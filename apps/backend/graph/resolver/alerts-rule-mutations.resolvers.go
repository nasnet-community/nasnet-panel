package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/graph/model"
	"backend/internal/alerts"
	"backend/internal/apperrors"
	"backend/internal/services"
	"context"
	"fmt"
	"time"
)

// ApplyAlertRuleTemplate is the resolver for the applyAlertRuleTemplate field.
func (r *mutationResolver) ApplyAlertRuleTemplate(ctx context.Context, templateID string, variables map[string]any, customizations *model.CreateAlertRuleInput) (*model.AlertRulePayload, error) {
	// Check authorization: user must be authenticated
	if r.authService == nil {
		return &model.AlertRulePayload{
			Errors: []*model.MutationError{
				{Code: "UNAUTHORIZED", Message: "authentication service not available"},
			},
		}, nil
	}

	if r.AlertRuleTemplateService == nil {
		return &model.AlertRulePayload{
			Errors: []*model.MutationError{
				{Code: "SERVICE_UNAVAILABLE", Message: "alert rule template service not available"},
			},
		}, nil
	}

	// Validate input: templateID must not be empty
	if templateID == "" {
		return &model.AlertRulePayload{
			Errors: []*model.MutationError{
				{Code: "INVALID_INPUT", Message: "template id cannot be empty"},
			},
		}, nil
	}

	// Build customizations input
	var input services.CreateAlertRuleInput
	if customizations != nil {
		input = convertCreateAlertRuleInput(customizations)
	}

	// Apply template via service (delegates to AlertService.CreateRule)
	rule, err := r.AlertRuleTemplateService.ApplyTemplate(ctx, templateID, variables, input)
	if err != nil {
		if r.log != nil {
			r.log.Errorw("failed to apply alert rule template", "templateId", templateID, "error", err)
		}
		return &model.AlertRulePayload{
			Errors: []*model.MutationError{
				{Code: "TEMPLATE_APPLICATION_FAILED", Message: err.Error()},
			},
		}, nil
	}

	if r.log != nil {
		r.log.Infow("applied alert rule template", "templateId", templateID, "ruleId", rule.ID)
	}

	return &model.AlertRulePayload{
		AlertRule: convertAlertRuleToModel(rule),
	}, nil
}

// SaveCustomAlertRuleTemplate is the resolver for the saveCustomAlertRuleTemplate field.
//
//nolint:gocyclo // resolver logic requires branching for multiple input fields
func (r *mutationResolver) SaveCustomAlertRuleTemplate(ctx context.Context, input model.SaveAlertRuleTemplateInput) (*model.AlertRuleTemplatePayload, error) {
	// Check authorization: user must be authenticated
	if r.authService == nil {
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "UNAUTHORIZED", Message: "authentication service not available"},
			},
		}, nil
	}

	if r.AlertRuleTemplateService == nil {
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "SERVICE_UNAVAILABLE", Message: "alert rule template service not available"},
			},
		}, nil
	}

	// Validate input: name must not be empty
	if input.Name == "" {
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "INVALID_INPUT", Message: "template name cannot be empty"},
			},
		}, nil
	}

	// Validate input: conditions must not be empty
	if len(input.Conditions) == 0 {
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "INVALID_INPUT", Message: "template must have at least one condition"},
			},
		}, nil
	}

	// Generate a unique ID for the template
	tmplID := fmt.Sprintf("custom-%d", time.Now().Unix())

	// Convert input to service template
	tmpl := &alerts.AlertRuleTemplate{
		ID:          tmplID,
		Name:        input.Name,
		Description: input.Description,
		Category:    alerts.CategoryCustom, // Always CUSTOM for user-created templates
		EventType:   input.EventType,
		Severity:    string(input.Severity),
		Channels:    input.Channels,
		Version:     "1.0.0",
	}

	// Convert variables from Omittable
	//nolint:nestif // nested conditions required for validation logic
	if input.Variables.IsSet() {
		vars := input.Variables.Value()
		tmpl.Variables = make([]alerts.AlertRuleTemplateVariable, len(vars))
		for i, v := range vars {
			variable := alerts.AlertRuleTemplateVariable{
				Name:     v.Name,
				Label:    v.Label,
				Type:     alerts.AlertRuleTemplateVariableType(v.Type),
				Required: v.Required,
			}

			// Handle optional Omittable fields
			if v.DefaultValue.IsSet() {
				variable.DefaultValue = v.DefaultValue.Value()
			}
			if v.Min.IsSet() {
				variable.Min = v.Min.Value()
			}
			if v.Max.IsSet() {
				variable.Max = v.Max.Value()
			}
			if v.Unit.IsSet() {
				variable.Unit = v.Unit.Value()
			}
			if v.Description.IsSet() {
				variable.Description = v.Description.Value()
			}

			tmpl.Variables[i] = variable
		}
	}

	// Convert conditions
	tmpl.Conditions = make([]alerts.TemplateCondition, len(input.Conditions))
	for i, cond := range input.Conditions {
		tmpl.Conditions[i] = alerts.TemplateCondition{
			Field:    cond.Field,
			Operator: string(cond.Operator),
			Value:    cond.Value,
		}
	}

	// Convert throttle if present
	if input.Throttle.IsSet() {
		throttle := input.Throttle.Value()
		if throttle != nil {
			tmpl.Throttle = &alerts.TemplateThrottle{
				MaxAlerts:     throttle.MaxAlerts,
				PeriodSeconds: throttle.PeriodSeconds,
			}
			if throttle.GroupByField.IsSet() {
				tmpl.Throttle.GroupByField = throttle.GroupByField.Value()
			}
		}
	}

	// Save template
	saved, err := r.AlertRuleTemplateService.SaveCustomTemplate(ctx, tmpl)
	if err != nil {
		if r.log != nil {
			r.log.Errorw("failed to save custom alert rule template", "name", input.Name, "error", err)
		}
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "SAVE_FAILED", Message: err.Error()},
			},
		}, nil
	}

	if r.log != nil {
		r.log.Infow("saved custom alert rule template", "id", saved.ID, "name", saved.Name)
	}

	return &model.AlertRuleTemplatePayload{
		Template: convertAlertRuleTemplateToModel(saved),
	}, nil
}

// DeleteCustomAlertRuleTemplate is the resolver for the deleteCustomAlertRuleTemplate field.
func (r *mutationResolver) DeleteCustomAlertRuleTemplate(ctx context.Context, id string) (*model.DeletePayload, error) {
	// Check authorization: user must be authenticated
	if r.authService == nil {
		return nil, apperrors.NewAuthError(apperrors.CodeAuthFailed, "authentication service not available")
	}

	if r.AlertRuleTemplateService == nil {
		return nil, apperrors.NewValidationError("alertRuleTemplateService", nil, "service not available")
	}

	// Validate input: id must not be empty
	if id == "" {
		return nil, apperrors.NewValidationError("id", id, "template id cannot be empty")
	}

	err := r.AlertRuleTemplateService.DeleteCustomTemplate(ctx, id)
	if err != nil {
		if r.log != nil {
			r.log.Errorw("failed to delete custom alert rule template", "id", id, "error", err)
		}
		return nil, apperrors.NewProtocolError(apperrors.CodeCommandFailed, "failed to delete template", "graphql").WithCause(err)
	}

	if r.log != nil {
		r.log.Infow("deleted custom alert rule template", "id", id)
	}

	return &model.DeletePayload{
		Success: true,
	}, nil
}

// ImportAlertRuleTemplate is the resolver for the importAlertRuleTemplate field.
func (r *mutationResolver) ImportAlertRuleTemplate(ctx context.Context, json string) (*model.AlertRuleTemplatePayload, error) {
	// Check authorization: user must be authenticated
	if r.authService == nil {
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "UNAUTHORIZED", Message: "authentication service not available"},
			},
		}, nil
	}

	if r.AlertRuleTemplateService == nil {
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "SERVICE_UNAVAILABLE", Message: "alert rule template service not available"},
			},
		}, nil
	}

	// Validate input: json must not be empty
	if json == "" {
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "INVALID_INPUT", Message: "template json cannot be empty"},
			},
		}, nil
	}

	template, err := r.AlertRuleTemplateService.ImportTemplate(ctx, json)
	if err != nil {
		if r.log != nil {
			r.log.Errorw("failed to import alert rule template", "error", err)
		}
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "IMPORT_FAILED", Message: err.Error()},
			},
		}, nil
	}

	if r.log != nil {
		r.log.Infow("imported alert rule template", "id", template.ID, "name", template.Name)
	}

	return &model.AlertRuleTemplatePayload{
		Template: convertAlertRuleTemplateToModel(template),
	}, nil
}

// ExportAlertRuleTemplate is the resolver for the exportAlertRuleTemplate field.
func (r *mutationResolver) ExportAlertRuleTemplate(ctx context.Context, id string) (string, error) {
	// Check authorization: user must be authenticated
	if r.authService == nil {
		return "", apperrors.NewAuthError(apperrors.CodeAuthFailed, "authentication service not available")
	}

	if r.AlertRuleTemplateService == nil {
		return "", apperrors.NewValidationError("alertRuleTemplateService", nil, "service not available")
	}

	// Validate input: id must not be empty
	if id == "" {
		return "", apperrors.NewValidationError("id", id, "template id cannot be empty")
	}

	jsonStr, err := r.AlertRuleTemplateService.ExportTemplate(ctx, id)
	if err != nil {
		if r.log != nil {
			r.log.Errorw("failed to export alert rule template", "id", id, "error", err)
		}
		return "", apperrors.NewProtocolError(apperrors.CodeCommandFailed, "export failed", "graphql").WithCause(err)
	}

	if r.log != nil {
		r.log.Infow("exported alert rule template", "id", id)
	}

	return jsonStr, nil
}

// ApplyAlertTemplate is the resolver for the applyAlertTemplate field.
func (r *mutationResolver) ApplyAlertTemplate(ctx context.Context, input model.ApplyAlertTemplateInput) (*model.AlertRulePayload, error) {
	panic(apperrors.NewProtocolError(apperrors.CodeCommandFailed, "not implemented: ApplyAlertTemplate - applyAlertTemplate", "graphql"))
}

// SaveAlertTemplate is the resolver for the saveAlertTemplate field.
func (r *mutationResolver) SaveAlertTemplate(ctx context.Context, input model.SaveAlertTemplateInput) (*model.AlertTemplatePayload, error) {
	panic(apperrors.NewProtocolError(apperrors.CodeCommandFailed, "not implemented: SaveAlertTemplate - saveAlertTemplate", "graphql"))
}

// DeleteAlertTemplate is the resolver for the deleteAlertTemplate field.
func (r *mutationResolver) DeleteAlertTemplate(ctx context.Context, id string) (*model.DeletePayload, error) {
	panic(apperrors.NewProtocolError(apperrors.CodeCommandFailed, "not implemented: DeleteAlertTemplate - deleteAlertTemplate", "graphql"))
}

// ResetAlertTemplate is the resolver for the resetAlertTemplate field.
func (r *mutationResolver) ResetAlertTemplate(ctx context.Context, eventType string, channel model.NotificationChannel) (*model.DeletePayload, error) {
	panic(apperrors.NewProtocolError(apperrors.CodeCommandFailed, "not implemented: ResetAlertTemplate - resetAlertTemplate", "graphql"))
}

// PreviewNotificationTemplate is the resolver for the previewNotificationTemplate field.
func (r *mutationResolver) PreviewNotificationTemplate(ctx context.Context, input model.PreviewNotificationTemplateInput) (*model.NotificationTemplatePreview, error) {
	panic(apperrors.NewProtocolError(apperrors.CodeCommandFailed, "not implemented: PreviewNotificationTemplate - previewNotificationTemplate", "graphql"))
}

// CreateAlertRule is the resolver for the createAlertRule field.
func (r *mutationResolver) CreateAlertRule(ctx context.Context, input model.CreateAlertRuleInput) (*model.AlertRulePayload, error) {
	panic(apperrors.NewProtocolError(apperrors.CodeCommandFailed, "not implemented: CreateAlertRule - createAlertRule", "graphql"))
}

// UpdateAlertRule is the resolver for the updateAlertRule field.
func (r *mutationResolver) UpdateAlertRule(ctx context.Context, id string, input model.UpdateAlertRuleInput) (*model.AlertRulePayload, error) {
	panic(apperrors.NewProtocolError(apperrors.CodeCommandFailed, "not implemented: UpdateAlertRule - updateAlertRule", "graphql"))
}

// ToggleAlertRule is the resolver for the toggleAlertRule field.
func (r *mutationResolver) ToggleAlertRule(ctx context.Context, id string) (*model.AlertRulePayload, error) {
	panic(apperrors.NewProtocolError(apperrors.CodeCommandFailed, "not implemented: ToggleAlertRule - toggleAlertRule", "graphql"))
}

// DeleteAlertRule is the resolver for the deleteAlertRule field.
func (r *mutationResolver) DeleteAlertRule(ctx context.Context, id string) (*model.DeletePayload, error) {
	panic(apperrors.NewProtocolError(apperrors.CodeCommandFailed, "not implemented: DeleteAlertRule - deleteAlertRule", "graphql"))
}
