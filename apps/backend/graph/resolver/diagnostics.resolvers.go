package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"backend/graph/model"
	"backend/internal/diagnostics"
	"context"
	"fmt"
)

// RunDiagnostics is the resolver for the runDiagnostics field.
func (r *mutationResolver) RunDiagnostics(ctx context.Context, routerID string) (*model.DiagnosticReport, error) {
	panic(fmt.Errorf("not implemented: RunDiagnostics - runDiagnostics"))
}

// ResetCircuitBreaker is the resolver for the resetCircuitBreaker field.
func (r *mutationResolver) ResetCircuitBreaker(ctx context.Context, routerID string) (*model.CircuitBreakerStatus, error) {
	panic(fmt.Errorf("not implemented: ResetCircuitBreaker - resetCircuitBreaker"))
}

// ConnectionAttempts is the resolver for the connectionAttempts field.
func (r *queryResolver) ConnectionAttempts(ctx context.Context, routerID string, limit *int) ([]*model.ConnectionAttempt, error) {
	panic(fmt.Errorf("not implemented: ConnectionAttempts - connectionAttempts"))
}

// CircuitBreakerStatus is the resolver for the circuitBreakerStatus field.
func (r *queryResolver) CircuitBreakerStatus(ctx context.Context, routerID string) (*model.CircuitBreakerStatus, error) {
	panic(fmt.Errorf("not implemented: CircuitBreakerStatus - circuitBreakerStatus"))
}

// CircuitBreakerStateChanged is the resolver for the circuitBreakerStateChanged field.
func (r *subscriptionResolver) CircuitBreakerStateChanged(ctx context.Context, routerID *string) (<-chan *model.CircuitBreakerStatus, error) {
	panic(fmt.Errorf("not implemented: CircuitBreakerStateChanged - circuitBreakerStateChanged"))
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *Resolver) ConnectionAttempts(ctx context.Context, routerID string, limit *int) ([]*model.ConnectionAttempt, error) {
	if r.DiagnosticsService == nil {
		return nil, fmt.Errorf("diagnostics service not initialized")
	}

	l := 10
	if limit != nil && *limit > 0 {
		l = *limit
	}

	attempts, err := r.DiagnosticsService.GetConnectionAttempts(ctx, routerID, l)
	if err != nil {
		return nil, err
	}

	return mapConnectionAttempts(attempts), nil
}
func (r *Resolver) CircuitBreakerStatus(ctx context.Context, routerID string) (*model.CircuitBreakerStatus, error) {
	if r.DiagnosticsService == nil {
		return nil, fmt.Errorf("diagnostics service not initialized")
	}

	status, err := r.DiagnosticsService.GetCircuitBreakerStatus(ctx, routerID)
	if err != nil {
		return nil, err
	}

	return mapCircuitBreakerStatus(status), nil
}
func (r *Resolver) RunDiagnostics(ctx context.Context, routerID string) (*model.DiagnosticReport, error) {
	if r.DiagnosticsService == nil {
		return nil, fmt.Errorf("diagnostics service not initialized")
	}

	report, err := r.DiagnosticsService.RunDiagnostics(ctx, routerID)
	if err != nil {
		return nil, err
	}

	return mapDiagnosticReport(report), nil
}
func (r *Resolver) ResetCircuitBreaker(ctx context.Context, routerID string) (*model.CircuitBreakerStatus, error) {
	if r.DiagnosticsService == nil {
		return nil, fmt.Errorf("diagnostics service not initialized")
	}

	status, err := r.DiagnosticsService.ResetCircuitBreaker(ctx, routerID)
	if err != nil {
		return nil, err
	}

	// Publish event for circuit breaker reset
	if r.EventPublisher != nil {
		// Note: In a real implementation, this would publish a typed event
		// r.EventPublisher.PublishCircuitBreakerReset(ctx, routerID)
	}

	return mapCircuitBreakerStatus(status), nil
}
func mapConnectionAttempts(attempts []diagnostics.ConnectionAttempt) []*model.ConnectionAttempt {
	result := make([]*model.ConnectionAttempt, len(attempts))
	for i, a := range attempts {
		result[i] = &model.ConnectionAttempt{
			Protocol:      mapProtocol(a.Protocol),
			StartedAt:     a.StartedAt,
			EndedAt:       a.EndedAt,
			Success:       a.Success,
			ErrorCode:     a.ErrorCode,
			ErrorMessage:  a.ErrorMessage,
			ErrorCategory: mapErrorCategory(a.ErrorCategory),
		}
	}
	return result
}
func mapProtocol(p diagnostics.Protocol) model.Protocol {
	switch p {
	case diagnostics.ProtocolREST:
		return model.ProtocolRest
	case diagnostics.ProtocolAPI:
		return model.ProtocolAPI
	case diagnostics.ProtocolAPISSL:
		return model.ProtocolAPISsl
	case diagnostics.ProtocolSSH:
		return model.ProtocolSSH
	case diagnostics.ProtocolTelnet:
		return model.ProtocolTelnet
	default:
		return model.ProtocolAPI
	}
}
func mapErrorCategory(c *diagnostics.ErrorCategory) *model.ErrorCategory {
	if c == nil {
		return nil
	}
	var result model.ErrorCategory
	switch *c {
	case diagnostics.ErrorCategoryTimeout:
		result = model.ErrorCategoryTimeout
	case diagnostics.ErrorCategoryRefused:
		result = model.ErrorCategoryRefused
	case diagnostics.ErrorCategoryAuthFailed:
		result = model.ErrorCategoryAuthFailed
	case diagnostics.ErrorCategoryProtocolError:
		result = model.ErrorCategoryProtocolError
	case diagnostics.ErrorCategoryNetworkError:
		result = model.ErrorCategoryNetworkError
	case diagnostics.ErrorCategoryTLSError:
		result = model.ErrorCategoryTLSError
	default:
		result = model.ErrorCategoryProtocolError
	}
	return &result
}
func mapCircuitBreakerStatus(s *diagnostics.CircuitBreakerStatus) *model.CircuitBreakerStatus {
	if s == nil {
		return nil
	}
	return &model.CircuitBreakerStatus{
		RouterID:                 s.RouterID,
		State:                    mapCircuitBreakerState(s.State),
		FailureCount:             s.FailureCount,
		FailureThreshold:         s.FailureThreshold,
		CooldownRemainingSeconds: s.CooldownRemainingSeconds,
		LastFailureAt:            s.LastFailureAt,
		LastSuccessAt:            s.LastSuccessAt,
	}
}
func mapCircuitBreakerState(s diagnostics.CircuitBreakerState) model.CircuitBreakerState {
	switch s {
	case diagnostics.CircuitBreakerStateClosed:
		return model.CircuitBreakerStateClosed
	case diagnostics.CircuitBreakerStateOpen:
		return model.CircuitBreakerStateOpen
	case diagnostics.CircuitBreakerStateHalfOpen:
		return model.CircuitBreakerStateHalfOpen
	default:
		return model.CircuitBreakerStateClosed
	}
}
func mapDiagnosticReport(r *diagnostics.DiagnosticReport) *model.DiagnosticReport {
	if r == nil {
		return nil
	}
	return &model.DiagnosticReport{
		RouterID:         r.RouterID,
		Timestamp:        r.Timestamp,
		NetworkReachable: r.NetworkReachable,
		PortStatus:       mapPortStatuses(r.PortStatus),
		TLSStatus:        mapTLSStatus(r.TLSStatus),
		AuthStatus:       mapAuthStatus(r.AuthStatus),
		Suggestions:      mapSuggestions(r.Suggestions),
		RawReport:        r.RawReport,
	}
}
func mapPortStatuses(ports []diagnostics.PortStatus) []*model.PortStatus {
	result := make([]*model.PortStatus, len(ports))
	for i, p := range ports {
		result[i] = &model.PortStatus{
			Port:           p.Port,
			Service:        p.Service,
			Open:           p.Open,
			ResponseTimeMs: p.ResponseTimeMs,
			Error:          p.Error,
		}
	}
	return result
}
func mapTLSStatus(s *diagnostics.TLSStatus) *model.TLSStatus {
	if s == nil {
		return nil
	}
	return &model.TLSStatus{
		Valid:     s.Valid,
		Issuer:    s.Issuer,
		Subject:   s.Subject,
		ExpiresAt: s.ExpiresAt,
		Error:     s.Error,
	}
}
func mapAuthStatus(s diagnostics.AuthStatus) *model.AuthStatus {
	return &model.AuthStatus{
		Tested:    s.Tested,
		Success:   s.Success,
		Error:     s.Error,
		ErrorCode: s.ErrorCode,
	}
}
func mapSuggestions(suggestions []diagnostics.DiagnosticSuggestion) []*model.DiagnosticSuggestion {
	result := make([]*model.DiagnosticSuggestion, len(suggestions))
	for i, s := range suggestions {
		result[i] = &model.DiagnosticSuggestion{
			Severity:    mapSuggestionSeverity(s.Severity),
			Title:       s.Title,
			Description: s.Description,
			Action:      s.Action,
			DocsURL:     s.DocsURL,
		}
	}
	return result
}
func mapSuggestionSeverity(s diagnostics.SuggestionSeverity) model.SuggestionSeverity {
	switch s {
	case diagnostics.SuggestionSeverityInfo:
		return model.SuggestionSeverityInfo
	case diagnostics.SuggestionSeverityWarning:
		return model.SuggestionSeverityWarning
	case diagnostics.SuggestionSeverityError:
		return model.SuggestionSeverityError
	case diagnostics.SuggestionSeverityCritical:
		return model.SuggestionSeverityCritical
	default:
		return model.SuggestionSeverityInfo
	}
}
