package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/graph/model"
	"backend/internal/errors"
	"context"
)

// RunDNSLookup is the resolver for the runDnsLookup field.
func (r *mutationResolver) RunDNSLookup(ctx context.Context, input model.DNSLookupInput) (*model.DNSLookupResult, error) {
	// Validate input
	if input.DeviceID == "" {
		panic(errors.NewValidationError("input", nil, "deviceID cannot be empty"))
	}
	if input.Hostname == "" {
		panic(errors.NewValidationError("input", nil, "hostname cannot be empty"))
	}
	// Context is used for timeout handling in implementation
	_ = ctx
	panic(errors.NewValidationError("input", nil, "not implemented: RunDNSLookup - runDnsLookup"))
}

// FlushDNSCache is the resolver for the flushDnsCache field.
func (r *mutationResolver) FlushDNSCache(ctx context.Context, deviceID string) (*model.FlushDNSCacheResult, error) {
	if deviceID == "" {
		panic(errors.NewValidationError("input", nil, "deviceID cannot be empty"))
	}
	// Context is used for timeout handling in implementation
	_ = ctx
	panic(errors.NewValidationError("input", nil, "not implemented: FlushDNSCache - flushDnsCache"))
}

// DNSServers is the resolver for the dnsServers field.
func (r *queryResolver) DNSServers(ctx context.Context, deviceID string) (*model.DNSServers, error) {
	if deviceID == "" {
		panic(errors.NewValidationError("input", nil, "deviceID cannot be empty"))
	}
	// Context is used for timeout handling in implementation
	_ = ctx
	panic(errors.NewValidationError("input", nil, "not implemented: DNSServers - dnsServers"))
}

// DNSCacheStats is the resolver for the dnsCacheStats field.
func (r *queryResolver) DNSCacheStats(ctx context.Context, deviceID string) (*model.DNSCacheStats, error) {
	if deviceID == "" {
		panic(errors.NewValidationError("input", nil, "deviceID cannot be empty"))
	}
	// Context is used for timeout handling in implementation
	_ = ctx
	panic(errors.NewValidationError("input", nil, "not implemented: DNSCacheStats - dnsCacheStats"))
}

// DNSBenchmark is the resolver for the dnsBenchmark field.
func (r *queryResolver) DNSBenchmark(ctx context.Context, deviceID string) (*model.DNSBenchmarkResult, error) {
	if deviceID == "" {
		panic(errors.NewValidationError("input", nil, "deviceID cannot be empty"))
	}
	// Context is used for timeout handling in implementation
	_ = ctx
	panic(errors.NewValidationError("input", nil, "not implemented: DNSBenchmark - dnsBenchmark"))
}
