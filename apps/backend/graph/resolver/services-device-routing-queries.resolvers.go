package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/generated/ent"
	"backend/generated/ent/devicerouting"
	"backend/graph/model"
	"backend/internal/errors"
	"context"
	"fmt"
)

// DeviceRoutingMatrix resolves the deviceRoutingMatrix query.
func (r *queryResolver) DeviceRoutingMatrix(ctx context.Context, routerID string) (*model.DeviceRoutingMatrix, error) {
	// Validate input
	if routerID == "" {
		return nil, errors.NewValidationError("routerID", "", "required")
	}

	// Verify routing matrix service is configured
	if r.Resolver.RoutingMatrixSvc == nil {
		return nil, errors.NewResourceError(errors.CodeDependencyNotReady, "routing matrix service not configured", "RoutingMatrixService", "")
	}

	// Query the full device routing matrix
	matrix, err := r.Resolver.RoutingMatrixSvc.GetDeviceRoutingMatrix(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeResourceNotFound, errors.CategoryResource, "failed to get device routing matrix")
	}

	// Verify matrix is not nil
	if matrix == nil {
		return nil, errors.NewResourceError(errors.CodeResourceNotFound, "device routing matrix is nil", "DeviceRoutingMatrix", routerID)
	}

	// Convert to GraphQL model
	return convertDeviceRoutingMatrix(matrix), nil
}

// DeviceRoutings resolves the deviceRoutings query.
func (r *queryResolver) DeviceRoutings(ctx context.Context, routerID string) ([]*model.DeviceRouting, error) {
	// Validate input
	if routerID == "" {
		return nil, errors.NewValidationError("routerID", "", "required")
	}

	// Query all device routings for this router
	routings, err := r.db.DeviceRouting.
		Query().
		Where(devicerouting.RouterIDEQ(routerID)).
		All(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeResourceNotFound, errors.CategoryResource, "failed to query device routings")
	}

	// Return empty slice if no routings found (not an error)
	if len(routings) == 0 {
		return make([]*model.DeviceRouting, 0), nil
	}

	// Convert to GraphQL model
	result := make([]*model.DeviceRouting, len(routings))
	for i, dr := range routings {
		if dr == nil {
			return nil, errors.NewResourceError(errors.CodeResourceNotFound, fmt.Sprintf("device routing is nil at index %d", i), "DeviceRouting", "")
		}
		result[i] = convertDeviceRouting(dr)
	}

	return result, nil
}

// DeviceRouting resolves the deviceRouting query.
func (r *queryResolver) DeviceRouting(ctx context.Context, routerID string, routingID string) (*model.DeviceRouting, error) {
	// Validate inputs
	if routerID == "" {
		return nil, errors.NewValidationError("routerID", "", "required")
	}
	if routingID == "" {
		return nil, errors.NewValidationError("routingID", "", "required")
	}

	// Query specific device routing
	dr, err := r.db.DeviceRouting.Get(ctx, routingID)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, errors.NewResourceError(errors.CodeResourceNotFound, "device routing not found", "DeviceRouting", routingID)
		}
		return nil, errors.Wrap(err, errors.CodeResourceNotFound, errors.CategoryResource, "failed to query device routing")
	}

	// Verify it belongs to the correct router
	if dr.RouterID != routerID {
		return nil, errors.NewValidationError("routerID", routerID, "routing does not belong to router")
	}

	return convertDeviceRouting(dr), nil
}
