package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/generated/ent"
	"backend/generated/ent/devicerouting"
	"backend/graph/model"
	"backend/internal/apperrors"
	"context"
	"fmt"
)

// DeviceRoutingMatrix resolves the deviceRoutingMatrix query.
func (r *queryResolver) DeviceRoutingMatrix(ctx context.Context, routerID string) (*model.DeviceRoutingMatrix, error) {
	// Validate input
	if routerID == "" {
		return nil, apperrors.NewValidationError("routerID", "", "required")
	}

	// Verify routing matrix service is configured
	if r.RoutingMatrixSvc == nil {
		return nil, apperrors.NewResourceError(apperrors.CodeDependencyNotReady, "routing matrix service not configured", "RoutingMatrixService", "")
	}

	// Query the full device routing matrix
	matrix, err := r.RoutingMatrixSvc.GetDeviceRoutingMatrix(ctx)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryResource, "failed to get device routing matrix")
	}

	// Verify matrix is not nil
	if matrix == nil {
		return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, "device routing matrix is nil", "DeviceRoutingMatrix", routerID)
	}

	// Convert to GraphQL model
	return convertDeviceRoutingMatrix(matrix), nil
}

// DeviceRoutings resolves the deviceRoutings query.
func (r *queryResolver) DeviceRoutings(ctx context.Context, routerID string) ([]*model.DeviceRouting, error) {
	// Validate input
	if routerID == "" {
		return nil, apperrors.NewValidationError("routerID", "", "required")
	}

	// Query all device routings for this router
	routings, err := r.db.DeviceRouting.
		Query().
		Where(devicerouting.RouterIDEQ(routerID)).
		All(ctx)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryResource, "failed to query device routings")
	}

	// Return empty slice if no routings found (not an error)
	if len(routings) == 0 {
		return make([]*model.DeviceRouting, 0), nil
	}

	// Convert to GraphQL model
	result := make([]*model.DeviceRouting, len(routings))
	for i, dr := range routings {
		if dr == nil {
			return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, fmt.Sprintf("device routing is nil at index %d", i), "DeviceRouting", "")
		}
		result[i] = convertDeviceRouting(dr)
	}

	return result, nil
}

// DeviceRouting resolves the deviceRouting query.
func (r *queryResolver) DeviceRouting(ctx context.Context, routerID string, routingID string) (*model.DeviceRouting, error) {
	// Validate inputs
	if routerID == "" {
		return nil, apperrors.NewValidationError("routerID", "", "required")
	}
	if routingID == "" {
		return nil, apperrors.NewValidationError("routingID", "", "required")
	}

	// Query specific device routing
	dr, err := r.db.DeviceRouting.Get(ctx, routingID)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, "device routing not found", "DeviceRouting", routingID)
		}
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryResource, "failed to query device routing")
	}

	// Verify it belongs to the correct router
	if dr.RouterID != routerID {
		return nil, apperrors.NewValidationError("routerID", routerID, "routing does not belong to router")
	}

	return convertDeviceRouting(dr), nil
}

// KillSwitchStatus resolves the killSwitchStatus query.
func (r *queryResolver) KillSwitchStatus(ctx context.Context, routerID string, deviceID string) (*model.KillSwitchStatus, error) {
	// Validate inputs
	if routerID == "" {
		return nil, apperrors.NewValidationError("routerID", "", "required")
	}
	if deviceID == "" {
		return nil, apperrors.NewValidationError("deviceID", "", "required")
	}

	// Query the device routing to get kill switch status
	dr, err := r.db.DeviceRouting.
		Query().
		Where(devicerouting.DeviceIDEQ(deviceID)).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, "device routing not found", "DeviceRouting", deviceID)
		}
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryResource, "failed to query device routing")
	}

	// Verify device routing is not nil
	if dr == nil {
		return nil, apperrors.NewResourceError(apperrors.CodeResourceNotFound, "device routing is nil after query", "DeviceRouting", deviceID)
	}

	// Verify it belongs to the correct router
	if dr.RouterID != routerID {
		return nil, apperrors.NewValidationError("routerID", routerID, "routing does not belong to router")
	}

	// Map kill switch mode from DB to GraphQL enum
	var killSwitchMode model.KillSwitchMode
	//nolint:exhaustive // string value switch, default handles all cases
	switch dr.KillSwitchMode {
	case "block_all":
		killSwitchMode = model.KillSwitchModeBlockAll
	case "fallback_service":
		killSwitchMode = model.KillSwitchModeFallbackService
	case "allow_direct":
		killSwitchMode = model.KillSwitchModeAllowDirect
	default:
		killSwitchMode = model.KillSwitchModeBlockAll
	}

	// TODO: Query activation history for activation count and last deactivation timestamp
	// For now, we'll return basic info from the routing record
	activationCount := 0
	if dr.KillSwitchActivatedAt != nil {
		activationCount = 1 // Simple approximation
	}

	// Safe conversion of fallback interface ID to pointer
	fallbackInterfaceID := ""
	if dr.KillSwitchFallbackInterfaceID != "" {
		fallbackInterfaceID = dr.KillSwitchFallbackInterfaceID
	}

	return &model.KillSwitchStatus{
		Enabled:              dr.KillSwitchEnabled,
		Mode:                 killSwitchMode,
		Active:               dr.KillSwitchActive,
		LastActivatedAt:      dr.KillSwitchActivatedAt,
		LastDeactivatedAt:    nil, // TODO: Track deactivation timestamps
		FallbackInterfaceID:  &fallbackInterfaceID,
		ActivationCount:      activationCount,
		LastActivationReason: nil, // TODO: Track activation reason
	}, nil
}

// DeviceRoutingChanged resolves the deviceRoutingChanged subscription.
func (r *subscriptionResolver) DeviceRoutingChanged(ctx context.Context, routerID string) (<-chan *model.DeviceRoutingEvent, error) {
	return r.subscribeToDeviceRoutingEvents(ctx, routerID, "device.routing.changed", "failed to subscribe to routing events")
}

// KillSwitchChanged resolves the killSwitchChanged subscription.
func (r *subscriptionResolver) KillSwitchChanged(ctx context.Context, routerID string) (<-chan *model.DeviceRoutingEvent, error) {
	return r.subscribeToDeviceRoutingEvents(ctx, routerID, "device.killswitch.*", "failed to subscribe to kill switch events")
}
