package resolver

// This file contains queries for update information.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/generated/ent/serviceinstance"
	"backend/graph/model"
	"backend/internal/errors"
	"context"
	"time"
)

// AvailableUpdates returns list of available updates for router's service instances.
func (r *queryResolver) AvailableUpdates(ctx context.Context, routerID string) ([]*model.UpdateInfo, error) {
	// Authorization check
	if _, ok := ctx.Value(contextKeyUserID).(string); !ok {
		return nil, errors.NewValidationError("userID", "", "authentication required")
	}

	// Input validation
	if routerID == "" {
		return nil, errors.NewValidationError("routerID", "", "required")
	}

	// Service availability check
	if r.UpdateService == nil {
		return nil, errors.NewProtocolError(errors.CodeCommandFailed, "update service not initialized", "graphql")
	}

	instances, err := r.db.ServiceInstance.Query().
		Where(serviceinstance.RouterIDEQ(routerID)).
		All(ctx)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeProtocolError, errors.CategoryProtocol, "failed to query service instances")
	}

	var updates []*model.UpdateInfo
	for _, instance := range instances {
		updateInfo, available, err := r.UpdateService.CheckForUpdate(
			ctx,
			instance.FeatureID,
			instance.BinaryVersion,
		)
		if err != nil {
			r.log.Errorw("failed to check for update",
				"instance_id", instance.ID,
				"feature_id", instance.FeatureID,
				"error", err)
			continue
		}

		if !available {
			continue
		}

		publishedAt, err := time.Parse(time.RFC3339, updateInfo.PublishedAt)
		if err != nil {
			r.log.Errorw("failed to parse publish date",
				"instance_id", instance.ID,
				"published_at", updateInfo.PublishedAt,
				"error", err)
			// Use zero time if parsing fails
			publishedAt = time.Time{}
		}

		updates = append(updates, &model.UpdateInfo{
			InstanceID:       instance.ID,
			FeatureID:        instance.FeatureID,
			CurrentVersion:   instance.BinaryVersion,
			AvailableVersion: updateInfo.AvailableVersion,
			Severity:         mapSeverityToModel(string(updateInfo.Severity)),
			ReleaseNotes:     updateInfo.ReleaseNotes,
			PublishedAt:      publishedAt,
			DownloadURL:      updateInfo.DownloadURL,
			ChecksumURL:      &updateInfo.ChecksumURL,
			SizeBytes:        int(updateInfo.Size),
			Architecture:     updateInfo.Architecture,
		})
	}

	return updates, nil
}

// InstanceUpdateInfo returns update information for a specific service instance.
func (r *queryResolver) InstanceUpdateInfo(ctx context.Context, routerID string, instanceID string) (*model.UpdateInfo, error) {
	// Authorization check
	if _, ok := ctx.Value(contextKeyUserID).(string); !ok {
		return nil, errors.NewValidationError("userID", "", "authentication required")
	}

	// Input validation
	if routerID == "" {
		return nil, errors.NewValidationError("routerID", "", "required")
	}
	if instanceID == "" {
		return nil, errors.NewValidationError("instanceID", "", "required")
	}

	// Service availability check
	if r.UpdateService == nil {
		return nil, errors.NewProtocolError(errors.CodeCommandFailed, "update service not initialized", "graphql")
	}

	instance, err := r.db.ServiceInstance.Get(ctx, instanceID)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeProtocolError, errors.CategoryProtocol, "failed to query service instance")
	}

	updateInfo, available, err := r.UpdateService.CheckForUpdate(
		ctx,
		instance.FeatureID,
		instance.BinaryVersion,
	)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeProtocolError, errors.CategoryProtocol, "failed to check for update")
	}

	if !available {
		return nil, nil
	}

	publishedAt, err := time.Parse(time.RFC3339, updateInfo.PublishedAt)
	if err != nil {
		r.log.Errorw("failed to parse publish date",
			"instance_id", instance.ID,
			"published_at", updateInfo.PublishedAt,
			"error", err)
		// Use zero time if parsing fails
		publishedAt = time.Time{}
	}

	return &model.UpdateInfo{
		InstanceID:       instance.ID,
		FeatureID:        instance.FeatureID,
		CurrentVersion:   instance.BinaryVersion,
		AvailableVersion: updateInfo.AvailableVersion,
		Severity:         mapSeverityToModel(string(updateInfo.Severity)),
		ReleaseNotes:     updateInfo.ReleaseNotes,
		PublishedAt:      publishedAt,
		DownloadURL:      updateInfo.DownloadURL,
		ChecksumURL:      &updateInfo.ChecksumURL,
		SizeBytes:        int(updateInfo.Size),
		Architecture:     updateInfo.Architecture,
	}, nil
}
