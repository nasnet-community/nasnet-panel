package resolver

// This file contains queries for update information.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/generated/ent/serviceinstance"
	"backend/graph/model"
	"context"
	"fmt"
	"time"
)

// AvailableUpdates returns list of available updates for router's service instances.
func (r *queryResolver) AvailableUpdates(ctx context.Context, routerID string) ([]*model.UpdateInfo, error) {
	if r.UpdateService == nil {
		return nil, fmt.Errorf("update service not initialized")
	}

	instances, err := r.db.ServiceInstance.Query().
		Where(serviceinstance.RouterIDEQ(routerID)).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query service instances: %w", err)
	}

	var updates []*model.UpdateInfo
	for _, instance := range instances {
		updateInfo, available, err := r.UpdateService.CheckForUpdate(
			ctx,
			instance.FeatureID,
			instance.BinaryVersion,
		)
		if err != nil {
			r.log.Errorw("failed to check for update",
				"instance_id", instance.ID,
				"feature_id", instance.FeatureID,
				"error", err)
			continue
		}

		if !available {
			continue
		}

		publishedAt, _ := time.Parse(time.RFC3339, updateInfo.PublishedAt)

		updates = append(updates, &model.UpdateInfo{
			InstanceID:       instance.ID,
			FeatureID:        instance.FeatureID,
			CurrentVersion:   instance.BinaryVersion,
			AvailableVersion: updateInfo.AvailableVersion,
			Severity:         mapSeverityToModel(string(updateInfo.Severity)),
			ReleaseNotes:     updateInfo.ReleaseNotes,
			PublishedAt:      publishedAt,
			DownloadURL:      updateInfo.DownloadURL,
			ChecksumURL:      &updateInfo.ChecksumURL,
			SizeBytes:        int(updateInfo.Size),
			Architecture:     updateInfo.Architecture,
		})
	}

	return updates, nil
}

// InstanceUpdateInfo returns update information for a specific service instance.
func (r *queryResolver) InstanceUpdateInfo(ctx context.Context, routerID string, instanceID string) (*model.UpdateInfo, error) {
	if r.UpdateService == nil {
		return nil, fmt.Errorf("update service not initialized")
	}

	instance, err := r.db.ServiceInstance.Get(ctx, instanceID)
	if err != nil {
		return nil, fmt.Errorf("failed to query service instance: %w", err)
	}

	updateInfo, available, err := r.UpdateService.CheckForUpdate(
		ctx,
		instance.FeatureID,
		instance.BinaryVersion,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to check for update: %w", err)
	}

	if !available {
		return nil, nil
	}

	publishedAt, _ := time.Parse(time.RFC3339, updateInfo.PublishedAt)

	return &model.UpdateInfo{
		InstanceID:       instance.ID,
		FeatureID:        instance.FeatureID,
		CurrentVersion:   instance.BinaryVersion,
		AvailableVersion: updateInfo.AvailableVersion,
		Severity:         mapSeverityToModel(string(updateInfo.Severity)),
		ReleaseNotes:     updateInfo.ReleaseNotes,
		PublishedAt:      publishedAt,
		DownloadURL:      updateInfo.DownloadURL,
		ChecksumURL:      &updateInfo.ChecksumURL,
		SizeBytes:        int(updateInfo.Size),
		Architecture:     updateInfo.Architecture,
	}, nil
}
