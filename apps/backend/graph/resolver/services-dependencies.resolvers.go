package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/generated/ent"
	"backend/generated/ent/serviceinstance"
	"backend/graph/model"
	"context"
	"fmt"
)

// AddDependency is the resolver for the addDependency field.
func (r *mutationResolver) AddDependency(ctx context.Context, input model.AddDependencyInput) (*model.ServiceDependency, error) {
	if r.DependencyMgr == nil {
		return nil, fmt.Errorf("dependency manager is not available")
	}

	depID, err := r.DependencyMgr.AddDependency(
		ctx,
		input.FromInstanceID,
		input.ToInstanceID,
		string(input.DependencyType),
		input.AutoStart,
		input.HealthTimeoutSeconds,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to add dependency: %w", err)
	}

	// Fetch the created dependency from DB to return full model
	dep, err := r.db.ServiceDependency.Get(ctx, depID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch created dependency: %w", err)
	}

	return entDependencyToModel(dep), nil
}

// RemoveDependency is the resolver for the removeDependency field.
func (r *mutationResolver) RemoveDependency(ctx context.Context, input model.RemoveDependencyInput) (bool, error) {
	if r.DependencyMgr == nil {
		return false, fmt.Errorf("dependency manager is not available")
	}

	if err := r.DependencyMgr.RemoveDependency(ctx, input.DependencyID); err != nil {
		return false, fmt.Errorf("failed to remove dependency: %w", err)
	}

	return true, nil
}

// TriggerBootSequence is the resolver for the triggerBootSequence field.
func (r *mutationResolver) TriggerBootSequence(ctx context.Context) (bool, error) {
	if r.BootSequenceMgr == nil {
		return false, fmt.Errorf("boot sequence manager is not available")
	}

	if err := r.BootSequenceMgr.ExecuteBootSequence(ctx); err != nil {
		return false, fmt.Errorf("boot sequence failed: %w", err)
	}

	return true, nil
}

// SetResourceLimits is the resolver for the setResourceLimits mutation field.
// Applies cgroups v2 memory limits to a running service instance.
func (r *mutationResolver) SetResourceLimits(ctx context.Context, input model.SetResourceLimitsInput) (*model.ResourceLimitsPayload, error) {
	r.log.Infow("SetResourceLimits mutation called",
		"routerID", input.RouterID,
		"instanceID", input.InstanceID,
		"memoryMB", input.MemoryMb)

	// Check if InstanceManager is available
	if r.InstanceManager == nil {
		return &model.ResourceLimitsPayload{
			Success:        false,
			ResourceLimits: nil,
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Instance manager service is not available",
			}},
		}, nil
	}

	// Check if ResourceLimiter is available
	resourceLimiter := r.InstanceManager.ResourceLimiter()
	if resourceLimiter == nil {
		return &model.ResourceLimitsPayload{
			Success:        false,
			ResourceLimits: nil,
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Resource limiter service is not available",
			}},
		}, nil
	}

	// Load the service instance from database
	instance, err := r.db.ServiceInstance.Query().
		Where(serviceinstance.IDEQ(input.InstanceID)).
		Where(serviceinstance.RouterIDEQ(input.RouterID)).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return &model.ResourceLimitsPayload{
				Success:        false,
				ResourceLimits: nil,
				Errors: []*model.MutationError{{
					Code:    "NOT_FOUND",
					Message: fmt.Sprintf("Service instance not found: %s", input.InstanceID),
				}},
			}, nil
		}
		r.log.Errorw("failed to query service instance",
			"error", err,
			"instanceID", input.InstanceID)
		return &model.ResourceLimitsPayload{
			Success:        false,
			ResourceLimits: nil,
			Errors: []*model.MutationError{{
				Code:    "DATABASE_ERROR",
				Message: fmt.Sprintf("Failed to query service instance: %v", err),
			}},
		}, nil
	}

	// Check if instance is running (would need PID to apply limits)
	// For MVP, we'll assume we can get the PID from the instance manager
	// In production, this would be stored in the database or tracked by InstanceManager
	pid := 0 // Placeholder - would come from instance manager's process tracker

	// Validate memory limit (minimum 16MB)
	if input.MemoryMb < 16 {
		return &model.ResourceLimitsPayload{
			Success:        false,
			ResourceLimits: nil,
			Errors: []*model.MutationError{{
				Code:    "INVALID_INPUT",
				Message: fmt.Sprintf("Memory limit %dMB is below minimum 16MB", input.MemoryMb),
				Field:   ptrString("memoryMB"),
			}},
		}, nil
	}

	// Apply memory limit via ResourceLimiter
	err = resourceLimiter.ApplyMemoryLimit(ctx, pid, input.MemoryMb, instance.ID, instance.FeatureID)
	if err != nil {
		r.log.Errorw("failed to apply memory limit",
			"error", err,
			"instanceID", input.InstanceID,
			"memoryMB", input.MemoryMb)
		return &model.ResourceLimitsPayload{
			Success:        false,
			ResourceLimits: nil,
			Errors: []*model.MutationError{{
				Code:    "LIMIT_APPLICATION_FAILED",
				Message: fmt.Sprintf("Failed to apply memory limit: %v", err),
			}},
		}, nil
	}

	// Return success with updated resource limits
	resourceLimits := &model.ResourceLimits{
		MemoryMb:   input.MemoryMb,
		CPUPercent: nil,
		Applied:    resourceLimiter.IsCgroupsEnabled(),
	}

	r.log.Infow("resource limits applied successfully",
		"instanceID", input.InstanceID,
		"memoryMB", input.MemoryMb,
		"cgroupsEnabled", resourceLimits.Applied)

	return &model.ResourceLimitsPayload{
		Success:        true,
		ResourceLimits: resourceLimits,
		Errors:         []*model.MutationError{},
	}, nil
}

// ServiceDependencies is the resolver for the serviceDependencies field.
func (r *queryResolver) ServiceDependencies(ctx context.Context, instanceID string) ([]*model.ServiceDependency, error) {
	if r.DependencyMgr == nil {
		return nil, fmt.Errorf("dependency manager is not available")
	}

	deps, err := r.DependencyMgr.GetDependencies(ctx, instanceID)
	if err != nil {
		return nil, fmt.Errorf("failed to get dependencies: %w", err)
	}

	result := make([]*model.ServiceDependency, 0, len(deps))
	for _, dep := range deps {
		result = append(result, entDependencyToModel(dep))
	}
	return result, nil
}

// ServiceDependents is the resolver for the serviceDependents field.
func (r *queryResolver) ServiceDependents(ctx context.Context, instanceID string) ([]*model.ServiceDependency, error) {
	if r.DependencyMgr == nil {
		return nil, fmt.Errorf("dependency manager is not available")
	}

	deps, err := r.DependencyMgr.GetDependents(ctx, instanceID)
	if err != nil {
		return nil, fmt.Errorf("failed to get dependents: %w", err)
	}

	result := make([]*model.ServiceDependency, 0, len(deps))
	for _, dep := range deps {
		result = append(result, entDependencyToModel(dep))
	}
	return result, nil
}

// DependencyGraph is the resolver for the dependencyGraph field.
func (r *queryResolver) DependencyGraph(ctx context.Context, routerID string) (*model.DependencyGraph, error) {
	if r.DependencyMgr == nil {
		return nil, fmt.Errorf("dependency manager is not available")
	}

	graph, err := r.DependencyMgr.GetFullGraph(ctx, routerID)
	if err != nil {
		return nil, fmt.Errorf("failed to get dependency graph: %w", err)
	}

	nodes := make([]*model.DependencyGraphNode, 0, len(graph.Nodes))
	for _, n := range graph.Nodes {
		node := n // capture range variable
		nodes = append(nodes, &model.DependencyGraphNode{
			InstanceID:   node.InstanceID,
			InstanceName: node.InstanceName,
			FeatureID:    node.FeatureID,
			Status:       node.Status,
		})
	}

	edges := make([]*model.DependencyGraphEdge, 0, len(graph.Edges))
	for _, e := range graph.Edges {
		edge := e // capture range variable
		edges = append(edges, &model.DependencyGraphEdge{
			FromInstanceID:       edge.FromInstanceID,
			ToInstanceID:         edge.ToInstanceID,
			DependencyType:       model.DependencyType(edge.DependencyType),
			AutoStart:            edge.AutoStart,
			HealthTimeoutSeconds: edge.HealthTimeoutSeconds,
		})
	}

	return &model.DependencyGraph{
		Nodes: nodes,
		Edges: edges,
	}, nil
}

// BootSequenceProgress is the resolver for the bootSequenceProgress field.
// Returns a static "not in progress" state since the boot sequence manager
// does not expose in-flight progress (it is a synchronous operation).
func (r *queryResolver) BootSequenceProgress(ctx context.Context) (*model.BootSequenceProgress, error) {
	return &model.BootSequenceProgress{
		InProgress:         false,
		CurrentLayer:       nil,
		TotalLayers:        nil,
		StartedInstances:   []string{},
		FailedInstances:    []string{},
		RemainingInstances: []string{},
	}, nil
}

// entDependencyToModel converts an ent ServiceDependency to the GraphQL model type.
func entDependencyToModel(dep *ent.ServiceDependency) *model.ServiceDependency {
	if dep == nil {
		return nil
	}
	result := &model.ServiceDependency{
		ID:                   dep.ID,
		DependencyType:       model.DependencyType(dep.DependencyType),
		AutoStart:            dep.AutoStart,
		HealthTimeoutSeconds: dep.HealthTimeoutSeconds,
		CreatedAt:            dep.CreatedAt,
		UpdatedAt:            dep.UpdatedAt,
	}

	// Populate edge instances if they were eager-loaded
	if dep.Edges.FromInstance != nil {
		result.FromInstance = convertEntInstanceToModel(dep.Edges.FromInstance)
	}
	if dep.Edges.ToInstance != nil {
		result.ToInstance = convertEntInstanceToModel(dep.Edges.ToInstance)
	}

	return result
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) SetResourceLimits(ctx context.Context, input model.SetResourceLimitsInput) (*model.ResourceLimitsPayload, error) {
	r.log.Infow("SetResourceLimits mutation called",
		"routerID", input.RouterID,
		"instanceID", input.InstanceID,
		"memoryMB", input.MemoryMb)

	// Check if InstanceManager is available
	if r.InstanceManager == nil {
		return &model.ResourceLimitsPayload{
			Success:        false,
			ResourceLimits: nil,
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Instance manager service is not available",
			}},
		}, nil
	}

	// Check if ResourceLimiter is available
	resourceLimiter := r.InstanceManager.ResourceLimiter()
	if resourceLimiter == nil {
		return &model.ResourceLimitsPayload{
			Success:        false,
			ResourceLimits: nil,
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Resource limiter service is not available",
			}},
		}, nil
	}

	// Load the service instance from database
	instance, err := r.db.ServiceInstance.Query().
		Where(serviceinstance.IDEQ(input.InstanceID)).
		Where(serviceinstance.RouterIDEQ(input.RouterID)).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return &model.ResourceLimitsPayload{
				Success:        false,
				ResourceLimits: nil,
				Errors: []*model.MutationError{{
					Code:    "NOT_FOUND",
					Message: fmt.Sprintf("Service instance not found: %s", input.InstanceID),
				}},
			}, nil
		}
		r.log.Errorw("failed to query service instance",
			"error", err,
			"instanceID", input.InstanceID)
		return &model.ResourceLimitsPayload{
			Success:        false,
			ResourceLimits: nil,
			Errors: []*model.MutationError{{
				Code:    "DATABASE_ERROR",
				Message: fmt.Sprintf("Failed to query service instance: %v", err),
			}},
		}, nil
	}

	// Check if instance is running (would need PID to apply limits)
	// For MVP, we'll assume we can get the PID from the instance manager
	// In production, this would be stored in the database or tracked by InstanceManager
	pid := 0 // Placeholder - would come from instance manager's process tracker

	// Validate memory limit (minimum 16MB)
	if input.MemoryMb < 16 {
		return &model.ResourceLimitsPayload{
			Success:        false,
			ResourceLimits: nil,
			Errors: []*model.MutationError{{
				Code:    "INVALID_INPUT",
				Message: fmt.Sprintf("Memory limit %dMB is below minimum 16MB", input.MemoryMb),
				Field:   ptrString("memoryMB"),
			}},
		}, nil
	}

	// Apply memory limit via ResourceLimiter
	err = resourceLimiter.ApplyMemoryLimit(ctx, pid, input.MemoryMb, instance.ID, instance.FeatureID)
	if err != nil {
		r.log.Errorw("failed to apply memory limit",
			"error", err,
			"instanceID", input.InstanceID,
			"memoryMB", input.MemoryMb)
		return &model.ResourceLimitsPayload{
			Success:        false,
			ResourceLimits: nil,
			Errors: []*model.MutationError{{
				Code:    "LIMIT_APPLICATION_FAILED",
				Message: fmt.Sprintf("Failed to apply memory limit: %v", err),
			}},
		}, nil
	}

	// Return success with updated resource limits
	resourceLimits := &model.ResourceLimits{
		MemoryMb:   input.MemoryMb,
		CPUPercent: nil,
		Applied:    resourceLimiter.IsCgroupsEnabled(),
	}

	r.log.Infow("resource limits applied successfully",
		"instanceID", input.InstanceID,
		"memoryMB", input.MemoryMb,
		"cgroupsEnabled", resourceLimits.Applied)

	return &model.ResourceLimitsPayload{
		Success:        true,
		ResourceLimits: resourceLimits,
		Errors:         []*model.MutationError{},
	}, nil
}
*/
