package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"backend/ent"
	"backend/ent/alert"
	"backend/ent/alertrule"
	"backend/graph/model"
	"backend/internal/events"
	"backend/internal/notifications"
	"backend/internal/services"
	"context"
	"fmt"
	"time"
)

// CreateAlertRule is the resolver for the createAlertRule field.
func (r *mutationResolver) CreateAlertRule(ctx context.Context, input model.CreateAlertRuleInput) (*model.AlertRulePayload, error) {
	svc := r.AlertService
	if svc == nil {
		return &model.AlertRulePayload{
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Alert service is not available",
			}},
		}, nil
	}

	// Convert input to service input
	serviceInput := services.CreateAlertRuleInput{
		Name:        input.Name,
		Description: input.Description,
		EventType:   input.EventType,
		Severity:    alertrule.Severity(string(input.Severity)),
		Channels:    input.Channels,
		Enabled:     input.Enabled,
	}

	// Convert conditions
	if input.Conditions.IsSet() && input.Conditions.Value() != nil {
		conditions := input.Conditions.Value()
		serviceInput.Conditions = make([]map[string]interface{}, len(conditions))
		for i, cond := range conditions {
			serviceInput.Conditions[i] = map[string]interface{}{
				"field":    cond.Field,
				"operator": string(cond.Operator),
				"value":    cond.Value,
			}
		}
	}

	// Convert throttle config
	if input.Throttle.IsSet() && input.Throttle.Value() != nil {
		throttle := input.Throttle.Value()
		serviceInput.Throttle = map[string]interface{}{
			"maxAlerts":     throttle.MaxAlerts,
			"periodSeconds": throttle.PeriodSeconds,
		}
		if throttle.GroupByField.IsSet() && throttle.GroupByField.Value() != nil {
			serviceInput.Throttle["groupByField"] = *throttle.GroupByField.Value()
		}
	}

	// Convert quiet hours config
	if input.QuietHours.IsSet() && input.QuietHours.Value() != nil {
		quietHours := input.QuietHours.Value()
		serviceInput.QuietHours = map[string]interface{}{
			"startTime":      quietHours.StartTime,
			"endTime":        quietHours.EndTime,
			"timezone":       quietHours.Timezone,
			"bypassCritical": quietHours.BypassCritical,
		}
	}

	if input.DeviceID.IsSet() && input.DeviceID.Value() != nil {
		deviceIDStr := string(*input.DeviceID.Value())
		serviceInput.DeviceID = &deviceIDStr
	}

	// Create rule
	rule, err := svc.CreateRule(ctx, serviceInput)
	if err != nil {
		return &model.AlertRulePayload{
			Errors: []*model.MutationError{{
				Code:    "CREATE_FAILED",
				Message: err.Error(),
			}},
		}, nil
	}

	return &model.AlertRulePayload{
		AlertRule: convertAlertRuleToGraphQL(rule),
	}, nil
}

// UpdateAlertRule is the resolver for the updateAlertRule field.
func (r *mutationResolver) UpdateAlertRule(ctx context.Context, id string, input model.UpdateAlertRuleInput) (*model.AlertRulePayload, error) {
	svc := r.AlertService
	if svc == nil {
		return &model.AlertRulePayload{
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Alert service is not available",
			}},
		}, nil
	}

	// Convert input to service input
	serviceInput := services.UpdateAlertRuleInput{
		Name:        input.Name,
		Description: input.Description,
		EventType:   input.EventType,
		Channels:    input.Channels,
		Enabled:     input.Enabled,
	}

	// Convert severity if provided
	if input.Severity.IsSet() && input.Severity.Value() != nil {
		s := alertrule.Severity(string(*input.Severity.Value()))
		serviceInput.Severity = &s
	}

	// Convert conditions
	if input.Conditions.IsSet() && input.Conditions.Value() != nil {
		conditions := input.Conditions.Value()
		serviceInput.Conditions = make([]map[string]interface{}, len(conditions))
		for i, cond := range conditions {
			serviceInput.Conditions[i] = map[string]interface{}{
				"field":    cond.Field,
				"operator": string(cond.Operator),
				"value":    cond.Value,
			}
		}
	}

	// Convert throttle config
	if input.Throttle.IsSet() && input.Throttle.Value() != nil {
		throttle := input.Throttle.Value()
		serviceInput.Throttle = map[string]interface{}{
			"maxAlerts":     throttle.MaxAlerts,
			"periodSeconds": throttle.PeriodSeconds,
		}
		if throttle.GroupByField.IsSet() && throttle.GroupByField.Value() != nil {
			serviceInput.Throttle["groupByField"] = *throttle.GroupByField.Value()
		}
	}

	// Convert quiet hours config
	if input.QuietHours.IsSet() && input.QuietHours.Value() != nil {
		quietHours := input.QuietHours.Value()
		serviceInput.QuietHours = map[string]interface{}{
			"startTime":      quietHours.StartTime,
			"endTime":        quietHours.EndTime,
			"timezone":       quietHours.Timezone,
			"bypassCritical": quietHours.BypassCritical,
		}
	}

	if input.DeviceID.IsSet() && input.DeviceID.Value() != nil {
		deviceIDStr := string(*input.DeviceID.Value())
		serviceInput.DeviceID = &deviceIDStr
	}

	// Update rule
	rule, err := svc.UpdateRule(ctx, id, serviceInput)
	if err != nil {
		return &model.AlertRulePayload{
			Errors: []*model.MutationError{{
				Code:    "UPDATE_FAILED",
				Message: err.Error(),
			}},
		}, nil
	}

	return &model.AlertRulePayload{
		AlertRule: convertAlertRuleToGraphQL(rule),
	}, nil
}

// DeleteAlertRule is the resolver for the deleteAlertRule field.
func (r *mutationResolver) DeleteAlertRule(ctx context.Context, id string) (*model.DeletePayload, error) {
	svc := r.AlertService
	if svc == nil {
		return &model.DeletePayload{
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Alert service is not available",
			}},
		}, nil
	}

	// Delete rule
	err := svc.DeleteRule(ctx, id)
	if err != nil {
		return &model.DeletePayload{
			Success: false,
			Errors: []*model.MutationError{{
				Code:    "DELETE_FAILED",
				Message: err.Error(),
			}},
		}, nil
	}

	return &model.DeletePayload{
		Success:   true,
		DeletedID: &id,
	}, nil
}

// AcknowledgeAlert is the resolver for the acknowledgeAlert field.
func (r *mutationResolver) AcknowledgeAlert(ctx context.Context, alertID string) (*model.AlertPayload, error) {
	svc := r.AlertService
	if svc == nil {
		return &model.AlertPayload{
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Alert service is not available",
			}},
		}, nil
	}

	// TODO: Extract user ID from context for acknowledgedBy
	acknowledgedBy := "system" // Default value

	// Acknowledge alert
	alertEntity, err := svc.AcknowledgeAlert(ctx, services.AcknowledgeAlertInput{
		AlertID:        alertID,
		AcknowledgedBy: acknowledgedBy,
		AcknowledgedAt: time.Now(),
	})
	if err != nil {
		return &model.AlertPayload{
			Errors: []*model.MutationError{{
				Code:    "ACKNOWLEDGE_FAILED",
				Message: err.Error(),
			}},
		}, nil
	}

	return &model.AlertPayload{
		Alert: convertAlertToGraphQL(alertEntity),
	}, nil
}

// AcknowledgeAlerts is the resolver for the acknowledgeAlerts field.
func (r *mutationResolver) AcknowledgeAlerts(ctx context.Context, alertIds []string) (*model.BulkAlertPayload, error) {
	svc := r.AlertService
	if svc == nil {
		return &model.BulkAlertPayload{
			Errors: []*model.MutationError{{
				Code:    "SERVICE_UNAVAILABLE",
				Message: "Alert service is not available",
			}},
		}, nil
	}

	// TODO: Extract user ID from context for acknowledgedBy
	acknowledgedBy := "system" // Default value

	// Bulk acknowledge
	count, err := svc.AcknowledgeAlerts(ctx, alertIds, acknowledgedBy)
	if err != nil {
		return &model.BulkAlertPayload{
			Errors: []*model.MutationError{{
				Code:    "ACKNOWLEDGE_FAILED",
				Message: err.Error(),
			}},
		}, nil
	}

	return &model.BulkAlertPayload{
		AcknowledgedCount: count,
	}, nil
}

// TestNotificationChannel is the resolver for the testNotificationChannel field.
func (r *mutationResolver) TestNotificationChannel(ctx context.Context, channel string, config map[string]interface{}) (*model.TestNotificationPayload, error) {
	// Create test notification
	testNotif := notifications.Notification{
		Title:    "NasNetConnect Test",
		Message:  fmt.Sprintf("This is a test notification for %s channel", channel),
		Severity: "INFO",
		Data:     map[string]interface{}{},
	}

	var channelImpl notifications.Channel
	switch channel {
	case "email":
		// Extract email config
		emailConfig := notifications.EmailConfig{}
		if host, ok := config["host"].(string); ok {
			emailConfig.SMTPHost = host
		}
		if port, ok := config["port"].(float64); ok {
			emailConfig.SMTPPort = int(port)
		}
		if username, ok := config["username"].(string); ok {
			emailConfig.Username = username
		}
		if password, ok := config["password"].(string); ok {
			emailConfig.Password = password
		}
		if from, ok := config["from"].(string); ok {
			emailConfig.FromAddress = from
		}
		if to, ok := config["to"].(string); ok {
			emailConfig.ToAddress = to
		}
		if useTLS, ok := config["useTLS"].(bool); ok {
			emailConfig.UseTLS = useTLS
		}
		channelImpl = notifications.NewEmailChannel(emailConfig)

	case "telegram":
		// Extract telegram config
		telegramConfig := notifications.TelegramConfig{}
		if botToken, ok := config["botToken"].(string); ok {
			telegramConfig.BotToken = botToken
		}
		if chatID, ok := config["chatId"].(string); ok {
			telegramConfig.ChatID = chatID
		}
		channelImpl = notifications.NewTelegramChannel(telegramConfig)

	case "pushover":
		// Extract pushover config
		pushoverConfig := notifications.PushoverConfig{}
		if userKey, ok := config["userKey"].(string); ok {
			pushoverConfig.UserKey = userKey
		}
		if apiToken, ok := config["apiToken"].(string); ok {
			pushoverConfig.APIToken = apiToken
		}
		channelImpl = notifications.NewPushoverChannel(pushoverConfig)

	case "webhook":
		// Extract webhook config
		webhookConfig := notifications.WebhookConfig{}
		if url, ok := config["url"].(string); ok {
			webhookConfig.URL = url
		}
		if secret, ok := config["secret"].(string); ok {
			webhookConfig.Secret = secret
		}
		channelImpl = notifications.NewWebhookChannel(webhookConfig)

	default:
		return &model.TestNotificationPayload{
			Success: false,
			Message: strPtr(fmt.Sprintf("Unknown channel type: %s", channel)),
		}, nil
	}

	// Send test notification
	err := channelImpl.Send(ctx, testNotif)
	if err != nil {
		return &model.TestNotificationPayload{
			Success: false,
			Message: strPtr(fmt.Sprintf("Test failed: %s", err.Error())),
		}, nil
	}

	return &model.TestNotificationPayload{
		Success: true,
		Message: strPtr(fmt.Sprintf("%s notification sent successfully", channel)),
	}, nil
}

// AlertRules is the resolver for the alertRules field.
func (r *queryResolver) AlertRules(ctx context.Context, deviceID *string) ([]*model.AlertRule, error) {
	svc := r.AlertService
	if svc == nil {
		return nil, fmt.Errorf("alert service is not available")
	}

	// Fetch rules from service
	rules, err := svc.ListRules(ctx, deviceID)
	if err != nil {
		return nil, fmt.Errorf("failed to list alert rules: %w", err)
	}

	// Convert to GraphQL models
	result := make([]*model.AlertRule, len(rules))
	for i, rule := range rules {
		result[i] = convertAlertRuleToGraphQL(rule)
	}

	return result, nil
}

// AlertRule is the resolver for the alertRule field.
func (r *queryResolver) AlertRule(ctx context.Context, id string) (*model.AlertRule, error) {
	svc := r.AlertService
	if svc == nil {
		return nil, fmt.Errorf("alert service is not available")
	}

	// Fetch rule from service
	rule, err := svc.GetRule(ctx, id)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, nil // Return nil instead of error for not found
		}
		return nil, fmt.Errorf("failed to get alert rule: %w", err)
	}

	return convertAlertRuleToGraphQL(rule), nil
}

// Alerts is the resolver for the alerts field.
func (r *queryResolver) Alerts(ctx context.Context, deviceID *string, severity *model.AlertSeverity, acknowledged *bool, limit *int, offset *int) (*model.AlertConnection, error) {
	svc := r.AlertService
	if svc == nil {
		return nil, fmt.Errorf("alert service is not available")
	}

	// Set default pagination values
	limitVal := 50
	if limit != nil && *limit > 0 {
		limitVal = *limit
	}
	offsetVal := 0
	if offset != nil && *offset >= 0 {
		offsetVal = *offset
	}

	// Convert severity if provided

	var entSeverity *alert.Severity
	if severity != nil {
		s := alert.Severity(string(*severity))
		entSeverity = &s
	}

	// Fetch alerts from service
	alerts, totalCount, err := svc.ListAlerts(ctx, deviceID, entSeverity, acknowledged, limitVal, offsetVal)
	if err != nil {
		return nil, fmt.Errorf("failed to list alerts: %w", err)
	}

	// Convert to GraphQL connection
	edges := make([]*model.AlertEdge, len(alerts))
	for i, alertEntity := range alerts {
		edges[i] = &model.AlertEdge{
			Node:   convertAlertToGraphQL(alertEntity),
			Cursor: alertEntity.ID, // Using ID as cursor
		}
	}

	pageInfo := &model.PageInfo{
		HasNextPage:     (offsetVal + len(alerts)) < totalCount,
		HasPreviousPage: offsetVal > 0,
	}
	if len(edges) > 0 {
		pageInfo.StartCursor = &edges[0].Cursor
		lastCursor := edges[len(edges)-1].Cursor
		pageInfo.EndCursor = &lastCursor
	}

	return &model.AlertConnection{
		Edges:      edges,
		PageInfo:   pageInfo,
		TotalCount: totalCount,
	}, nil
}

// AlertEvents is the resolver for the alertEvents field.
func (r *subscriptionResolver) AlertEvents(ctx context.Context, deviceID *string) (<-chan *model.AlertEvent, error) {
	// Create channel for GraphQL subscription
	eventChannel := make(chan *model.AlertEvent, 10)

	// Subscribe to alert events from event bus
	if r.EventBus == nil {
		close(eventChannel)
		return eventChannel, fmt.Errorf("event bus is not available")
	}

	// Subscribe to alert.created and alert.acknowledged events
	err := r.EventBus.Subscribe("alert.created", func(ctx context.Context, event events.Event) error {
		// TODO: Filter by deviceID if provided
		// For now, send all events

		// Convert event to AlertEvent
		alertEvent := &model.AlertEvent{
			Action: model.AlertActionCreated,
			// Note: We would need to fetch the full alert details here
			// For now, this is a placeholder
		}

		select {
		case eventChannel <- alertEvent:
		case <-ctx.Done():
			return ctx.Err()
		default:
			// Channel full, skip event
		}

		return nil
	})

	if err != nil {
		close(eventChannel)
		return eventChannel, fmt.Errorf("failed to subscribe to alert events: %w", err)
	}

	// Also subscribe to acknowledged events
	_ = r.EventBus.Subscribe("alert.acknowledged", func(ctx context.Context, event events.Event) error {
		alertEvent := &model.AlertEvent{
			Action: model.AlertActionAcknowledged,
		}

		select {
		case eventChannel <- alertEvent:
		case <-ctx.Done():
			return ctx.Err()
		default:
			// Channel full, skip event
		}

		return nil
	})

	// Handle cleanup when context is cancelled
	go func() {
		<-ctx.Done()
		close(eventChannel)
	}()

	return eventChannel, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func convertAlertRuleToGraphQL(rule *ent.AlertRule) *model.AlertRule {
	result := &model.AlertRule{
		ID:          rule.ID,
		Name:        rule.Name,
		Description: &rule.Description,
		EventType:   rule.EventType,
		Severity:    model.AlertSeverity(string(rule.Severity)),
		Channels:    rule.Channels,
		Enabled:     rule.Enabled,
		CreatedAt:   rule.CreatedAt,
		UpdatedAt:   rule.UpdatedAt,
	}

	// Convert conditions
	if rule.Conditions != nil {
		result.Conditions = make([]*model.AlertCondition, len(rule.Conditions))
		for i, cond := range rule.Conditions {
			condMap := cond.(map[string]interface{})
			result.Conditions[i] = &model.AlertCondition{
				Field:    condMap["field"].(string),
				Operator: model.ConditionOperator(condMap["operator"].(string)),
				Value:    condMap["value"].(string),
			}
		}
	}

	// Convert throttle config
	if rule.Throttle != nil {
		throttleMap := rule.Throttle.(map[string]interface{})
		throttle := &model.ThrottleConfig{
			MaxAlerts:     int(throttleMap["maxAlerts"].(float64)),
			PeriodSeconds: int(throttleMap["periodSeconds"].(float64)),
		}
		if groupBy, ok := throttleMap["groupByField"].(string); ok {
			throttle.GroupByField = &groupBy
		}
		result.Throttle = throttle
	}

	// Convert quiet hours config
	if rule.QuietHours != nil {
		qhMap := rule.QuietHours.(map[string]interface{})
		result.QuietHours = &model.QuietHoursConfig{
			StartTime:      qhMap["startTime"].(string),
			EndTime:        qhMap["endTime"].(string),
			Timezone:       qhMap["timezone"].(string),
			BypassCritical: qhMap["bypassCritical"].(bool),
		}
	}

	// Set device ID if present
	if rule.DeviceID != "" {
		deviceID := rule.DeviceID
		result.DeviceID = &deviceID
	}

	return result
}
func convertAlertToGraphQL(alertEntity *ent.Alert) *model.Alert {
	result := &model.Alert{
		ID:          alertEntity.ID,
		RuleID:      alertEntity.RuleID,
		EventType:   alertEntity.EventType,
		Severity:    model.AlertSeverity(string(alertEntity.Severity)),
		Title:       alertEntity.Title,
		Message:     alertEntity.Message,
		Data:        alertEntity.Data,
		TriggeredAt: alertEntity.TriggeredAt,
	}

	// Set device ID if present
	if alertEntity.DeviceID != "" {
		deviceID := alertEntity.DeviceID
		result.DeviceID = &deviceID
	}

	// Set acknowledgment fields if present
	if alertEntity.AcknowledgedAt != nil {
		result.AcknowledgedAt = alertEntity.AcknowledgedAt
	}
	if alertEntity.AcknowledgedBy != "" {
		result.AcknowledgedBy = &alertEntity.AcknowledgedBy
	}

	return result
}
func strPtr(s string) *string {
	return &s
}
