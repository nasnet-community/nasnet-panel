package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"backend/ent"
	"backend/graph/model"
	"backend/internal/alerts"
	"backend/internal/services"
	"context"
	"fmt"
	"time"
)

// ApplyAlertRuleTemplate is the resolver for the applyAlertRuleTemplate field.
func (r *mutationResolver) ApplyAlertRuleTemplate(ctx context.Context, templateID string, variables map[string]interface{}, customizations *model.CreateAlertRuleInput) (*model.AlertRulePayload, error) {
	if r.AlertRuleTemplateService == nil {
		return &model.AlertRulePayload{
			Errors: []*model.MutationError{
				{Code: "SERVICE_UNAVAILABLE", Message: "alert rule template service not available"},
			},
		}, nil
	}

	// Build customizations input
	var input services.CreateAlertRuleInput
	if customizations != nil {
		input = convertCreateAlertRuleInput(customizations)
	}

	// Apply template via service (delegates to AlertService.CreateRule)
	rule, err := r.AlertRuleTemplateService.ApplyTemplate(ctx, templateID, variables, input)
	if err != nil {
		r.log.Errorw("failed to apply alert rule template", "templateId", templateID, "error", err)
		return &model.AlertRulePayload{
			Errors: []*model.MutationError{
				{Code: "TEMPLATE_APPLICATION_FAILED", Message: err.Error()},
			},
		}, nil
	}

	r.log.Infow("applied alert rule template", "templateId", templateID, "ruleId", rule.ID)

	return &model.AlertRulePayload{
		AlertRule: convertAlertRuleToModel(rule),
	}, nil
}

// SaveCustomAlertRuleTemplate is the resolver for the saveCustomAlertRuleTemplate field.
func (r *mutationResolver) SaveCustomAlertRuleTemplate(ctx context.Context, input model.SaveAlertRuleTemplateInput) (*model.AlertRuleTemplatePayload, error) {
	if r.AlertRuleTemplateService == nil {
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "SERVICE_UNAVAILABLE", Message: "alert rule template service not available"},
			},
		}, nil
	}

	// Generate a unique ID for the template
	tmplID := fmt.Sprintf("custom-%d", time.Now().Unix())

	// Convert input to service template
	tmpl := &alerts.AlertRuleTemplate{
		ID:          tmplID,
		Name:        input.Name,
		Description: input.Description,
		Category:    alerts.CategoryCustom, // Always CUSTOM for user-created templates
		EventType:   input.EventType,
		Severity:    string(input.Severity),
		Channels:    input.Channels,
		Version:     "1.0.0",
	}

	// Convert variables from Omittable
	if input.Variables.IsSet() {
		vars := input.Variables.Value()
		tmpl.Variables = make([]alerts.AlertRuleTemplateVariable, len(vars))
		for i, v := range vars {
			variable := alerts.AlertRuleTemplateVariable{
				Name:     v.Name,
				Label:    v.Label,
				Type:     alerts.AlertRuleTemplateVariableType(v.Type),
				Required: v.Required,
			}

			// Handle optional Omittable fields
			if v.DefaultValue.IsSet() {
				variable.DefaultValue = v.DefaultValue.Value()
			}
			if v.Min.IsSet() {
				variable.Min = v.Min.Value()
			}
			if v.Max.IsSet() {
				variable.Max = v.Max.Value()
			}
			if v.Unit.IsSet() {
				variable.Unit = v.Unit.Value()
			}
			if v.Description.IsSet() {
				variable.Description = v.Description.Value()
			}

			tmpl.Variables[i] = variable
		}
	}

	// Convert conditions
	tmpl.Conditions = make([]alerts.TemplateCondition, len(input.Conditions))
	for i, cond := range input.Conditions {
		tmpl.Conditions[i] = alerts.TemplateCondition{
			Field:    cond.Field,
			Operator: string(cond.Operator),
			Value:    cond.Value,
		}
	}

	// Convert throttle if present
	if input.Throttle.IsSet() {
		throttle := input.Throttle.Value()
		if throttle != nil {
			tmpl.Throttle = &alerts.TemplateThrottle{
				MaxAlerts:     throttle.MaxAlerts,
				PeriodSeconds: throttle.PeriodSeconds,
			}
			if throttle.GroupByField.IsSet() {
				tmpl.Throttle.GroupByField = throttle.GroupByField.Value()
			}
		}
	}

	// Save template
	saved, err := r.AlertRuleTemplateService.SaveCustomTemplate(ctx, tmpl)
	if err != nil {
		r.log.Errorw("failed to save custom alert rule template", "name", input.Name, "error", err)
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "SAVE_FAILED", Message: err.Error()},
			},
		}, nil
	}

	r.log.Infow("saved custom alert rule template", "id", saved.ID, "name", saved.Name)

	return &model.AlertRuleTemplatePayload{
		Template: convertAlertRuleTemplateToModel(saved),
	}, nil
}

// DeleteCustomAlertRuleTemplate is the resolver for the deleteCustomAlertRuleTemplate field.
func (r *mutationResolver) DeleteCustomAlertRuleTemplate(ctx context.Context, id string) (*model.DeletePayload, error) {
	if r.AlertRuleTemplateService == nil {
		return nil, fmt.Errorf("alert rule template service not available")
	}

	err := r.AlertRuleTemplateService.DeleteCustomTemplate(ctx, id)
	if err != nil {
		r.log.Errorw("failed to delete custom alert rule template", "id", id, "error", err)
		return nil, fmt.Errorf("failed to delete template: %w", err)
	}

	r.log.Infow("deleted custom alert rule template", "id", id)

	return &model.DeletePayload{
		Success: true,
	}, nil
}

// ImportAlertRuleTemplate is the resolver for the importAlertRuleTemplate field.
func (r *mutationResolver) ImportAlertRuleTemplate(ctx context.Context, json string) (*model.AlertRuleTemplatePayload, error) {
	if r.AlertRuleTemplateService == nil {
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "SERVICE_UNAVAILABLE", Message: "alert rule template service not available"},
			},
		}, nil
	}

	template, err := r.AlertRuleTemplateService.ImportTemplate(ctx, json)
	if err != nil {
		r.log.Errorw("failed to import alert rule template", "error", err)
		return &model.AlertRuleTemplatePayload{
			Errors: []*model.MutationError{
				{Code: "IMPORT_FAILED", Message: err.Error()},
			},
		}, nil
	}

	r.log.Infow("imported alert rule template", "id", template.ID, "name", template.Name)

	return &model.AlertRuleTemplatePayload{
		Template: convertAlertRuleTemplateToModel(template),
	}, nil
}

// ExportAlertRuleTemplate is the resolver for the exportAlertRuleTemplate field.
func (r *mutationResolver) ExportAlertRuleTemplate(ctx context.Context, id string) (string, error) {
	if r.AlertRuleTemplateService == nil {
		return "", fmt.Errorf("alert rule template service not available")
	}

	jsonStr, err := r.AlertRuleTemplateService.ExportTemplate(ctx, id)
	if err != nil {
		r.log.Errorw("failed to export alert rule template", "id", id, "error", err)
		return "", fmt.Errorf("export failed: %w", err)
	}

	r.log.Infow("exported alert rule template", "id", id)

	return jsonStr, nil
}

// ApplyAlertTemplate is the resolver for the applyAlertTemplate field.
func (r *mutationResolver) ApplyAlertTemplate(ctx context.Context, input model.ApplyAlertTemplateInput) (*model.AlertRulePayload, error) {
	panic(fmt.Errorf("not implemented: ApplyAlertTemplate - applyAlertTemplate"))
}

// SaveAlertTemplate is the resolver for the saveAlertTemplate field.
func (r *mutationResolver) SaveAlertTemplate(ctx context.Context, input model.SaveAlertTemplateInput) (*model.AlertTemplatePayload, error) {
	panic(fmt.Errorf("not implemented: SaveAlertTemplate - saveAlertTemplate"))
}

// DeleteAlertTemplate is the resolver for the deleteAlertTemplate field.
func (r *mutationResolver) DeleteAlertTemplate(ctx context.Context, id string) (*model.DeletePayload, error) {
	panic(fmt.Errorf("not implemented: DeleteAlertTemplate - deleteAlertTemplate"))
}

// ResetAlertTemplate is the resolver for the resetAlertTemplate field.
func (r *mutationResolver) ResetAlertTemplate(ctx context.Context, eventType string, channel model.NotificationChannel) (*model.DeletePayload, error) {
	panic(fmt.Errorf("not implemented: ResetAlertTemplate - resetAlertTemplate"))
}

// PreviewNotificationTemplate is the resolver for the previewNotificationTemplate field.
func (r *mutationResolver) PreviewNotificationTemplate(ctx context.Context, input model.PreviewNotificationTemplateInput) (*model.NotificationTemplatePreview, error) {
	panic(fmt.Errorf("not implemented: PreviewNotificationTemplate - previewNotificationTemplate"))
}

// CreateAlertRule is the resolver for the createAlertRule field.
func (r *mutationResolver) CreateAlertRule(ctx context.Context, input model.CreateAlertRuleInput) (*model.AlertRulePayload, error) {
	panic(fmt.Errorf("not implemented: CreateAlertRule - createAlertRule"))
}

// UpdateAlertRule is the resolver for the updateAlertRule field.
func (r *mutationResolver) UpdateAlertRule(ctx context.Context, id string, input model.UpdateAlertRuleInput) (*model.AlertRulePayload, error) {
	panic(fmt.Errorf("not implemented: UpdateAlertRule - updateAlertRule"))
}

// ToggleAlertRule is the resolver for the toggleAlertRule field.
func (r *mutationResolver) ToggleAlertRule(ctx context.Context, id string) (*model.AlertRulePayload, error) {
	panic(fmt.Errorf("not implemented: ToggleAlertRule - toggleAlertRule"))
}

// DeleteAlertRule is the resolver for the deleteAlertRule field.
func (r *mutationResolver) DeleteAlertRule(ctx context.Context, id string) (*model.DeletePayload, error) {
	panic(fmt.Errorf("not implemented: DeleteAlertRule - deleteAlertRule"))
}

// AcknowledgeAlert is the resolver for the acknowledgeAlert field.
func (r *mutationResolver) AcknowledgeAlert(ctx context.Context, alertID string) (*model.AlertPayload, error) {
	panic(fmt.Errorf("not implemented: AcknowledgeAlert - acknowledgeAlert"))
}

// AcknowledgeAlerts is the resolver for the acknowledgeAlerts field.
func (r *mutationResolver) AcknowledgeAlerts(ctx context.Context, alertIds []string) (*model.BulkAlertPayload, error) {
	panic(fmt.Errorf("not implemented: AcknowledgeAlerts - acknowledgeAlerts"))
}

// TestNotificationChannel is the resolver for the testNotificationChannel field.
func (r *mutationResolver) TestNotificationChannel(ctx context.Context, channel string, config map[string]interface{}) (*model.TestNotificationPayload, error) {
	panic(fmt.Errorf("not implemented: TestNotificationChannel - testNotificationChannel"))
}

// CreateWebhook is the resolver for the createWebhook field.
func (r *mutationResolver) CreateWebhook(ctx context.Context, input model.CreateWebhookInput) (*model.WebhookPayload, error) {
	panic(fmt.Errorf("not implemented: CreateWebhook - createWebhook"))
}

// UpdateWebhook is the resolver for the updateWebhook field.
func (r *mutationResolver) UpdateWebhook(ctx context.Context, id string, input model.UpdateWebhookInput) (*model.WebhookPayload, error) {
	panic(fmt.Errorf("not implemented: UpdateWebhook - updateWebhook"))
}

// DeleteWebhook is the resolver for the deleteWebhook field.
func (r *mutationResolver) DeleteWebhook(ctx context.Context, id string) (*model.DeletePayload, error) {
	panic(fmt.Errorf("not implemented: DeleteWebhook - deleteWebhook"))
}

// TestWebhook is the resolver for the testWebhook field.
func (r *mutationResolver) TestWebhook(ctx context.Context, id string) (*model.WebhookTestPayload, error) {
	panic(fmt.Errorf("not implemented: TestWebhook - testWebhook"))
}

// TriggerDigestNow is the resolver for the triggerDigestNow field.
func (r *mutationResolver) TriggerDigestNow(ctx context.Context, channelID string) (*model.DigestSummary, error) {
	panic(fmt.Errorf("not implemented: TriggerDigestNow - triggerDigestNow"))
}

// CreateNotificationChannelConfig is the resolver for the createNotificationChannelConfig field.
func (r *mutationResolver) CreateNotificationChannelConfig(ctx context.Context, input model.CreateNotificationChannelConfigInput) (*model.ChannelConfigPayload, error) {
	panic(fmt.Errorf("not implemented: CreateNotificationChannelConfig - createNotificationChannelConfig"))
}

// UpdateNotificationChannelConfig is the resolver for the updateNotificationChannelConfig field.
func (r *mutationResolver) UpdateNotificationChannelConfig(ctx context.Context, id string, input model.UpdateNotificationChannelConfigInput) (*model.ChannelConfigPayload, error) {
	panic(fmt.Errorf("not implemented: UpdateNotificationChannelConfig - updateNotificationChannelConfig"))
}

// DeleteNotificationChannelConfig is the resolver for the deleteNotificationChannelConfig field.
func (r *mutationResolver) DeleteNotificationChannelConfig(ctx context.Context, id string) (*model.DeletePayload, error) {
	panic(fmt.Errorf("not implemented: DeleteNotificationChannelConfig - deleteNotificationChannelConfig"))
}

// AlertRuleTemplates is the resolver for the alertRuleTemplates field.
func (r *queryResolver) AlertRuleTemplates(ctx context.Context, category *model.AlertRuleTemplateCategory) ([]*model.AlertRuleTemplate, error) {
	if r.AlertRuleTemplateService == nil {
		return nil, fmt.Errorf("alert rule template service not available")
	}

	// Convert GraphQL category to service category
	var serviceCategory *alerts.AlertRuleTemplateCategory
	if category != nil {
		c := alerts.AlertRuleTemplateCategory(*category)
		serviceCategory = &c
	}

	// Get templates from service
	templates, err := r.AlertRuleTemplateService.GetTemplates(ctx, serviceCategory)
	if err != nil {
		r.log.Errorw("failed to get alert rule templates", "error", err)
		return nil, fmt.Errorf("failed to get templates: %w", err)
	}

	// Convert service templates to GraphQL model
	result := make([]*model.AlertRuleTemplate, len(templates))
	for i, tmpl := range templates {
		result[i] = convertAlertRuleTemplateToModel(tmpl)
	}

	return result, nil
}

// AlertRuleTemplate is the resolver for the alertRuleTemplate field.
func (r *queryResolver) AlertRuleTemplate(ctx context.Context, id string) (*model.AlertRuleTemplate, error) {
	if r.AlertRuleTemplateService == nil {
		return nil, fmt.Errorf("alert rule template service not available")
	}

	template, err := r.AlertRuleTemplateService.GetTemplateByID(ctx, id)
	if err != nil {
		r.log.Errorw("failed to get alert rule template", "id", id, "error", err)
		return nil, fmt.Errorf("template not found: %w", err)
	}

	return convertAlertRuleTemplateToModel(template), nil
}

// PreviewAlertRuleTemplate is the resolver for the previewAlertRuleTemplate field.
func (r *queryResolver) PreviewAlertRuleTemplate(ctx context.Context, templateID string, variables map[string]interface{}) (*model.AlertRuleTemplatePreview, error) {
	if r.AlertRuleTemplateService == nil {
		return nil, fmt.Errorf("alert rule template service not available")
	}

	preview, err := r.AlertRuleTemplateService.PreviewTemplate(ctx, templateID, variables)
	if err != nil {
		r.log.Errorw("failed to preview alert rule template", "templateId", templateID, "error", err)
		return nil, fmt.Errorf("preview failed: %w", err)
	}

	// Convert to GraphQL model
	result := &model.AlertRuleTemplatePreview{
		Template:           convertAlertRuleTemplateToModel(preview.Template),
		ResolvedConditions: make([]*model.AlertCondition, len(preview.ResolvedConditions)),
		ValidationInfo: &model.TemplateValidationInfo{
			IsValid:          preview.ValidationInfo.IsValid,
			MissingVariables: preview.ValidationInfo.MissingVariables,
			Warnings:         preview.ValidationInfo.Warnings,
		},
	}

	// Convert resolved conditions
	for i, cond := range preview.ResolvedConditions {
		result.ResolvedConditions[i] = &model.AlertCondition{
			Field:    cond.Field,
			Operator: model.ConditionOperator(cond.Operator),
			Value:    fmt.Sprintf("%v", cond.Value),
		}
	}

	return result, nil
}

// AlertTemplates is the resolver for the alertTemplates field.
func (r *queryResolver) AlertTemplates(ctx context.Context, eventType *string, channel *model.NotificationChannel) ([]*model.AlertTemplate, error) {
	panic(fmt.Errorf("not implemented: AlertTemplates - alertTemplates"))
}

// AlertTemplate is the resolver for the alertTemplate field.
func (r *queryResolver) AlertTemplate(ctx context.Context, id string) (*model.AlertTemplate, error) {
	panic(fmt.Errorf("not implemented: AlertTemplate - alertTemplate"))
}

// CommonEventTypes is the resolver for the commonEventTypes field.
func (r *queryResolver) CommonEventTypes(ctx context.Context) ([]string, error) {
	panic(fmt.Errorf("not implemented: CommonEventTypes - commonEventTypes"))
}

// SearchAlertTemplates is the resolver for the searchAlertTemplates field.
func (r *queryResolver) SearchAlertTemplates(ctx context.Context, query string) ([]*model.AlertTemplate, error) {
	panic(fmt.Errorf("not implemented: SearchAlertTemplates - searchAlertTemplates"))
}

// PreviewAlertTemplate is the resolver for the previewAlertTemplate field.
func (r *queryResolver) PreviewAlertTemplate(ctx context.Context, templateID string, variables map[string]interface{}) (*model.TemplatePreviewPayload, error) {
	panic(fmt.Errorf("not implemented: PreviewAlertTemplate - previewAlertTemplate"))
}

// AlertRules is the resolver for the alertRules field.
func (r *queryResolver) AlertRules(ctx context.Context, deviceID *string) ([]*model.AlertRule, error) {
	panic(fmt.Errorf("not implemented: AlertRules - alertRules"))
}

// AlertRule is the resolver for the alertRule field.
func (r *queryResolver) AlertRule(ctx context.Context, id string) (*model.AlertRule, error) {
	panic(fmt.Errorf("not implemented: AlertRule - alertRule"))
}

// Alerts is the resolver for the alerts field.
func (r *queryResolver) Alerts(ctx context.Context, deviceID *string, severity *model.AlertSeverity, acknowledged *bool, limit *int, offset *int) (*model.AlertConnection, error) {
	panic(fmt.Errorf("not implemented: Alerts - alerts"))
}

// PushoverUsage is the resolver for the pushoverUsage field.
func (r *queryResolver) PushoverUsage(ctx context.Context) (*model.PushoverUsage, error) {
	panic(fmt.Errorf("not implemented: PushoverUsage - pushoverUsage"))
}

// Webhooks is the resolver for the webhooks field.
func (r *queryResolver) Webhooks(ctx context.Context) ([]*model.Webhook, error) {
	panic(fmt.Errorf("not implemented: Webhooks - webhooks"))
}

// Webhook is the resolver for the webhook field.
func (r *queryResolver) Webhook(ctx context.Context, id string) (*model.Webhook, error) {
	panic(fmt.Errorf("not implemented: Webhook - webhook"))
}

// NotificationLogs is the resolver for the notificationLogs field.
func (r *queryResolver) NotificationLogs(ctx context.Context, alertID *string, channel *string, webhookID *string, limit *int, offset *int) ([]*model.NotificationLog, error) {
	panic(fmt.Errorf("not implemented: NotificationLogs - notificationLogs"))
}

// AlertEscalations is the resolver for the alertEscalations field.
func (r *queryResolver) AlertEscalations(ctx context.Context, status *model.EscalationStatus, limit *int, offset *int) ([]*model.AlertEscalation, error) {
	panic(fmt.Errorf("not implemented: AlertEscalations - alertEscalations"))
}

// DigestQueueCount is the resolver for the digestQueueCount field.
func (r *queryResolver) DigestQueueCount(ctx context.Context, channelID string) (int, error) {
	panic(fmt.Errorf("not implemented: DigestQueueCount - digestQueueCount"))
}

// DigestHistory is the resolver for the digestHistory field.
func (r *queryResolver) DigestHistory(ctx context.Context, channelID string, limit *int) ([]*model.DigestSummary, error) {
	panic(fmt.Errorf("not implemented: DigestHistory - digestHistory"))
}

// AlertRuleThrottleStatus is the resolver for the alertRuleThrottleStatus field.
func (r *queryResolver) AlertRuleThrottleStatus(ctx context.Context, ruleID *string) ([]*model.ThrottleStatus, error) {
	panic(fmt.Errorf("not implemented: AlertRuleThrottleStatus - alertRuleThrottleStatus"))
}

// AlertStormStatus is the resolver for the alertStormStatus field.
func (r *queryResolver) AlertStormStatus(ctx context.Context) (*model.StormStatus, error) {
	panic(fmt.Errorf("not implemented: AlertStormStatus - alertStormStatus"))
}

// NotificationChannelConfigs is the resolver for the notificationChannelConfigs field.
func (r *queryResolver) NotificationChannelConfigs(ctx context.Context, channelType *model.ChannelType) ([]*model.NotificationChannelConfig, error) {
	panic(fmt.Errorf("not implemented: NotificationChannelConfigs - notificationChannelConfigs"))
}

// NotificationChannelConfig is the resolver for the notificationChannelConfig field.
func (r *queryResolver) NotificationChannelConfig(ctx context.Context, id string) (*model.NotificationChannelConfig, error) {
	panic(fmt.Errorf("not implemented: NotificationChannelConfig - notificationChannelConfig"))
}

// DefaultNotificationChannelConfig is the resolver for the defaultNotificationChannelConfig field.
func (r *queryResolver) DefaultNotificationChannelConfig(ctx context.Context, channelType model.ChannelType) (*model.NotificationChannelConfig, error) {
	panic(fmt.Errorf("not implemented: DefaultNotificationChannelConfig - defaultNotificationChannelConfig"))
}

// AlertEvents is the resolver for the alertEvents field.
func (r *subscriptionResolver) AlertEvents(ctx context.Context, deviceID *string) (<-chan *model.AlertEvent, error) {
	panic(fmt.Errorf("not implemented: AlertEvents - alertEvents"))
}

// ============================================
// Alert Rule Template Helper Functions
// ============================================

// convertAlertRuleTemplateToModel converts service template to GraphQL model.
func convertAlertRuleTemplateToModel(tmpl *alerts.AlertRuleTemplate) *model.AlertRuleTemplate {
	if tmpl == nil {
		return nil
	}

	result := &model.AlertRuleTemplate{
		ID:          tmpl.ID,
		Name:        tmpl.Name,
		Description: tmpl.Description,
		Category:    model.AlertRuleTemplateCategory(tmpl.Category),
		Severity:    model.AlertSeverity(tmpl.Severity),
		EventType:   tmpl.EventType,
		Channels:    tmpl.Channels,
		IsBuiltIn:   tmpl.IsBuiltIn,
		Version:     tmpl.Version,
	}

	// Convert conditions
	result.Conditions = make([]*model.AlertCondition, len(tmpl.Conditions))
	for i, cond := range tmpl.Conditions {
		result.Conditions[i] = &model.AlertCondition{
			Field:    cond.Field,
			Operator: model.ConditionOperator(cond.Operator),
			Value:    cond.Value,
		}
	}

	// Convert variables
	result.Variables = make([]*model.AlertRuleTemplateVariable, len(tmpl.Variables))
	for i, v := range tmpl.Variables {
		result.Variables[i] = &model.AlertRuleTemplateVariable{
			Name:     v.Name,
			Label:    v.Label,
			Type:     model.AlertRuleTemplateVariableType(v.Type),
			Required: v.Required,
		}

		if v.DefaultValue != nil {
			result.Variables[i].DefaultValue = v.DefaultValue
		}
		if v.Min != nil {
			result.Variables[i].Min = v.Min
		}
		if v.Max != nil {
			result.Variables[i].Max = v.Max
		}
		if v.Unit != nil {
			result.Variables[i].Unit = v.Unit
		}
		if v.Description != nil {
			result.Variables[i].Description = v.Description
		}
	}

	// Convert throttle if present
	if tmpl.Throttle != nil {
		result.Throttle = &model.ThrottleConfig{
			MaxAlerts:     tmpl.Throttle.MaxAlerts,
			PeriodSeconds: tmpl.Throttle.PeriodSeconds,
		}
		if tmpl.Throttle.GroupByField != nil {
			result.Throttle.GroupByField = tmpl.Throttle.GroupByField
		}
	}

	// Set timestamps
	if tmpl.CreatedAt != nil {
		result.CreatedAt = *tmpl.CreatedAt
	} else {
		result.CreatedAt = time.Now()
	}
	if tmpl.UpdatedAt != nil {
		result.UpdatedAt = *tmpl.UpdatedAt
	} else {
		result.UpdatedAt = time.Now()
	}

	return result
}

// convertCreateAlertRuleInput converts GraphQL input to service input.
func convertCreateAlertRuleInput(input *model.CreateAlertRuleInput) services.CreateAlertRuleInput {
	result := services.CreateAlertRuleInput{
		Name:        input.Name,
		EventType:   input.EventType,
		Enabled:     true, // Default to enabled
	}

	// Handle optional Omittable fields
	if input.Description.IsSet() {
		result.Description = input.Description.Value()
	}

	if input.DeviceID.IsSet() {
		result.DeviceID = input.DeviceID.Value()
	}

	if input.Enabled.IsSet() {
		enabled := input.Enabled.Value()
		if enabled != nil {
			result.Enabled = *enabled
		}
	}

	// Convert conditions
	if input.Conditions.IsSet() {
		conditions := input.Conditions.Value()
		result.Conditions = make([]map[string]interface{}, len(conditions))
		for i, cond := range conditions {
			result.Conditions[i] = map[string]interface{}{
				"field":    cond.Field,
				"operator": string(cond.Operator),
				"value":    cond.Value,
			}
		}
	}

	// Convert throttle
	if input.Throttle.IsSet() {
		throttle := input.Throttle.Value()
		if throttle != nil {
			result.Throttle = map[string]interface{}{
				"maxAlerts":     throttle.MaxAlerts,
				"periodSeconds": throttle.PeriodSeconds,
			}
			if throttle.GroupByField.IsSet() {
				groupBy := throttle.GroupByField.Value()
				if groupBy != nil {
					result.Throttle["groupByField"] = *groupBy
				}
			}
		}
	}

	// Convert quiet hours
	if input.QuietHours.IsSet() {
		qh := input.QuietHours.Value()
		if qh != nil {
			result.QuietHours = map[string]interface{}{
				"startTime": qh.StartTime,
				"endTime":   qh.EndTime,
				"timezone":  qh.Timezone,
			}
			// Days field doesn't exist in QuietHoursConfigInput - removed
		}
	}

	return result
}

// convertAlertRuleToModel converts ent AlertRule to GraphQL model.
func convertAlertRuleToModel(rule *ent.AlertRule) *model.AlertRule {
	if rule == nil {
		return nil
	}

	// Basic conversion - extend as needed based on model.AlertRule fields
	return &model.AlertRule{
		ID:          rule.ID,
		Name:        rule.Name,
		Description: &rule.Description,
		EventType:   rule.EventType,
		Severity:    model.AlertSeverity(rule.Severity),
		Enabled:     rule.Enabled,
		CreatedAt:   rule.CreatedAt,
		UpdatedAt:   rule.UpdatedAt,
	}
}
