package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	graphql1 "backend/graph/model"
	"backend/internal/errors"
	"backend/internal/features"
	"backend/internal/orchestrator/lifecycle"
	"context"
	"fmt"
)

// InstallService is the resolver for the installService field.
func (r *mutationResolver) InstallService(ctx context.Context, input graphql1.InstallServiceInput) (*graphql1.ServiceInstancePayload, error) {
	if r.InstanceManager == nil {
		return nil, errors.NewProtocolError("INSTANCE_MANAGER_NOT_INIT", "instance manager not initialized", "graphql")
	}

	cfg := map[string]interface{}{}
	if input.Config.IsSet() {
		if v := input.Config.Value(); v != nil {
			cfg = v
		}
	}

	req := lifecycle.CreateInstanceRequest{
		FeatureID:         input.FeatureID,
		InstanceName:      input.InstanceName,
		RouterID:          input.RouterID,
		Config:            cfg,
		RouterOSVersion:   "",
		Architecture:      "",
		AvailableMemoryMB: 0,
		AvailableDiskMB:   0,
	}

	inst, err := r.InstanceManager.CreateInstance(ctx, req)
	if err != nil {
		wrappedErr := errors.Wrap(err, "CREATE_INSTANCE_FAILED", errors.CategoryInternal, "failed to create instance")
		errMsg := wrappedErr.Error()
		return &graphql1.ServiceInstancePayload{
			Errors: []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	return &graphql1.ServiceInstancePayload{Instance: convertEntInstanceToGraphQL(inst)}, nil
}

// StartInstance is the resolver for the startInstance field.
func (r *mutationResolver) StartInstance(ctx context.Context, input graphql1.StartInstanceInput) (*graphql1.ServiceInstancePayload, error) {
	if r.InstanceManager == nil {
		return nil, errors.NewProtocolError("INSTANCE_MANAGER_NOT_INIT", "instance manager not initialized", "graphql")
	}

	if err := r.InstanceManager.StartInstance(ctx, input.InstanceID); err != nil {
		wrappedErr := errors.Wrap(err, "START_INSTANCE_FAILED", errors.CategoryInternal, "failed to start instance")
		errMsg := wrappedErr.Error()
		return &graphql1.ServiceInstancePayload{
			Errors: []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	inst, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		return nil, errors.Wrap(err, "FETCH_INSTANCE_FAILED", errors.CategoryInternal, "failed to fetch instance after start")
	}

	return &graphql1.ServiceInstancePayload{Instance: convertEntInstanceToGraphQL(inst)}, nil
}

// StopInstance is the resolver for the stopInstance field.
func (r *mutationResolver) StopInstance(ctx context.Context, input graphql1.StopInstanceInput) (*graphql1.ServiceInstancePayload, error) {
	if r.InstanceManager == nil {
		return nil, errors.NewProtocolError("INSTANCE_MANAGER_NOT_INIT", "instance manager not initialized", "graphql")
	}

	if err := r.InstanceManager.StopInstance(ctx, input.InstanceID); err != nil {
		wrappedErr := errors.Wrap(err, "STOP_INSTANCE_FAILED", errors.CategoryInternal, "failed to stop instance")
		errMsg := wrappedErr.Error()
		return &graphql1.ServiceInstancePayload{
			Errors: []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	inst, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		return nil, errors.Wrap(err, "FETCH_INSTANCE_FAILED", errors.CategoryInternal, "failed to fetch instance after stop")
	}

	return &graphql1.ServiceInstancePayload{Instance: convertEntInstanceToGraphQL(inst)}, nil
}

// RestartInstance is the resolver for the restartInstance field.
func (r *mutationResolver) RestartInstance(ctx context.Context, input graphql1.RestartInstanceInput) (*graphql1.ServiceInstancePayload, error) {
	if r.InstanceManager == nil {
		return nil, errors.NewProtocolError("INSTANCE_MANAGER_NOT_INIT", "instance manager not initialized", "graphql")
	}

	if err := r.InstanceManager.RestartInstance(ctx, input.InstanceID); err != nil {
		wrappedErr := errors.Wrap(err, "RESTART_INSTANCE_FAILED", errors.CategoryInternal, "failed to restart instance")
		errMsg := wrappedErr.Error()
		return &graphql1.ServiceInstancePayload{
			Errors: []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	inst, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		return nil, errors.Wrap(err, "FETCH_INSTANCE_FAILED", errors.CategoryInternal, "failed to fetch instance after restart")
	}

	return &graphql1.ServiceInstancePayload{Instance: convertEntInstanceToGraphQL(inst)}, nil
}

// DeleteInstance is the resolver for the deleteInstance field.
func (r *mutationResolver) DeleteInstance(ctx context.Context, input graphql1.DeleteInstanceInput) (*graphql1.ServiceInstancePayload, error) {
	if r.InstanceManager == nil {
		return nil, errors.NewProtocolError("INSTANCE_MANAGER_NOT_INIT", "instance manager not initialized", "graphql")
	}

	// Fetch before deletion so the snapshot can be returned in the payload.
	inst, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		return nil, errors.Wrap(err, "INSTANCE_NOT_FOUND", errors.CategoryInternal, "instance not found")
	}
	snapshot := convertEntInstanceToGraphQL(inst)

	if err := r.InstanceManager.DeleteInstance(ctx, input.InstanceID); err != nil {
		wrappedErr := errors.Wrap(err, "DELETE_INSTANCE_FAILED", errors.CategoryInternal, "failed to delete instance")
		errMsg := wrappedErr.Error()
		return &graphql1.ServiceInstancePayload{
			Errors: []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	return &graphql1.ServiceInstancePayload{Instance: snapshot}, nil
}

// ReverifyInstance is the resolver for the reverifyInstance field.
// Performs an on-demand SHA256 hash check of the instance binary.
func (r *mutationResolver) ReverifyInstance(ctx context.Context, routerID string, instanceID string) (*graphql1.ReverifyPayload, error) {
	inst, err := r.db.ServiceInstance.Get(ctx, instanceID)
	if err != nil {
		return nil, errors.Wrap(err, "INSTANCE_NOT_FOUND", errors.CategoryInternal, "instance not found")
	}

	if inst.BinaryPath == "" || inst.BinaryChecksum == "" {
		errMsg := "binary path or expected checksum not set for this instance"
		return &graphql1.ReverifyPayload{
			InstanceID:   instanceID,
			Success:      false,
			ErrorMessage: &errMsg,
		}, nil
	}

	expectedHash := inst.BinaryChecksum
	currentHash, calcErr := features.CalculateSHA256(inst.BinaryPath)
	if calcErr != nil {
		errMsg := fmt.Sprintf("failed to compute binary hash: %s", calcErr.Error())
		return &graphql1.ReverifyPayload{
			InstanceID:   instanceID,
			Success:      false,
			ErrorMessage: &errMsg,
		}, nil
	}

	passed := currentHash == expectedHash
	result := &graphql1.ReverifyPayload{
		InstanceID:   instanceID,
		Success:      passed,
		CurrentHash:  &currentHash,
		ExpectedHash: &expectedHash,
	}
	if !passed {
		errMsg := "binary hash mismatch: possible tampering detected"
		result.ErrorMessage = &errMsg
	}

	return result, nil
}
