package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/generated/ent/serviceinstance"
	graphql1 "backend/graph/model"
	"backend/internal/apperrors"
	"backend/internal/events"
	"backend/internal/features"
	"backend/internal/orchestrator/lifecycle"
	"context"
	"fmt"
)

// InstallService is the resolver for the installService field.
func (r *mutationResolver) InstallService(ctx context.Context, input graphql1.InstallServiceInput) (*graphql1.ServiceInstancePayload, error) {
	if r.InstanceManager == nil {
		return nil, apperrors.NewProtocolError("INSTANCE_MANAGER_NOT_INIT", "instance manager not initialized", "graphql")
	}

	cfg := map[string]interface{}{}
	if input.Config.IsSet() {
		if v := input.Config.Value(); v != nil {
			cfg = v
		}
	}

	req := lifecycle.CreateInstanceRequest{
		FeatureID:         input.FeatureID,
		InstanceName:      input.InstanceName,
		RouterID:          input.RouterID,
		Config:            cfg,
		RouterOSVersion:   "",
		Architecture:      "",
		AvailableMemoryMB: 0,
		AvailableDiskMB:   0,
	}

	inst, err := r.InstanceManager.CreateInstance(ctx, req)
	if err != nil {
		wrappedErr := apperrors.Wrap(err, "CREATE_INSTANCE_FAILED", apperrors.CategoryInternal, "failed to create instance")
		errMsg := wrappedErr.Error()
		return &graphql1.ServiceInstancePayload{
			Errors: []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	return &graphql1.ServiceInstancePayload{Instance: convertEntInstanceToGraphQL(inst)}, nil
}

// StartInstance is the resolver for the startInstance field.
func (r *mutationResolver) StartInstance(ctx context.Context, input graphql1.StartInstanceInput) (*graphql1.ServiceInstancePayload, error) {
	if r.InstanceManager == nil {
		return nil, apperrors.NewProtocolError("INSTANCE_MANAGER_NOT_INIT", "instance manager not initialized", "graphql")
	}

	if err := r.InstanceManager.StartInstance(ctx, input.InstanceID); err != nil {
		wrappedErr := apperrors.Wrap(err, "START_INSTANCE_FAILED", apperrors.CategoryInternal, "failed to start instance")
		errMsg := wrappedErr.Error()
		return &graphql1.ServiceInstancePayload{
			Errors: []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	inst, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		return nil, apperrors.Wrap(err, "FETCH_INSTANCE_FAILED", apperrors.CategoryInternal, "failed to fetch instance after start")
	}

	return &graphql1.ServiceInstancePayload{Instance: convertEntInstanceToGraphQL(inst)}, nil
}

// StopInstance is the resolver for the stopInstance field.
func (r *mutationResolver) StopInstance(ctx context.Context, input graphql1.StopInstanceInput) (*graphql1.ServiceInstancePayload, error) {
	if r.InstanceManager == nil {
		return nil, apperrors.NewProtocolError("INSTANCE_MANAGER_NOT_INIT", "instance manager not initialized", "graphql")
	}

	if err := r.InstanceManager.StopInstance(ctx, input.InstanceID); err != nil {
		wrappedErr := apperrors.Wrap(err, "STOP_INSTANCE_FAILED", apperrors.CategoryInternal, "failed to stop instance")
		errMsg := wrappedErr.Error()
		return &graphql1.ServiceInstancePayload{
			Errors: []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	inst, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		return nil, apperrors.Wrap(err, "FETCH_INSTANCE_FAILED", apperrors.CategoryInternal, "failed to fetch instance after stop")
	}

	return &graphql1.ServiceInstancePayload{Instance: convertEntInstanceToGraphQL(inst)}, nil
}

// RestartInstance is the resolver for the restartInstance field.
func (r *mutationResolver) RestartInstance(ctx context.Context, input graphql1.RestartInstanceInput) (*graphql1.ServiceInstancePayload, error) {
	if r.InstanceManager == nil {
		return nil, apperrors.NewProtocolError("INSTANCE_MANAGER_NOT_INIT", "instance manager not initialized", "graphql")
	}

	if err := r.InstanceManager.RestartInstance(ctx, input.InstanceID); err != nil {
		wrappedErr := apperrors.Wrap(err, "RESTART_INSTANCE_FAILED", apperrors.CategoryInternal, "failed to restart instance")
		errMsg := wrappedErr.Error()
		return &graphql1.ServiceInstancePayload{
			Errors: []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	inst, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		return nil, apperrors.Wrap(err, "FETCH_INSTANCE_FAILED", apperrors.CategoryInternal, "failed to fetch instance after restart")
	}

	return &graphql1.ServiceInstancePayload{Instance: convertEntInstanceToGraphQL(inst)}, nil
}

// DeleteInstance is the resolver for the deleteInstance field.
func (r *mutationResolver) DeleteInstance(ctx context.Context, input graphql1.DeleteInstanceInput) (*graphql1.ServiceInstancePayload, error) {
	if r.InstanceManager == nil {
		return nil, apperrors.NewProtocolError("INSTANCE_MANAGER_NOT_INIT", "instance manager not initialized", "graphql")
	}

	// Fetch before deletion so the snapshot can be returned in the payload.
	inst, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		return nil, apperrors.Wrap(err, "INSTANCE_NOT_FOUND", apperrors.CategoryInternal, "instance not found")
	}
	snapshot := convertEntInstanceToGraphQL(inst)

	if err := r.InstanceManager.DeleteInstance(ctx, input.InstanceID); err != nil {
		wrappedErr := apperrors.Wrap(err, "DELETE_INSTANCE_FAILED", apperrors.CategoryInternal, "failed to delete instance")
		errMsg := wrappedErr.Error()
		return &graphql1.ServiceInstancePayload{
			Errors: []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	return &graphql1.ServiceInstancePayload{Instance: snapshot}, nil
}

// ReverifyInstance is the resolver for the reverifyInstance field.
// Performs an on-demand SHA256 hash check of the instance binary.
func (r *mutationResolver) ReverifyInstance(ctx context.Context, routerID string, instanceID string) (*graphql1.ReverifyPayload, error) {
	inst, err := r.db.ServiceInstance.Get(ctx, instanceID)
	if err != nil {
		return nil, apperrors.Wrap(err, "INSTANCE_NOT_FOUND", apperrors.CategoryInternal, "instance not found")
	}

	if inst.BinaryPath == "" || inst.BinaryChecksum == "" {
		errMsg := "binary path or expected checksum not set for this instance"
		return &graphql1.ReverifyPayload{
			InstanceID:   instanceID,
			Success:      false,
			ErrorMessage: &errMsg,
		}, nil
	}

	expectedHash := inst.BinaryChecksum
	currentHash, calcErr := features.CalculateSHA256(inst.BinaryPath)
	if calcErr != nil {
		errMsg := fmt.Sprintf("failed to compute binary hash: %s", calcErr.Error())
		return &graphql1.ReverifyPayload{
			InstanceID:   instanceID,
			Success:      false,
			ErrorMessage: &errMsg,
		}, nil
	}

	passed := currentHash == expectedHash
	result := &graphql1.ReverifyPayload{
		InstanceID:   instanceID,
		Success:      passed,
		CurrentHash:  &currentHash,
		ExpectedHash: &expectedHash,
	}
	if !passed {
		errMsg := "binary hash mismatch: possible tampering detected"
		result.ErrorMessage = &errMsg
	}

	return result, nil
}

// InstallProgress is the resolver for the installProgress subscription field.
func (r *subscriptionResolver) InstallProgress(ctx context.Context, routerID string) (<-chan *graphql1.InstallProgress, error) {
	if r.EventBus == nil {
		return nil, apperrors.NewProtocolError("EVENT_BUS_NOT_INIT", "event bus not initialized", "graphql")
	}

	ch := make(chan *graphql1.InstallProgress, 16)

	handler := func(_ context.Context, event events.Event) error {
		select {
		case <-ctx.Done():
			return nil
		default:
		}

		switch e := event.(type) {
		case *events.ServiceInstalledEvent:
			status := "completed"
			select {
			case ch <- &graphql1.InstallProgress{
				InstanceID: e.InstanceID,
				FeatureID:  e.ServiceType,
				Status:     status,
				Percent:    100.0,
			}:
			default:
			}
		case *events.ServiceStateChangedEvent:
			if e.ToStatus != string(lifecycle.StatusInstalling) &&
				e.ToStatus != string(lifecycle.StatusInstalled) &&
				e.ToStatus != string(lifecycle.StatusFailed) {

				return nil
			}

			percent := 0.0
			if e.ToStatus == string(lifecycle.StatusInstalled) {
				percent = 100.0
			}
			progress := &graphql1.InstallProgress{
				InstanceID: e.InstanceID,
				FeatureID:  e.ServiceType,
				Status:     e.ToStatus,
				Percent:    percent,
			}
			if e.ErrorMessage != "" {
				progress.ErrorMessage = &e.ErrorMessage
			}
			select {
			case ch <- progress:
			default:
			}
		}
		return nil
	}

	if err := r.EventBus.Subscribe(events.EventTypeServiceInstalled, handler); err != nil {
		close(ch)
		return nil, apperrors.Wrap(err, "SUBSCRIBE_FAILED", apperrors.CategoryInternal, "failed to subscribe to install events")
	}
	if err := r.EventBus.Subscribe(events.EventTypeServiceStateChanged, handler); err != nil {
		close(ch)
		return nil, apperrors.Wrap(err, "SUBSCRIBE_FAILED", apperrors.CategoryInternal, "failed to subscribe to state change events")
	}

	go func() {
		defer func() {
			if r := recover(); r != nil {
				// Log panic but don't crash service
				_ = r
			}
			close(ch)
		}()
		<-ctx.Done()
	}()

	return ch, nil
}

// InstanceStatusChanged is the resolver for the instanceStatusChanged subscription field.
func (r *subscriptionResolver) InstanceStatusChanged(ctx context.Context, routerID string) (<-chan *graphql1.InstanceStatusChanged, error) {
	if r.EventBus == nil {
		return nil, apperrors.NewProtocolError("EVENT_BUS_NOT_INIT", "event bus not initialized", "graphql")
	}

	ch := make(chan *graphql1.InstanceStatusChanged, 16)

	handler := func(_ context.Context, event events.Event) error {
		select {
		case <-ctx.Done():
			return nil
		default:
		}

		e, ok := event.(*events.ServiceStateChangedEvent)
		if !ok {
			return nil
		}

		select {
		case ch <- &graphql1.InstanceStatusChanged{
			InstanceID:     e.InstanceID,
			PreviousStatus: convertEntStatusToGraphQL(serviceinstance.Status(e.FromStatus)),
			NewStatus:      convertEntStatusToGraphQL(serviceinstance.Status(e.ToStatus)),
			Timestamp:      e.GetTimestamp(),
		}:
		default:
		}
		return nil
	}

	if err := r.EventBus.Subscribe(events.EventTypeServiceStateChanged, handler); err != nil {
		close(ch)
		return nil, apperrors.Wrap(err, "SUBSCRIBE_FAILED", apperrors.CategoryInternal, "failed to subscribe to status change events")
	}

	go func() {
		defer func() {
			if r := recover(); r != nil {
				// Log panic but don't crash service
				_ = r
			}
			close(ch)
		}()
		<-ctx.Done()
	}()

	return ch, nil
}

// VerificationEvents is the resolver for the verificationEvents subscription field.
func (r *subscriptionResolver) VerificationEvents(ctx context.Context, routerID string) (<-chan *graphql1.VerificationEvent, error) {
	if r.EventBus == nil {
		return nil, apperrors.NewProtocolError("EVENT_BUS_NOT_INIT", "event bus not initialized", "graphql")
	}

	ch := make(chan *graphql1.VerificationEvent, 16)

	handler := func(_ context.Context, event events.Event) error {
		select {
		case <-ctx.Done():
			return nil
		default:
		}

		var gqlEvent *graphql1.VerificationEvent
		ts := event.GetTimestamp()

		switch e := event.(type) {
		case *events.BinaryVerifiedEvent:
			archiveHash := e.ArchiveHash
			binaryHash := e.BinaryHash
			gpgKeyID := e.GPGKeyID
			gqlEvent = &graphql1.VerificationEvent{
				InstanceID:  e.InstanceID,
				FeatureID:   e.FeatureID,
				RouterID:    e.RouterID,
				EventType:   "verified",
				ArchiveHash: &archiveHash,
				BinaryHash:  &binaryHash,
				GpgVerified: e.GPGVerified,
				GpgKeyID:    &gpgKeyID,
				Timestamp:   ts,
			}
		case *events.BinaryVerificationFailedEvent:
			expectedHash := e.ExpectedHash
			actualHash := e.ActualHash
			failureReason := e.FailureReason
			suggestedAction := e.SuggestedAction
			gqlEvent = &graphql1.VerificationEvent{
				InstanceID:      e.InstanceID,
				FeatureID:       e.FeatureID,
				RouterID:        e.RouterID,
				EventType:       "verification_failed",
				ExpectedHash:    &expectedHash,
				ActualHash:      &actualHash,
				GpgVerified:     false,
				FailureReason:   &failureReason,
				SuggestedAction: &suggestedAction,
				Timestamp:       ts,
			}
		case *events.BinaryIntegrityFailedEvent:
			expectedHash := e.ExpectedHash
			actualHash := e.ActualHash
			gqlEvent = &graphql1.VerificationEvent{
				InstanceID:   e.InstanceID,
				FeatureID:    e.FeatureID,
				RouterID:     e.RouterID,
				EventType:    "integrity_failed",
				ExpectedHash: &expectedHash,
				ActualHash:   &actualHash,
				GpgVerified:  false,
				Timestamp:    ts,
			}
		}

		if gqlEvent != nil {
			select {
			case ch <- gqlEvent:
			default:
			}
		}
		return nil
	}

	topics := []string{
		events.EventTypeBinaryVerified,
		events.EventTypeBinaryVerificationFailed,
		events.EventTypeBinaryIntegrityFailed,
	}

	for _, topic := range topics {
		if err := r.EventBus.Subscribe(topic, handler); err != nil {
			close(ch)
			return nil, apperrors.Wrap(err, "SUBSCRIBE_FAILED", apperrors.CategoryInternal, "failed to subscribe to "+topic)
		}
	}

	go func() {
		defer func() {
			if r := recover(); r != nil {
				// Log panic but don't crash service
				_ = r
			}
			close(ch)
		}()
		<-ctx.Done()
	}()

	return ch, nil
}

// BootSequenceEvents is the resolver for the bootSequenceEvents subscription field.
func (r *subscriptionResolver) BootSequenceEvents(ctx context.Context) (<-chan *graphql1.BootSequenceEvent, error) {
	if r.EventBus == nil {
		return nil, apperrors.NewProtocolError("EVENT_BUS_NOT_INIT", "event bus not initialized", "graphql")
	}

	ch := make(chan *graphql1.BootSequenceEvent, 16)

	handler := func(_ context.Context, event events.Event) error {
		select {
		case <-ctx.Done():
			return nil
		default:
		}

		ts := event.GetTimestamp()
		var gqlEvent *graphql1.BootSequenceEvent

		switch e := event.(type) {
		case *events.BootSequenceStartedEvent:
			gqlEvent = &graphql1.BootSequenceEvent{
				ID:          event.GetID().String(),
				Type:        "started",
				Timestamp:   ts,
				InstanceIds: e.InstanceIDs,
			}
		case *events.BootSequenceLayerCompleteEvent:
			success := e.SuccessCount
			failure := e.FailureCount
			gqlEvent = &graphql1.BootSequenceEvent{
				ID:           event.GetID().String(),
				Type:         "layer_complete",
				Timestamp:    ts,
				Layer:        &e.Layer,
				InstanceIds:  e.InstanceIDs,
				SuccessCount: &success,
				FailureCount: &failure,
			}
		case *events.BootSequenceCompleteEvent:
			success := e.StartedInstances
			failure := e.FailedInstances
			ids := e.FailedIDs
			if ids == nil {
				ids = []string{}
			}
			gqlEvent = &graphql1.BootSequenceEvent{
				ID:           event.GetID().String(),
				Type:         "complete",
				Timestamp:    ts,
				InstanceIds:  ids,
				SuccessCount: &success,
				FailureCount: &failure,
			}
		case *events.BootSequenceFailedEvent:
			errMsg := e.ErrorMessage
			ids := e.StartedIDs
			if ids == nil {
				ids = []string{}
			}
			gqlEvent = &graphql1.BootSequenceEvent{
				ID:           event.GetID().String(),
				Type:         "failed",
				Timestamp:    ts,
				Layer:        &e.Layer,
				InstanceIds:  ids,
				ErrorMessage: &errMsg,
			}
		}

		if gqlEvent != nil {
			select {
			case ch <- gqlEvent:
			default:
			}
		}
		return nil
	}

	bootTopics := []string{
		events.EventTypeBootSequenceStarted,
		events.EventTypeBootSequenceLayerComplete,
		events.EventTypeBootSequenceComplete,
		events.EventTypeBootSequenceFailed,
	}

	for _, topic := range bootTopics {
		if err := r.EventBus.Subscribe(topic, handler); err != nil {
			close(ch)
			return nil, apperrors.Wrap(err, "SUBSCRIBE_FAILED", apperrors.CategoryInternal, "failed to subscribe to "+topic)
		}
	}

	go func() {
		defer func() {
			if r := recover(); r != nil {
				// Log panic but don't crash service
				_ = r
			}
			close(ch)
		}()
		<-ctx.Done()
	}()

	return ch, nil
}
