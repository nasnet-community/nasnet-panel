package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"backend/graph/model"
	"context"
	"fmt"
	"log"
)

// IpAddresses fetches all IP addresses for a router with optional interface filtering.
// Implements query ipAddresses(routerId: ID!, interfaceId: ID): [IpAddress!]!
//
// Per NAS-6.2 AC 6.2.1: User can see all configured IP addresses with address, network,
// broadcast, interface, status, and source (static/dynamic) in a sortable/filterable table.
func (r *queryResolver) IpAddresses(
	ctx context.Context,
	routerID string,
	interfaceID *string,
) ([]*model.IpAddress, error) {
	if r.IPAddressService == nil {
		return nil, fmt.Errorf("IPAddressService not initialized")
	}

	log.Printf("fetching IP addresses: router_id=%s interface_id=%v", routerID, interfaceID)

	// Fetch IP addresses from the service
	ipAddresses, err := r.IPAddressService.ListIPAddresses(ctx, routerID, interfaceID)
	if err != nil {
		log.Printf("failed to fetch IP addresses: router_id=%s error=%v", routerID, err)
		return nil, fmt.Errorf("failed to fetch IP addresses: %w", err)
	}

	// Convert to GraphQL model
	result := make([]*model.IpAddress, 0, len(ipAddresses))
	for _, ip := range ipAddresses {
		result = append(result, &model.IpAddress{
			ID:        ip.ID,
			Address:   ip.Address,
			Network:   &ip.Network,
			Broadcast: &ip.Broadcast,
			Interface: &model.Interface{
				ID:   ip.Interface,
				Name: ip.Interface, // Will be enriched by Interface resolver
			},
			Disabled: ip.Disabled,
			Dynamic:  ip.Dynamic,
			Invalid:  ip.Invalid,
			Comment:  &ip.Comment,
		})
	}

	log.Printf("successfully fetched %d IP addresses for router %s", len(result), routerID)
	return result, nil
}

// IpAddress fetches a specific IP address by ID.
// Implements query ipAddress(routerId: ID!, id: ID!): IpAddress
func (r *queryResolver) IpAddress(
	ctx context.Context,
	routerID string,
	id string,
) (*model.IpAddress, error) {
	if r.IPAddressService == nil {
		return nil, fmt.Errorf("IPAddressService not initialized")
	}

	log.Printf("fetching IP address: router_id=%s ip_id=%s", routerID, id)

	// Fetch the IP address from the service
	ip, err := r.IPAddressService.GetIPAddress(ctx, routerID, id)
	if err != nil {
		log.Printf("failed to fetch IP address: router_id=%s ip_id=%s error=%v", routerID, id, err)
		return nil, fmt.Errorf("failed to fetch IP address: %w", err)
	}

	// Convert to GraphQL model
	return &model.IpAddress{
		ID:        ip.ID,
		Address:   ip.Address,
		Network:   &ip.Network,
		Broadcast: &ip.Broadcast,
		Interface: &model.Interface{
			ID:   ip.Interface,
			Name: ip.Interface,
		},
		Disabled: ip.Disabled,
		Dynamic:  ip.Dynamic,
		Invalid:  ip.Invalid,
		Comment:  &ip.Comment,
	}, nil
}

// CheckIpConflict checks if an IP address conflicts with existing assignments.
// Implements query checkIpConflict(routerId: ID!, address: String!, interfaceId: ID, excludeId: ID): IpConflictResult!
//
// Per NAS-6.2 AC 6.2.3: Validation prevents duplicate IP addresses on different interfaces,
// showing error with existing location.
func (r *queryResolver) CheckIpConflict(
	ctx context.Context,
	routerID string,
	address string,
	interfaceID *string,
	excludeID *string,
) (*model.IpConflictResult, error) {
	if r.IPAddressService == nil {
		return nil, fmt.Errorf("IPAddressService not initialized")
	}

	log.Printf("checking IP conflict: router_id=%s address=%s interface_id=%v exclude_id=%v",
		routerID, address, interfaceID, excludeID)

	// Check for conflicts using the service
	conflictResult, err := r.IPAddressService.CheckConflict(ctx, routerID, address, interfaceID, excludeID)
	if err != nil {
		log.Printf("conflict check failed: router_id=%s address=%s error=%v", routerID, address, err)
		return nil, fmt.Errorf("conflict check failed: %w", err)
	}

	// Convert to GraphQL model
	conflicts := make([]*model.IpConflict, 0, len(conflictResult.Conflicts))
	for _, conflict := range conflictResult.Conflicts {
		conflictType := model.IpConflictType(conflict.ConflictType)
		conflicts = append(conflicts, &model.IpConflict{
			ID:      conflict.ID,
			Address: conflict.Address,
			Interface: &model.Interface{
				ID:   conflict.Interface,
				Name: conflict.Interface,
			},
			ConflictType: conflictType,
			Explanation:  conflict.Explanation,
		})
	}

	return &model.IpConflictResult{
		HasConflict: conflictResult.HasConflict,
		Conflicts:   conflicts,
		Message:     conflictResult.Message,
	}, nil
}

// IpAddressDependencies checks what depends on an IP address.
// Implements query ipAddressDependencies(routerId: ID!, id: ID!): IpAddressDependencies!
//
// Per NAS-6.2 AC 6.2.5: Deletion shows warning if IP is used by DHCP server or other services,
// requires acknowledgment.
func (r *queryResolver) IpAddressDependencies(
	ctx context.Context,
	routerID string,
	id string,
) (*model.IpAddressDependencies, error) {
	if r.IPAddressService == nil {
		return nil, fmt.Errorf("IPAddressService not initialized")
	}

	log.Printf("checking IP address dependencies: router_id=%s ip_id=%s", routerID, id)

	// Get dependencies from the service
	deps, err := r.IPAddressService.GetDependencies(ctx, routerID, id)
	if err != nil {
		log.Printf("failed to check dependencies: router_id=%s ip_id=%s error=%v", routerID, id, err)
		return nil, fmt.Errorf("failed to check dependencies: %w", err)
	}

	// Convert DHCP servers
	dhcpServers := make([]*model.DhcpServer, 0, len(deps.DHCPServers))
	for _, dhcp := range deps.DHCPServers {
		dhcpServers = append(dhcpServers, &model.DhcpServer{
			ID:   dhcp.ID,
			Name: dhcp.Name,
			Interface: &model.Interface{
				ID:   dhcp.Interface,
				Name: dhcp.Interface,
			},
			Disabled: dhcp.Disabled,
		})
	}

	// Convert routes
	routes := make([]*model.Route, 0, len(deps.Routes))
	for _, route := range deps.Routes {
		// Create minimal route representation
		// Note: This is simplified; full Route type has more fields
		destination := route.Destination
		gateway := route.Gateway
		iface := route.Interface
		disabled := !route.Active

		routes = append(routes, &model.Route{
			ID:          route.ID,
			Destination: destination,
			Gateway:     &gateway,
			Interface:   &iface,
			Distance:    1, // Default distance
			Type:        model.RouteTypeStatic,
			Scope:       model.RouteScopeGlobal,
			Active:      route.Active,
			Disabled:    &disabled,
		})
	}

	// Convert NAT rules
	natRules := make([]*model.NatRule, 0, len(deps.NATRules))
	for _, nat := range deps.NATRules {
		natRules = append(natRules, &model.NatRule{
			ID:         nat.ID,
			Chain:      nat.Chain,
			Action:     nat.Action,
			SrcAddress: &nat.SrcAddress,
			DstAddress: &nat.DstAddress,
			ToAddress:  &nat.ToAddress,
			Disabled:   nat.Disabled,
		})
	}

	// Convert firewall rules
	firewallRules := make([]*model.FirewallRule, 0, len(deps.FirewallRules))
	for _, fw := range deps.FirewallRules {
		firewallRules = append(firewallRules, &model.FirewallRule{
			ID:           fw.ID,
			Chain:        fw.Chain,
			Action:       fw.Action,
			InInterface:  &fw.InInterface,
			OutInterface: &fw.OutInterface,
			Disabled:     fw.Disabled,
		})
	}

	return &model.IpAddressDependencies{
		IpAddressID:   id,
		DhcpServers:   dhcpServers,
		Routes:        routes,
		NatRules:      natRules,
		FirewallRules: firewallRules,
		HasDependencies: deps.HasDependencies,
	}, nil
}

// CreateIpAddress assigns a new IP address to an interface.
// Implements mutation createIpAddress(routerId: ID!, input: IpAddressInput!): IpAddressMutationResult!
//
// Per NAS-6.2 AC 6.2.2: Form calculates and displays network, broadcast, and usable range
// from entered CIDR notation.
func (r *mutationResolver) CreateIpAddress(
	ctx context.Context,
	routerID string,
	input model.IpAddressInput,
) (*model.IpAddressMutationResult, error) {
	if r.IPAddressService == nil {
		return &model.IpAddressMutationResult{
			Success: false,
			Errors: []*model.MutationError{
				{
					Code:    "SERVICE_NOT_INITIALIZED",
					Message: "IPAddressService not initialized",
				},
			},
		}, nil
	}

	log.Printf("creating IP address: router_id=%s address=%s interface=%s",
		routerID, input.Address, input.InterfaceID)

	// Extract comment and disabled values
	comment := ""
	if input.Comment.IsSet() && input.Comment.Value() != nil {
		comment = *input.Comment.Value()
	}
	disabled := false
	if input.Disabled.IsSet() && input.Disabled.Value() != nil {
		disabled = *input.Disabled.Value()
	}

	// Create the IP address
	ip, err := r.IPAddressService.CreateIPAddress(
		ctx,
		routerID,
		input.Address,
		input.InterfaceID,
		comment,
		disabled,
	)
	if err != nil {
		log.Printf("failed to create IP address: router_id=%s error=%v", routerID, err)
		return &model.IpAddressMutationResult{
			Success: false,
			Errors: []*model.MutationError{
				{
					Code:    "CREATE_FAILED",
					Message: err.Error(),
					Field:   strPtr("address"),
				},
			},
		}, nil
	}

	// Invalidate cache (handled by service)
	log.Printf("successfully created IP address: router_id=%s ip_id=%s", routerID, ip.ID)

	return &model.IpAddressMutationResult{
		Success: true,
		IpAddress: &model.IpAddress{
			ID:        ip.ID,
			Address:   ip.Address,
			Network:   &ip.Network,
			Broadcast: &ip.Broadcast,
			Interface: &model.Interface{
				ID:   ip.Interface,
				Name: ip.Interface,
			},
			Disabled: ip.Disabled,
			Dynamic:  ip.Dynamic,
			Invalid:  ip.Invalid,
			Comment:  &ip.Comment,
		},
		Errors: []*model.MutationError{},
	}, nil
}

// UpdateIpAddress updates an existing IP address.
// Implements mutation updateIpAddress(routerId: ID!, id: ID!, input: IpAddressInput!): IpAddressMutationResult!
//
// Per NAS-6.2 AC 6.2.4: Changes go through Safety Pipeline showing validation, conflict check,
// and impact analysis with 10-second undo window.
func (r *mutationResolver) UpdateIpAddress(
	ctx context.Context,
	routerID string,
	id string,
	input model.IpAddressInput,
) (*model.IpAddressMutationResult, error) {
	if r.IPAddressService == nil {
		return &model.IpAddressMutationResult{
			Success: false,
			Errors: []*model.MutationError{
				{
					Code:    "SERVICE_NOT_INITIALIZED",
					Message: "IPAddressService not initialized",
				},
			},
		}, nil
	}

	log.Printf("updating IP address: router_id=%s ip_id=%s address=%s",
		routerID, id, input.Address)

	// Extract comment and disabled values
	comment := ""
	if input.Comment.IsSet() && input.Comment.Value() != nil {
		comment = *input.Comment.Value()
	}
	disabled := false
	if input.Disabled.IsSet() && input.Disabled.Value() != nil {
		disabled = *input.Disabled.Value()
	}

	// Update the IP address
	ip, err := r.IPAddressService.UpdateIPAddress(
		ctx,
		routerID,
		id,
		input.Address,
		input.InterfaceID,
		comment,
		disabled,
	)
	if err != nil {
		log.Printf("failed to update IP address: router_id=%s ip_id=%s error=%v", routerID, id, err)
		return &model.IpAddressMutationResult{
			Success: false,
			Errors: []*model.MutationError{
				{
					Code:    "UPDATE_FAILED",
					Message: err.Error(),
					Field:   strPtr("address"),
				},
			},
		}, nil
	}

	log.Printf("successfully updated IP address: router_id=%s ip_id=%s", routerID, id)

	return &model.IpAddressMutationResult{
		Success: true,
		IpAddress: &model.IpAddress{
			ID:        ip.ID,
			Address:   ip.Address,
			Network:   &ip.Network,
			Broadcast: &ip.Broadcast,
			Interface: &model.Interface{
				ID:   ip.Interface,
				Name: ip.Interface,
			},
			Disabled: ip.Disabled,
			Dynamic:  ip.Dynamic,
			Invalid:  ip.Invalid,
			Comment:  &ip.Comment,
		},
		Errors: []*model.MutationError{},
	}, nil
}

// DeleteIpAddress removes an IP address from an interface.
// Implements mutation deleteIpAddress(routerId: ID!, id: ID!): IpAddressDeleteResult!
//
// Per NAS-6.2 AC 6.2.5: Deletion shows warning if IP is used by DHCP server or other services,
// requires acknowledgment.
func (r *mutationResolver) DeleteIpAddress(
	ctx context.Context,
	routerID string,
	id string,
) (*model.IpAddressDeleteResult, error) {
	if r.IPAddressService == nil {
		return &model.IpAddressDeleteResult{
			Success: false,
			Message: strPtr("IPAddressService not initialized"),
			Errors: []*model.MutationError{
				{
					Code:    "SERVICE_NOT_INITIALIZED",
					Message: "IPAddressService not initialized",
				},
			},
		}, nil
	}

	log.Printf("deleting IP address: router_id=%s ip_id=%s", routerID, id)

	// Check dependencies first
	deps, err := r.IPAddressService.GetDependencies(ctx, routerID, id)
	if err != nil {
		log.Printf("failed to check dependencies before delete: router_id=%s ip_id=%s error=%v", routerID, id, err)
		return &model.IpAddressDeleteResult{
			Success: false,
			Message: strPtr("Failed to check dependencies"),
			Errors: []*model.MutationError{
				{
					Code:    "DEPENDENCY_CHECK_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	// Build impact analysis
	consequences := []string{}
	canDelete := true

	if len(deps.DHCPServers) > 0 {
		consequences = append(consequences, fmt.Sprintf("%d DHCP server(s) will lose their gateway", len(deps.DHCPServers)))
	}
	if len(deps.Routes) > 0 {
		consequences = append(consequences, fmt.Sprintf("%d route(s) will become invalid", len(deps.Routes)))
	}
	if len(deps.NATRules) > 0 {
		consequences = append(consequences, fmt.Sprintf("%d NAT rule(s) will stop working", len(deps.NATRules)))
	}
	if len(deps.FirewallRules) > 0 {
		consequences = append(consequences, fmt.Sprintf("%d firewall rule(s) will be affected", len(deps.FirewallRules)))
	}

	severity := model.ConfirmationSeverityStandard
	impactMessage := "This IP address can be safely deleted."
	if deps.HasDependencies {
		severity = model.ConfirmationSeverityCritical
		impactMessage = fmt.Sprintf("Warning: This IP address is used by %d service(s). Deleting it may disrupt network functionality.",
			len(deps.DHCPServers)+len(deps.Routes)+len(deps.NATRules)+len(deps.FirewallRules))
		// Allow deletion but warn user
		canDelete = true
	}

	// Convert dependencies to GraphQL models (same as in IpAddressDependencies)
	dhcpServers := make([]*model.DhcpServer, 0, len(deps.DHCPServers))
	for _, dhcp := range deps.DHCPServers {
		dhcpServers = append(dhcpServers, &model.DhcpServer{
			ID:   dhcp.ID,
			Name: dhcp.Name,
			Interface: &model.Interface{
				ID:   dhcp.Interface,
				Name: dhcp.Interface,
			},
			Disabled: dhcp.Disabled,
		})
	}

	natRules := make([]*model.NatRule, 0, len(deps.NATRules))
	for _, nat := range deps.NATRules {
		natRules = append(natRules, &model.NatRule{
			ID:         nat.ID,
			Chain:      nat.Chain,
			Action:     nat.Action,
			SrcAddress: &nat.SrcAddress,
			DstAddress: &nat.DstAddress,
			ToAddress:  &nat.ToAddress,
			Disabled:   nat.Disabled,
		})
	}

	firewallRules := make([]*model.FirewallRule, 0, len(deps.FirewallRules))
	for _, fw := range deps.FirewallRules {
		firewallRules = append(firewallRules, &model.FirewallRule{
			ID:           fw.ID,
			Chain:        fw.Chain,
			Action:       fw.Action,
			InInterface:  &fw.InInterface,
			OutInterface: &fw.OutInterface,
			Disabled:     fw.Disabled,
		})
	}

	impactAnalysis := &model.IpAddressImpactAnalysis{
		UsedByDhcpServers:   dhcpServers,
		UsedInFirewallRules: firewallRules,
		UsedInNatRules:      natRules,
		ActiveConnections:   0, // Not implemented yet
		Severity:            severity,
		Message:             impactMessage,
		Consequences:        consequences,
		CanDelete:           canDelete,
	}

	// Proceed with deletion
	err = r.IPAddressService.DeleteIPAddress(ctx, routerID, id)
	if err != nil {
		log.Printf("failed to delete IP address: router_id=%s ip_id=%s error=%v", routerID, id, err)
		return &model.IpAddressDeleteResult{
			Success:        false,
			Message:        strPtr("Failed to delete IP address"),
			ImpactAnalysis: impactAnalysis,
			Errors: []*model.MutationError{
				{
					Code:    "DELETE_FAILED",
					Message: err.Error(),
				},
			},
		}, nil
	}

	log.Printf("successfully deleted IP address: router_id=%s ip_id=%s", routerID, id)

	return &model.IpAddressDeleteResult{
		Success:        true,
		Message:        strPtr("IP address deleted successfully"),
		ImpactAnalysis: impactAnalysis,
		Errors:         []*model.MutationError{},
	}, nil
}
