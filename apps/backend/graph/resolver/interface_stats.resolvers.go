package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
	"time"

	"backend/graph/model"
)

// InterfaceStatsHistory is the resolver for the interfaceStatsHistory field.
func (r *queryResolver) InterfaceStatsHistory(
	ctx context.Context,
	routerID string,
	interfaceID string,
	timeRange model.StatsTimeRangeInput,
	interval *string,
) (*model.InterfaceStatsHistory, error) {
	// Default interval to 5 minutes if not specified
	intervalStr := "5m"
	if interval != nil {
		intervalStr = *interval
	}

	// Validate interval is within acceptable range
	duration, err := time.ParseDuration(intervalStr)
	if err != nil {
		return nil, fmt.Errorf("invalid interval format: %w", err)
	}

	// Enforce minimum 1 second interval
	if duration < 1*time.Second {
		return nil, fmt.Errorf("interval must be at least 1 second")
	}

	// Query telemetry service for historical stats
	if r.TelemetryService == nil {
		return nil, fmt.Errorf("telemetry service not initialized")
	}

	return r.TelemetryService.GetInterfaceStatsHistory(
		ctx,
		routerID,
		interfaceID,
		timeRange,
		intervalStr,
	)
}

// InterfaceStatsUpdated is the resolver for the interfaceStatsUpdated field.
func (r *subscriptionResolver) InterfaceStatsUpdated(
	ctx context.Context,
	routerID string,
	interfaceID string,
	interval *string,
) (<-chan *model.InterfaceStats, error) {
	// Default interval to 5 seconds if not specified
	intervalDuration := 5 * time.Second
	if interval != nil {
		duration, err := time.ParseDuration(*interval)
		if err != nil {
			return nil, fmt.Errorf("invalid interval format: %w", err)
		}
		intervalDuration = duration
	}

	// Enforce minimum 1 second interval for rate limiting
	if intervalDuration < 1*time.Second {
		intervalDuration = 1 * time.Second
	}

	// Enforce maximum 30 second interval
	if intervalDuration > 30*time.Second {
		intervalDuration = 30 * time.Second
	}

	// Subscribe to stats updates through stats poller
	if r.StatsPoller == nil {
		return nil, fmt.Errorf("stats poller not initialized")
	}

	return r.StatsPoller.Subscribe(ctx, routerID, interfaceID, intervalDuration)
}
