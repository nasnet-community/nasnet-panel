package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/generated/ent"
	"backend/generated/ent/alert"
	"backend/graph/model"
	"backend/internal/alerts"
	"backend/internal/errors"
	"context"
	"fmt"
)

// AlertRuleTemplates is the resolver for the alertRuleTemplates field.
func (r *queryResolver) AlertRuleTemplates(ctx context.Context, category *model.AlertRuleTemplateCategory) ([]*model.AlertRuleTemplate, error) {
	// Check authorization: user must be authenticated
	if r.authService == nil {
		return nil, errors.NewAuthError(errors.CodeAuthFailed, "authentication service not available")
	}

	if r.AlertRuleTemplateService == nil {
		return nil, errors.NewValidationError("alertRuleTemplateService", nil, "service not available")
	}

	// Convert GraphQL category to service category
	var serviceCategory *alerts.AlertRuleTemplateCategory
	if category != nil {
		c := alerts.AlertRuleTemplateCategory(*category)
		serviceCategory = &c
	}

	// Get templates from service
	templates, err := r.AlertRuleTemplateService.GetTemplates(ctx, serviceCategory)
	if err != nil {
		if r.log != nil {
			r.log.Errorw("failed to get alert rule templates", "error", err)
		}
		return nil, errors.NewProtocolError(errors.CodeCommandFailed, "failed to get templates", "graphql").WithCause(err)
	}

	// Convert service templates to GraphQL model
	result := make([]*model.AlertRuleTemplate, len(templates))
	for i, tmpl := range templates {
		result[i] = convertAlertRuleTemplateToModel(tmpl)
	}

	return result, nil
}

// AlertRuleTemplate is the resolver for the alertRuleTemplate field.
func (r *queryResolver) AlertRuleTemplate(ctx context.Context, id string) (*model.AlertRuleTemplate, error) {
	// Check authorization: user must be authenticated
	if r.authService == nil {
		return nil, errors.NewAuthError(errors.CodeAuthFailed, "authentication service not available")
	}

	if r.AlertRuleTemplateService == nil {
		return nil, errors.NewValidationError("alertRuleTemplateService", nil, "service not available")
	}

	// Validate input: id must not be empty
	if id == "" {
		return nil, errors.NewValidationError("id", id, "template id cannot be empty")
	}

	template, err := r.AlertRuleTemplateService.GetTemplateByID(ctx, id)
	if err != nil {
		if r.log != nil {
			r.log.Errorw("failed to get alert rule template", "id", id, "error", err)
		}
		return nil, errors.NewValidationError("id", id, "template not found").WithCause(err)
	}

	return convertAlertRuleTemplateToModel(template), nil
}

// PreviewAlertRuleTemplate is the resolver for the previewAlertRuleTemplate field.
func (r *queryResolver) PreviewAlertRuleTemplate(ctx context.Context, templateID string, variables map[string]any) (*model.AlertRuleTemplatePreview, error) {
	// Check authorization: user must be authenticated
	if r.authService == nil {
		return nil, errors.NewAuthError(errors.CodeAuthFailed, "authentication service not available")
	}

	if r.AlertRuleTemplateService == nil {
		return nil, errors.NewValidationError("alertRuleTemplateService", nil, "service not available")
	}

	// Validate input: templateID must not be empty
	if templateID == "" {
		return nil, errors.NewValidationError("templateID", templateID, "template id cannot be empty")
	}

	preview, err := r.AlertRuleTemplateService.PreviewTemplate(ctx, templateID, variables)
	if err != nil {
		if r.log != nil {
			r.log.Errorw("failed to preview alert rule template", "templateId", templateID, "error", err)
		}
		return nil, errors.NewProtocolError(errors.CodeCommandFailed, "preview failed", "graphql").WithCause(err)
	}

	// Convert to GraphQL model
	result := &model.AlertRuleTemplatePreview{
		Template:           convertAlertRuleTemplateToModel(preview.Template),
		ResolvedConditions: make([]*model.AlertCondition, len(preview.ResolvedConditions)),
		ValidationInfo: &model.TemplateValidationInfo{
			IsValid:          preview.ValidationInfo.IsValid,
			MissingVariables: preview.ValidationInfo.MissingVariables,
			Warnings:         preview.ValidationInfo.Warnings,
		},
	}

	// Convert resolved conditions
	for i, cond := range preview.ResolvedConditions {
		result.ResolvedConditions[i] = &model.AlertCondition{
			Field:    cond.Field,
			Operator: model.ConditionOperator(cond.Operator),
			Value:    stringifyValue(cond.Value),
		}
	}

	return result, nil
}

// AlertTemplates is the resolver for the alertTemplates field.
func (r *queryResolver) AlertTemplates(ctx context.Context, eventType *string, channel *model.NotificationChannel) ([]*model.AlertTemplate, error) {
	panic(errors.NewProtocolError(errors.CodeCommandFailed, "not implemented: AlertTemplates - alertTemplates", "graphql"))
}

// AlertTemplate is the resolver for the alertTemplate field.
func (r *queryResolver) AlertTemplate(ctx context.Context, id string) (*model.AlertTemplate, error) {
	panic(errors.NewProtocolError(errors.CodeCommandFailed, "not implemented: AlertTemplate - alertTemplate", "graphql"))
}

// CommonEventTypes is the resolver for the commonEventTypes field.
func (r *queryResolver) CommonEventTypes(ctx context.Context) ([]string, error) {
	panic(errors.NewProtocolError(errors.CodeCommandFailed, "not implemented: CommonEventTypes - commonEventTypes", "graphql"))
}

// SearchAlertTemplates is the resolver for the searchAlertTemplates field.
func (r *queryResolver) SearchAlertTemplates(ctx context.Context, query string) ([]*model.AlertTemplate, error) {
	panic(errors.NewProtocolError(errors.CodeCommandFailed, "not implemented: SearchAlertTemplates - searchAlertTemplates", "graphql"))
}

// PreviewAlertTemplate is the resolver for the previewAlertTemplate field.
func (r *queryResolver) PreviewAlertTemplate(ctx context.Context, templateID string, variables map[string]any) (*model.TemplatePreviewPayload, error) {
	panic(errors.NewProtocolError(errors.CodeCommandFailed, "not implemented: PreviewAlertTemplate - previewAlertTemplate", "graphql"))
}

// AlertRules is the resolver for the alertRules field.
func (r *queryResolver) AlertRules(ctx context.Context, deviceID *string) ([]*model.AlertRule, error) {
	panic(errors.NewProtocolError(errors.CodeCommandFailed, "not implemented: AlertRules - alertRules", "graphql"))
}

// AlertRule is the resolver for the alertRule field.
func (r *queryResolver) AlertRule(ctx context.Context, id string) (*model.AlertRule, error) {
	panic(errors.NewProtocolError(errors.CodeCommandFailed, "not implemented: AlertRule - alertRule", "graphql"))
}

// Alerts is the resolver for the alerts field.
func (r *queryResolver) Alerts(ctx context.Context, deviceID *string, severity *model.AlertSeverity, acknowledged *bool, limit *int, offset *int) (*model.AlertConnection, error) {
	panic(errors.NewProtocolError(errors.CodeCommandFailed, "not implemented: Alerts - alerts", "graphql"))
}

// ServiceAlerts is the resolver for the serviceAlerts field.
func (r *queryResolver) ServiceAlerts(ctx context.Context, instanceID string, severity *model.AlertSeverity, acknowledged *bool, limit *int, offset *int) (*model.AlertConnection, error) {
	// Check authorization: user must be authenticated
	if r.authService == nil {
		return nil, errors.NewAuthError(errors.CodeAuthFailed, "authentication service not available")
	}

	// Validate database client availability
	if r.db == nil {
		if r.log != nil {
			r.log.Errorw("database client not available")
		}
		return nil, errors.NewProtocolError(errors.CodeResourceNotFound, "database client not available", "graphql")
	}

	// Validate input: instanceID must not be empty
	if instanceID == "" {
		return nil, errors.NewValidationError("instanceID", instanceID, "instance id cannot be empty")
	}

	// Set default pagination values and validate
	pageLimit := 50
	if limit != nil {
		if *limit < 1 {
			return nil, errors.NewValidationError("limit", *limit, "limit must be greater than 0")
		}
		pageLimit = *limit
	}
	pageOffset := 0
	if offset != nil {
		if *offset < 0 {
			return nil, errors.NewValidationError("offset", *offset, "offset cannot be negative")
		}
		pageOffset = *offset
	}

	// Build query with source_type and source_id filters
	query := r.db.Alert.Query().
		Where(
			alert.SourceType("service"),
			alert.SourceID(instanceID),
		)

	// Apply optional filters
	if severity != nil {
		query = query.Where(alert.SeverityEQ(alert.Severity(string(*severity))))
	}

	if acknowledged != nil {
		if *acknowledged {
			query = query.Where(alert.AcknowledgedAtNotNil())
		} else {
			query = query.Where(alert.AcknowledgedAtIsNil())
		}
	}

	// Get total count for pagination
	totalCount, err := query.Clone().Count(ctx)
	if err != nil {
		if r.log != nil {
			r.log.Errorw("failed to count service alerts", "instanceId", instanceID, "error", err)
		}
		return nil, errors.Wrap(err, errors.CodeResourceNotFound, errors.CategoryInternal, "failed to count alerts")
	}

	// Query with pagination, order by most recent first
	alerts, err := query.
		Order(ent.Desc(alert.FieldTriggeredAt)).
		Limit(pageLimit).
		Offset(pageOffset).
		All(ctx)

	if err != nil {
		if r.log != nil {
			r.log.Errorw("failed to query service alerts", "instanceId", instanceID, "error", err)
		}
		return nil, errors.Wrap(err, errors.CodeResourceNotFound, errors.CategoryInternal, "failed to query alerts")
	}

	// Convert to GraphQL model
	edges := make([]*model.AlertEdge, len(alerts))
	for i, alert := range alerts {
		edges[i] = &model.AlertEdge{
			Node:   convertAlertToModel(alert),
			Cursor: alert.ID, // Use alert ID as cursor
		}
	}

	return &model.AlertConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     (pageOffset + pageLimit) < totalCount,
			HasPreviousPage: pageOffset > 0,
		},
		TotalCount: totalCount,
	}, nil
}

func stringifyValue(v interface{}) string {
	if s, ok := v.(string); ok {
		return s
	}
	if v == nil {
		return ""
	}
	// Use the type's String() method if available
	if stringer, ok := v.(interface{ String() string }); ok {
		return stringer.String()
	}
	// Fall back to %v formatting
	return fmt.Sprintf("%v", v)
}
