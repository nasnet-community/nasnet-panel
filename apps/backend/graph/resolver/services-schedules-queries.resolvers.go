package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/graph/model"
	"backend/internal/apperrors"
	"context"
)

// RoutingSchedule returns a specific routing schedule by ID.
func (r *queryResolver) RoutingSchedule(ctx context.Context, routerID string, scheduleID string) (*model.RoutingSchedule, error) {
	r.log.Infow("RoutingSchedule query called",
		"routerID", routerID,
		"scheduleID", scheduleID)

	// Check authorization: user must be authenticated
	if r.authService == nil {
		return nil, apperrors.NewInternalError("authentication service not available", nil)
	}

	// Check if ScheduleService is available
	if r.ScheduleService == nil {
		return nil, apperrors.NewInternalError("schedule service not available", nil)
	}

	// Get schedule from service
	schedule, err := r.ScheduleService.GetSchedule(ctx, scheduleID)
	if err != nil {
		r.log.Errorw("failed to get schedule",
			"error", err,
			"scheduleID", scheduleID)
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryResource, "failed to get schedule")
	}

	// Convert to GraphQL model
	result := convertRoutingScheduleToModel(schedule, r.ScheduleEvaluator)

	r.log.Infow("schedule retrieved",
		"scheduleID", scheduleID,
		"routingID", result.RoutingID)

	return result, nil
}

// RoutingSchedules returns all schedules for a device routing.
func (r *queryResolver) RoutingSchedules(ctx context.Context, routerID string, routingID string) ([]*model.RoutingSchedule, error) {
	r.log.Infow("RoutingSchedules query called",
		"routerID", routerID,
		"routingID", routingID)

	// Check authorization: user must be authenticated
	if r.authService == nil {
		return nil, apperrors.NewInternalError("authentication service not available", nil)
	}

	// Check if ScheduleService is available
	if r.ScheduleService == nil {
		return nil, apperrors.NewInternalError("schedule service not available", nil)
	}

	// Get schedules from service
	schedules, err := r.ScheduleService.GetSchedulesByRouting(ctx, routingID)
	if err != nil {
		r.log.Errorw("failed to get schedules",
			"error", err,
			"routingID", routingID)
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryResource, "failed to get schedules")
	}

	// Convert to GraphQL model
	result := make([]*model.RoutingSchedule, len(schedules))
	for i, schedule := range schedules {
		result[i] = convertRoutingScheduleToModel(schedule, r.ScheduleEvaluator)
	}

	r.log.Infow("schedules retrieved",
		"routingID", routingID,
		"count", len(result))

	return result, nil
}
