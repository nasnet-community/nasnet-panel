package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/graph/model"
	"backend/internal/common/ulid"
	"backend/internal/provisioning/types"
	provsvc "backend/internal/services/provisioning"
	"context"
	"fmt"
	"time"
)

// StartProvisioningSession is the resolver for the startProvisioningSession field.
func (r *mutationResolver) StartProvisioningSession(ctx context.Context, routerID string, input model.StartProvisioningSessionInput) (*model.ProvisioningSessionPayload, error) {
	mode := types.ModeEasy
	if input.Mode == model.ProvisioningModeAdvance {
		mode = types.ModeAdvance
	}

	state := types.StarState{
		Choose: types.ChooseState{
			Mode: mode,
		},
	}

	session, err := r.ProvisioningService.CreateSession(ctx, routerID, state)
	if err != nil {
		return nil, fmt.Errorf("create session: %w", err)
	}

	return &model.ProvisioningSessionPayload{Session: toGQLSession(session)}, nil
}

// AddProvisioningResource is the resolver for the addProvisioningResource field.
func (r *mutationResolver) AddProvisioningResource(ctx context.Context, sessionID string, input model.AddProvisioningResourceInput) (*model.ProvisioningSessionPayload, error) {
	resource := provsvc.SessionResource{
		ID:            ulid.NewString(),
		ResourceType:  input.ResourceType,
		Configuration: input.Configuration,
		Relationships: map[string]interface{}{},
	}

	if err := r.ProvisioningService.AddResource(ctx, sessionID, resource); err != nil {
		return nil, fmt.Errorf("add resource: %w", err)
	}

	session, err := r.ProvisioningService.GetSession(ctx, sessionID)
	if err != nil {
		return nil, fmt.Errorf("get session: %w", err)
	}

	return &model.ProvisioningSessionPayload{Session: toGQLSession(session)}, nil
}

// RemoveProvisioningResource is the resolver for the removeProvisioningResource field.
func (r *mutationResolver) RemoveProvisioningResource(ctx context.Context, sessionID string, resourceID string) (*model.ProvisioningSessionPayload, error) {
	if err := r.ProvisioningService.RemoveResource(ctx, sessionID, resourceID); err != nil {
		return nil, fmt.Errorf("remove resource: %w", err)
	}

	session, err := r.ProvisioningService.GetSession(ctx, sessionID)
	if err != nil {
		return nil, fmt.Errorf("get session: %w", err)
	}

	return &model.ProvisioningSessionPayload{Session: toGQLSession(session)}, nil
}

// UpdateProvisioningNetworks is the resolver for the updateProvisioningNetworks field.
func (r *mutationResolver) UpdateProvisioningNetworks(ctx context.Context, sessionID string, networksConfig map[string]any) (*model.ProvisioningSessionPayload, error) {
	if err := r.ProvisioningService.UpdateNetworksConfig(ctx, sessionID, networksConfig); err != nil {
		return nil, fmt.Errorf("update networks config: %w", err)
	}

	session, err := r.ProvisioningService.GetSession(ctx, sessionID)
	if err != nil {
		return nil, fmt.Errorf("get session: %w", err)
	}

	return &model.ProvisioningSessionPayload{Session: toGQLSession(session)}, nil
}

// NextProvisioningStep is the resolver for the nextProvisioningStep field.
func (r *mutationResolver) NextProvisioningStep(ctx context.Context, sessionID string) (*model.ProvisioningSessionPayload, error) {
	if err := r.ProvisioningService.AdvanceStep(ctx, sessionID); err != nil {
		return nil, fmt.Errorf("advance step: %w", err)
	}

	session, err := r.ProvisioningService.GetSession(ctx, sessionID)
	if err != nil {
		return nil, fmt.Errorf("get session: %w", err)
	}

	return &model.ProvisioningSessionPayload{Session: toGQLSession(session)}, nil
}

// PrevProvisioningStep is the resolver for the prevProvisioningStep field.
func (r *mutationResolver) PrevProvisioningStep(ctx context.Context, sessionID string) (*model.ProvisioningSessionPayload, error) {
	if err := r.ProvisioningService.RetreatStep(ctx, sessionID); err != nil {
		return nil, fmt.Errorf("retreat step: %w", err)
	}

	session, err := r.ProvisioningService.GetSession(ctx, sessionID)
	if err != nil {
		return nil, fmt.Errorf("get session: %w", err)
	}

	return &model.ProvisioningSessionPayload{Session: toGQLSession(session)}, nil
}

// ValidateProvisioningSession is the resolver for the validateProvisioningSession field.
func (r *mutationResolver) ValidateProvisioningSession(ctx context.Context, sessionID string) (*model.ValidateProvisioningSessionPayload, error) {
	issues, err := r.ProvisioningService.ValidateSession(ctx, sessionID)
	if err != nil {
		return nil, fmt.Errorf("validate session: %w", err)
	}

	session, err := r.ProvisioningService.GetSession(ctx, sessionID)
	if err != nil {
		return nil, fmt.Errorf("get session: %w", err)
	}

	// Group issues by resource ID
	byResource := make(map[string]*model.ResourceValidationResult)
	isValid := true
	for _, issue := range issues {
		if issue.Severity == "error" {
			isValid = false
		}
		res, ok := byResource[issue.ResourceID]
		if !ok {
			res = &model.ResourceValidationResult{
				ResourceID: issue.ResourceID,
				IsValid:    true,
			}
			byResource[issue.ResourceID] = res
		}
		if issue.Severity == "error" {
			res.IsValid = false
			res.Errors = append(res.Errors, issue.Message)
		} else {
			res.Warnings = append(res.Warnings, issue.Message)
		}
	}

	validationResults := make([]*model.ResourceValidationResult, 0, len(byResource))
	for _, v := range byResource {
		validationResults = append(validationResults, v)
	}

	return &model.ValidateProvisioningSessionPayload{
		Session:           toGQLSession(session),
		ValidationResults: validationResults,
		IsValid:           isValid,
	}, nil
}

// ApplyProvisioningSession is the resolver for the applyProvisioningSession field.
func (r *mutationResolver) ApplyProvisioningSession(ctx context.Context, sessionID string) (*model.ApplyProvisioningSessionPayload, error) {
	if err := r.ProvisioningService.ApplySession(ctx, sessionID); err != nil {
		session, getErr := r.ProvisioningService.GetSession(ctx, sessionID)
		if getErr != nil {
			return nil, fmt.Errorf("apply session: %w", err)
		}
		var gqlSession *model.ProvisioningSession
		if session != nil {
			gqlSession = toGQLSession(session)
		}
		return &model.ApplyProvisioningSessionPayload{
			Session: gqlSession,
			Errors:  []*model.MutationError{{Code: "APPLY_SESSION_FAILED", Message: err.Error()}},
		}, nil
	}

	session, err := r.ProvisioningService.GetSession(ctx, sessionID)
	if err != nil {
		return nil, fmt.Errorf("get session: %w", err)
	}

	return &model.ApplyProvisioningSessionPayload{
		Session:          toGQLSession(session),
		AppliedResources: []model.Resource{},
		ChangesetID:      sessionID,
	}, nil
}

// ImportStarState is the resolver for the importStarState field.
func (r *mutationResolver) ImportStarState(ctx context.Context, routerID string, input model.ImportStarStateInput) (*model.ProvisioningSessionPayload, error) {
	// Build a minimal StarState from the raw map input.
	// The full decomposition happens inside ImportStarState.
	state := types.StarState{}

	session, err := r.ProvisioningService.ImportStarState(ctx, routerID, state)
	if err != nil {
		return nil, fmt.Errorf("import star state: %w", err)
	}

	return &model.ProvisioningSessionPayload{Session: toGQLSession(session)}, nil
}

// DiscardProvisioningSession is the resolver for the discardProvisioningSession field.
func (r *mutationResolver) DiscardProvisioningSession(ctx context.Context, sessionID string) (*model.DiscardProvisioningSessionPayload, error) {
	if err := r.ProvisioningService.DiscardSession(ctx, sessionID); err != nil {
		return nil, fmt.Errorf("discard session: %w", err)
	}

	return &model.DiscardProvisioningSessionPayload{
		Success:   true,
		SessionID: sessionID,
	}, nil
}

// ProvisioningSession is the resolver for the provisioningSession field.
func (r *queryResolver) ProvisioningSession(ctx context.Context, id string) (*model.ProvisioningSession, error) {
	session, err := r.ProvisioningService.GetSession(ctx, id)
	if err != nil {
		return nil, err
	}
	return toGQLSession(session), nil
}

// ProvisioningSessions is the resolver for the provisioningSessions field.
func (r *queryResolver) ProvisioningSessions(ctx context.Context, routerID string, pagination *model.PaginationInput) (*model.ProvisioningSessionConnection, error) {
	// TODO: Implement paginated session listing backed by persistent store.
	return &model.ProvisioningSessionConnection{
		Edges:      []*model.ProvisioningSessionEdge{},
		PageInfo:   &model.PageInfo{},
		TotalCount: 0,
	}, nil
}

// AvailableProvisioningResources is the resolver for the availableProvisioningResources field.
func (r *queryResolver) AvailableProvisioningResources(ctx context.Context, firmware model.ProvisioningFirmware, routerMode model.ProvisioningRouterMode) ([]string, error) {
	// Returns the full list of supported provisioning resource types.
	return []string{
		"vpn.wireguard.client",
		"vpn.openvpn.client",
		"vpn.pptp.client",
		"vpn.l2tp.client",
		"vpn.sstp.client",
		"vpn.ikev2.client",
		"vpn.wireguard.server",
		"vpn.pptp.server",
		"vpn.l2tp.server",
		"vpn.sstp.server",
		"vpn.openvpn.server",
		"vpn.ikev2.server",
		"tunnel.ipip",
		"tunnel.eoip",
		"tunnel.gre",
		"tunnel.vxlan",
		"system.identity",
		"system.ntp",
		"system.services",
		"system.ddns",
		"system.dns",
		"wan.link.domestic",
		"wan.link.foreign",
		"wan.multilink.domestic",
		"wan.multilink.foreign",
	}, nil
}

// ProvisioningSessionProgress is the resolver for the provisioningSessionProgress field.
func (r *subscriptionResolver) ProvisioningSessionProgress(ctx context.Context, sessionID string) (<-chan *model.ProvisioningProgressEvent, error) {
	// TODO: Wire up to event bus for real-time provisioning progress events.
	ch := make(chan *model.ProvisioningProgressEvent, 1)
	ch <- &model.ProvisioningProgressEvent{
		SessionID:       sessionID,
		Phase:           "idle",
		Step:            0,
		TotalSteps:      0,
		Message:         "Waiting for provisioning to start",
		Status:          model.ProvisioningApplyStatusDraft,
		PercentComplete: 0,
		Timestamp:       time.Now(),
	}
	close(ch)
	return ch, nil
}

// ProvisioningSessionChanged is the resolver for the provisioningSessionChanged field.
func (r *subscriptionResolver) ProvisioningSessionChanged(ctx context.Context, routerID string) (<-chan *model.ProvisioningSession, error) {
	// TODO: Wire up to event bus to push session change events.
	ch := make(chan *model.ProvisioningSession)
	close(ch)
	return ch, nil
}
