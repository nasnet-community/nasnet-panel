package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"backend/graph/model"
	"backend/internal/auth"
	"backend/internal/credentials"
	"backend/internal/encryption"
	"backend/internal/middleware"
	"context"
	"sync"
	"time"
)

// UpdateRouterCredentials is the resolver for the updateRouterCredentials field.
func (r *mutationResolver) UpdateRouterCredentials(ctx context.Context, routerID string, input model.CredentialsInput) (*model.CredentialUpdatePayload, error) {
	// Check authentication
	user := middleware.UserFromContext(ctx)
	if user == nil {
		return &model.CredentialUpdatePayload{
			Success:   false,
			Message:   "Authentication required",
			ErrorCode: credPtr(model.CredentialErrorCodeAuthFailed),
		}, nil
	}

	if r.CredentialService == nil {
		return &model.CredentialUpdatePayload{
			Success:   false,
			Message:   "Credential service not configured",
			ErrorCode: credPtr(model.CredentialErrorCodeInvalidInput),
		}, nil
	}

	// Validate input
	if input.Username == "" || input.Password == "" {
		return &model.CredentialUpdatePayload{
			Success:   false,
			Message:   "Username and password are required",
			ErrorCode: credPtr(model.CredentialErrorCodeInvalidInput),
		}, nil
	}

	// Test credentials before saving (if RouterService is available)
	if r.RouterService != nil {
		testResult := r.RouterService.TestCredentials(ctx, routerID, input.Username, input.Password)
		if !testResult.Success {
			errorCode := mapTestStatusToCredErrorCode(testResult.Status)
			return &model.CredentialUpdatePayload{
				Success:   false,
				Message:   "Credential test failed: " + testResult.Error,
				ErrorCode: &errorCode,
			}, nil
		}
	}

	// Check if credentials already exist
	exists, err := r.CredentialService.Exists(ctx, nil, routerID)
	if err != nil {
		return &model.CredentialUpdatePayload{
			Success:   false,
			Message:   "Failed to check existing credentials: " + err.Error(),
			ErrorCode: credPtr(model.CredentialErrorCodeEncryptionFailed),
		}, nil
	}

	var secret interface{}
	if exists {
		// Update existing credentials
		secret, err = r.CredentialService.Update(ctx, nil, routerID, credentials.UpdateInput{
			Username: input.Username,
			Password: input.Password,
		})
	} else {
		// Create new credentials
		secret, err = r.CredentialService.Create(ctx, nil, routerID, credentials.UpdateInput{
			Username: input.Username,
			Password: input.Password,
		})
	}

	if err != nil {
		if err == credentials.ErrRouterNotFound {
			return &model.CredentialUpdatePayload{
				Success:   false,
				Message:   "Router not found",
				ErrorCode: credPtr(model.CredentialErrorCodeRouterNotFound),
			}, nil
		}
		return &model.CredentialUpdatePayload{
			Success:   false,
			Message:   "Failed to update credentials: " + err.Error(),
			ErrorCode: credPtr(model.CredentialErrorCodeEncryptionFailed),
		}, nil
	}

	// Publish audit event
	if r.EventPublisher != nil {
		r.EventPublisher.PublishCredentialChanged(ctx, routerID, user.ID, getClientIP(ctx))
	}

	_ = secret // Used for future reference

	// Get updated credential info
	info, _ := r.CredentialService.GetInfo(ctx, nil, routerID)
	var creds *model.RouterCredentials
	if info != nil {
		creds = &model.RouterCredentials{
			RouterID:         info.RouterID,
			Username:         info.Username,
			HasPassword:      info.HasPassword,
			EncryptionStatus: info.EncryptionStatus,
			KeyVersion:       info.KeyVersion,
			LastUpdated:      info.LastUpdated,
			CreatedAt:        info.CreatedAt,
		}
	}

	return &model.CredentialUpdatePayload{
		Success:     true,
		Message:     "Credentials updated successfully",
		Credentials: creds,
	}, nil
}

// TestAllCredentials is the resolver for the testAllCredentials field.
func (r *mutationResolver) TestAllCredentials(ctx context.Context) (*model.TestAllCredentialsPayload, error) {
	// Check authentication
	user := middleware.UserFromContext(ctx)
	if user == nil {
		return nil, newGQLError(auth.ErrCodeInvalidCredentials, "Authentication required")
	}

	if r.RouterService == nil {
		return nil, newGQLError("ROUTER.NOT_CONFIGURED", "Router service not configured")
	}

	// Get all routers from the service
	routers, err := r.RouterService.GetAllRouters(ctx)
	if err != nil {
		return nil, newGQLError("ROUTER.FETCH_FAILED", "Failed to fetch routers: "+err.Error())
	}

	if len(routers) == 0 {
		return &model.TestAllCredentialsPayload{
			TotalRouters: 0,
			SuccessCount: 0,
			FailureCount: 0,
			Results:      []*model.CredentialTestResult{},
		}, nil
	}

	// Test all credentials in parallel
	var wg sync.WaitGroup
	resultsChan := make(chan *model.CredentialTestResult, len(routers))

	// Limit concurrent tests to prevent overwhelming the network
	semaphore := make(chan struct{}, 10) // Max 10 concurrent tests

	for _, router := range routers {
		wg.Add(1)
		go func(routerID, routerName, host string, port int) {
			defer wg.Done()

			// Acquire semaphore
			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			result := r.testRouterCredentials(ctx, routerID, routerName, host, port)
			resultsChan <- result
		}(router.ID, router.Name, router.Host, router.Port)
	}

	// Wait for all tests to complete
	go func() {
		wg.Wait()
		close(resultsChan)
	}()

	// Collect results
	var results []*model.CredentialTestResult
	successCount := 0
	failureCount := 0

	for result := range resultsChan {
		results = append(results, result)
		if result.Success {
			successCount++
		} else {
			failureCount++
		}
	}

	return &model.TestAllCredentialsPayload{
		TotalRouters: len(routers),
		SuccessCount: successCount,
		FailureCount: failureCount,
		Results:      results,
	}, nil
}

// ExportRouterConfig is the resolver for the exportRouterConfig field.
func (r *mutationResolver) ExportRouterConfig(ctx context.Context, input model.ExportConfigInput) (*model.ExportConfigPayload, error) {
	// Check authentication
	user := middleware.UserFromContext(ctx)
	if user == nil {
		return nil, newGQLError(auth.ErrCodeInvalidCredentials, "Authentication required")
	}

	// Default: exclude credentials
	includeCredentials := false
	if input.IncludeCredentials.IsSet() {
		if v := input.IncludeCredentials.Value(); v != nil {
			includeCredentials = *v
		}
	}

	// If including credentials, encryption key is required
	if includeCredentials {
		if !input.EncryptionKey.IsSet() || input.EncryptionKey.Value() == nil || *input.EncryptionKey.Value() == "" {
			return &model.ExportConfigPayload{
				Success:         false,
				SecurityWarning: stringPtr("Encryption key is required when including credentials in export"),
				Errors: []*model.MutationError{{
					Code:    "ENCRYPTION_KEY_REQUIRED",
					Message: "You must provide an encryption key to export credentials",
				}},
			}, nil
		}

		// Validate encryption key (must be valid for AES-256)
		keyBytes := []byte(*input.EncryptionKey.Value())
		if len(keyBytes) != encryption.KeySize {
			return &model.ExportConfigPayload{
				Success:         false,
				SecurityWarning: stringPtr("Invalid encryption key size"),
				Errors: []*model.MutationError{{
					Code:    "INVALID_KEY_SIZE",
					Message: "Encryption key must be exactly 32 bytes for AES-256",
				}},
			}, nil
		}
	}

	// Get router configuration (placeholder - would get actual config)
	config := map[string]interface{}{
		"routerId": input.RouterID,
		"exported": time.Now().Format(time.RFC3339),
	}

	// Add security warning
	securityWarning := "Credentials are excluded from export by default for security."
	if includeCredentials {
		securityWarning = "WARNING: Credentials are included in this export and encrypted with your provided key. Keep the encryption key secure."
	}

	return &model.ExportConfigPayload{
		Success:         true,
		Config:          config,
		SecurityWarning: &securityWarning,
	}, nil
}

// RouterCredentials is the resolver for the routerCredentials field.
func (r *queryResolver) RouterCredentials(ctx context.Context, routerID string) (*model.RouterCredentials, error) {
	// Check authentication
	user := middleware.UserFromContext(ctx)
	if user == nil {
		return nil, newGQLError(auth.ErrCodeInvalidCredentials, "Authentication required")
	}

	if r.CredentialService == nil {
		return nil, newGQLError("CREDENTIALS.NOT_CONFIGURED", "Credential service not configured")
	}

	// Get credential info (this never returns the password)
	info, err := r.CredentialService.GetInfo(ctx, nil, routerID)
	if err != nil {
		if err == credentials.ErrCredentialsNotFound {
			return nil, nil // Return nil for non-existent credentials
		}
		return nil, newGQLError("CREDENTIALS.FETCH_FAILED", err.Error())
	}

	return &model.RouterCredentials{
		RouterID:         info.RouterID,
		Username:         info.Username,
		HasPassword:      info.HasPassword,
		EncryptionStatus: info.EncryptionStatus,
		KeyVersion:       info.KeyVersion,
		LastUpdated:      info.LastUpdated,
		CreatedAt:        info.CreatedAt,
	}, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *mutationResolver) testRouterCredentials(ctx context.Context, routerID, routerName, host string, port int) *model.CredentialTestResult {
	result := &model.CredentialTestResult{
		RouterID:   routerID,
		RouterName: routerName,
		Success:    false,
		Status:     model.CredentialTestStatusError,
	}

	// Check if credentials exist
	if r.CredentialService == nil {
		result.Error = stringPtr("Credential service not available")
		return result
	}

	// Get credentials
	creds, err := r.CredentialService.Get(ctx, nil, routerID)
	if err != nil {
		if err == credentials.ErrCredentialsNotFound {
			result.Status = model.CredentialTestStatusNoCredentials
			result.Error = stringPtr("No credentials stored for this router")
		} else {
			result.Error = stringPtr("Failed to retrieve credentials: " + err.Error())
		}
		return result
	}

	// Test the connection
	start := time.Now()
	testResult := r.RouterService.TestCredentials(ctx, routerID, creds.Username, creds.Password)
	responseTime := int(time.Since(start).Milliseconds())

	result.Status = mapStringToCredTestStatus(testResult.Status)
	result.Success = testResult.Success
	if testResult.Success {
		result.ResponseTimeMs = &responseTime
	} else {
		result.Error = stringPtr(testResult.Error)
	}

	return result
}
func mapStringToCredTestStatus(status string) model.CredentialTestStatus {
	switch status {
	case "SUCCESS":
		return model.CredentialTestStatusSuccess
	case "AUTH_FAILED":
		return model.CredentialTestStatusAuthFailed
	case "TIMEOUT":
		return model.CredentialTestStatusTimeout
	case "CONNECTION_REFUSED":
		return model.CredentialTestStatusConnectionRefused
	case "NETWORK_ERROR":
		return model.CredentialTestStatusNetworkError
	case "NO_CREDENTIALS":
		return model.CredentialTestStatusNoCredentials
	default:
		return model.CredentialTestStatusError
	}
}
func mapTestStatusToCredErrorCode(status string) model.CredentialErrorCode {
	switch status {
	case "AUTH_FAILED":
		return model.CredentialErrorCodeAuthFailed
	case "TIMEOUT":
		return model.CredentialErrorCodeTimeout
	case "CONNECTION_REFUSED":
		return model.CredentialErrorCodeConnectionRefused
	default:
		return model.CredentialErrorCodeInvalidInput
	}
}
func credPtr(v model.CredentialErrorCode) *model.CredentialErrorCode {
	return &v
}
