package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"backend/generated/ent"
	"backend/generated/ent/serviceinstance"
	graphql1 "backend/graph/model"
	"backend/internal/errors"
	"backend/internal/events"
	"context"
	"time"
)

// SetTrafficQuota is the resolver for the setTrafficQuota field.
func (r *mutationResolver) SetTrafficQuota(ctx context.Context, input graphql1.SetTrafficQuotaInput) (*graphql1.TrafficQuotaPayload, error) {
	if r.QuotaEnforcer == nil {
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "quota enforcer not available"}},
		}, nil
	}

	period, err := mapQuotaPeriod(input.Period)
	if err != nil {
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: err.Error()}},
		}, nil
	}

	action, err := mapQuotaAction(input.Action)
	if err != nil {
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: err.Error()}},
		}, nil
	}

	if err := r.QuotaEnforcer.SetQuota(ctx, input.InstanceID, int64(input.LimitBytes), period, action); err != nil {
		errMsg := errors.Wrap(err, errors.CodeResourceNotFound, errors.CategoryInternal, "failed to set quota").Error()
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	// Fetch the updated instance to return the quota
	instance, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		// Quota was set, but we couldn't fetch the result â€” still a success
		return &graphql1.TrafficQuotaPayload{Success: true}, nil
	}

	return &graphql1.TrafficQuotaPayload{
		Success: true,
		Quota:   buildTrafficQuotaFromInstance(instance),
	}, nil
}

// ResetTrafficQuota is the resolver for the resetTrafficQuota field.
func (r *mutationResolver) ResetTrafficQuota(ctx context.Context, routerID string, instanceID string) (*graphql1.TrafficQuotaPayload, error) {
	if r.QuotaEnforcer == nil {
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "quota enforcer not available"}},
		}, nil
	}

	instance, err := r.db.ServiceInstance.Get(ctx, instanceID)
	if err != nil {
		errMsg := errors.Wrap(err, errors.CodeResourceNotFound, errors.CategoryResource, "instance not found").Error()
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	if err := r.QuotaEnforcer.ResetQuota(ctx, instance); err != nil {
		errMsg := errors.Wrap(err, errors.CodeResourceNotFound, errors.CategoryInternal, "failed to reset quota").Error()
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	// Re-fetch after reset to get updated fields
	instance, err = r.db.ServiceInstance.Get(ctx, instanceID)
	if err != nil {
		return &graphql1.TrafficQuotaPayload{Success: true}, nil
	}

	return &graphql1.TrafficQuotaPayload{
		Success: true,
		Quota:   buildTrafficQuotaFromInstance(instance),
	}, nil
}

// ServiceTrafficStats is the resolver for the serviceTrafficStats field.
// Returns traffic statistics for a service instance over a specified history period.
// All traffic metrics are in BYTES (not bits).
func (r *queryResolver) ServiceTrafficStats(ctx context.Context, routerID string, instanceID string, historyHours *int) (*graphql1.ServiceTrafficStats, error) {
	if r.TrafficAggregator == nil {
		return nil, errors.Wrap(nil, errors.CodeResourceNotFound, errors.CategoryInternal, "traffic aggregator not available")
	}

	// Validate and set history duration (default: last 24 hours)
	hours := 24
	if historyHours != nil && *historyHours > 0 {
		hours = *historyHours
	}

	endTime := time.Now()
	startTime := endTime.Add(-time.Duration(hours) * time.Hour)

	records, err := r.TrafficAggregator.GetHourlyTraffic(ctx, instanceID, startTime, endTime)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeResourceNotFound, errors.CategoryInternal, "failed to fetch traffic history")
	}

	// Build history data points and aggregate totals
	// All values are in BYTES. TxBytes = upload, RxBytes = download.
	history := make([]*graphql1.TrafficDataPoint, 0, len(records))
	var totalUpload, totalDownload int64
	for _, rec := range records {
		// Cast int64 to int for GraphQL response. Large traffic amounts may be truncated.
		history = append(history, &graphql1.TrafficDataPoint{
			Timestamp:     rec.HourStart,
			UploadBytes:   int(rec.TxBytes),
			DownloadBytes: int(rec.RxBytes),
			TotalBytes:    int(rec.TxBytes + rec.RxBytes),
		})
		totalUpload += rec.TxBytes
		totalDownload += rec.RxBytes
	}

	// Fetch instance for quota and period info
	var quota *graphql1.TrafficQuota
	var periodUpload, periodDownload int64
	instance, instanceErr := r.db.ServiceInstance.Get(ctx, instanceID)
	if instanceErr == nil && instance != nil {
		if instance.QuotaBytes != nil {
			quota = buildTrafficQuotaFromInstance(instance)
		}

		// Current period totals: from period start to now
		// Quota period is reset at QuotaResetAt; if not set, use entire history
		if instance.QuotaResetAt != nil {
			periodDur := quotaPeriodDuration(instance.QuotaPeriod)
			periodStart := instance.QuotaResetAt.Add(-periodDur)
			periodRecords, periodErr := r.TrafficAggregator.GetHourlyTraffic(ctx, instanceID, periodStart, endTime)
			if periodErr == nil {
				for _, rec := range periodRecords {
					periodUpload += rec.TxBytes
					periodDownload += rec.RxBytes
				}
			}
		} else {
			periodUpload = totalUpload
			periodDownload = totalDownload
		}
	} else {
		// No instance found or fetch failed; use history totals as period totals
		periodUpload = totalUpload
		periodDownload = totalDownload
	}

	lastUpdated := endTime
	if len(records) > 0 {
		lastUpdated = records[len(records)-1].HourStart
	}

	return &graphql1.ServiceTrafficStats{
		InstanceID:            instanceID,
		TotalUploadBytes:      int(totalUpload),
		TotalDownloadBytes:    int(totalDownload),
		CurrentPeriodUpload:   int(periodUpload),
		CurrentPeriodDownload: int(periodDownload),
		History:               history,
		// DeviceBreakdown is populated by the separate ServiceDeviceBreakdown query.
		// Returned as empty here to avoid fetching all device data in main query.
		DeviceBreakdown: []*graphql1.DeviceTrafficBreakdown{},
		Quota:           quota,
		LastUpdated:     lastUpdated,
	}, nil
}

// ServiceDeviceBreakdown is the resolver for the serviceDeviceBreakdown field.
func (r *queryResolver) ServiceDeviceBreakdown(ctx context.Context, routerID string, instanceID string) ([]*graphql1.DeviceTrafficBreakdown, error) {
	if r.DeviceTrafficTracker == nil {
		return nil, errors.Wrap(nil, errors.CodeResourceNotFound, errors.CategoryInternal, "device traffic tracker not available")
	}

	breakdown, err := r.DeviceTrafficTracker.GetDeviceBreakdown(ctx, instanceID)
	if err != nil {
		return nil, errors.Wrap(err, errors.CodeResourceNotFound, errors.CategoryInternal, "failed to get device breakdown")
	}

	return breakdown, nil
}

// ServiceTrafficUpdated is the resolver for the serviceTrafficUpdated field.
func (r *subscriptionResolver) ServiceTrafficUpdated(ctx context.Context, routerID string, instanceID string) (<-chan *graphql1.TrafficStatsEvent, error) {
	ch := make(chan *graphql1.TrafficStatsEvent, 10)

	if r.EventBus == nil {
		close(ch)
		return ch, nil
	}

	// Handler dispatches quota events for this instance as TrafficStatsEvents
	handler := func(hCtx context.Context, event events.Event) error {
		var statsEvent *graphql1.TrafficStatsEvent

		switch e := event.(type) {
		case *events.QuotaWarning80Event:
			if e.InstanceID != instanceID {
				return nil
			}
			statsEvent = &graphql1.TrafficStatsEvent{
				InstanceID:        e.InstanceID,
				RouterID:          e.RouterID,
				TotalUploadBytes:  int(e.UsedBytes),
				QuotaWarning:      true,
				QuotaLimitReached: false,
				Timestamp:         e.GetTimestamp(),
			}
		case *events.QuotaWarning90Event:
			if e.InstanceID != instanceID {
				return nil
			}
			statsEvent = &graphql1.TrafficStatsEvent{
				InstanceID:        e.InstanceID,
				RouterID:          e.RouterID,
				TotalUploadBytes:  int(e.UsedBytes),
				QuotaWarning:      true,
				QuotaLimitReached: false,
				Timestamp:         e.GetTimestamp(),
			}
		case *events.QuotaExceededEvent:
			if e.InstanceID != instanceID {
				return nil
			}
			statsEvent = &graphql1.TrafficStatsEvent{
				InstanceID:        e.InstanceID,
				RouterID:          e.RouterID,
				TotalUploadBytes:  int(e.UsedBytes),
				QuotaWarning:      true,
				QuotaLimitReached: true,
				Timestamp:         e.GetTimestamp(),
			}
		default:
			return nil
		}

		if statsEvent != nil {
			select {
			case ch <- statsEvent:
			case <-hCtx.Done():
			default:
			}
		}
		return nil
	}

	for _, eventType := range []string{
		events.EventTypeQuotaWarning80,
		events.EventTypeQuotaWarning90,
		events.EventTypeQuotaExceeded,
	} {
		if subErr := r.EventBus.Subscribe(eventType, handler); subErr != nil {
			close(ch)
			return nil, errors.Wrap(subErr, errors.CodeResourceNotFound, errors.CategoryInternal, "failed to subscribe to "+eventType+" events")
		}
	}

	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
}

func mapQuotaPeriod(period graphql1.QuotaPeriod) (serviceinstance.QuotaPeriod, error) {
	switch period {
	case graphql1.QuotaPeriodDaily:
		return serviceinstance.QuotaPeriodDaily, nil
	case graphql1.QuotaPeriodWeekly:
		return serviceinstance.QuotaPeriodWeekly, nil
	case graphql1.QuotaPeriodMonthly:
		return serviceinstance.QuotaPeriodMonthly, nil
	default:
		return "", errors.NewValidationError("period", period, "unknown quota period")
	}
}
func mapQuotaAction(action graphql1.QuotaAction) (serviceinstance.QuotaAction, error) {
	switch action {
	case graphql1.QuotaActionLogOnly:
		return serviceinstance.QuotaActionLOG_ONLY, nil
	case graphql1.QuotaActionAlert:
		return serviceinstance.QuotaActionALERT, nil
	case graphql1.QuotaActionStopService:
		return serviceinstance.QuotaActionSTOP_SERVICE, nil
	case graphql1.QuotaActionThrottle:
		return serviceinstance.QuotaActionTHROTTLE, nil
	default:
		return "", errors.NewValidationError("action", action, "unknown quota action")
	}
}
func buildTrafficQuotaFromInstance(instance *ent.ServiceInstance) *graphql1.TrafficQuota {
	if instance == nil || instance.QuotaBytes == nil {
		return nil
	}

	quotaBytes := *instance.QuotaBytes
	// QuotaUsedBytes tracks cumulative bytes used in current period
	usedBytes := instance.QuotaUsedBytes

	// Calculate remaining bytes (floor at 0 to prevent negative values)
	remainingBytes := quotaBytes - usedBytes
	if remainingBytes < 0 {
		remainingBytes = 0
	}

	// Calculate usage percentage (prevents division by zero)
	var usagePercent float64
	if quotaBytes > 0 {
		usagePercent = float64(usedBytes) / float64(quotaBytes) * 100.0
	}

	period := graphql1.QuotaPeriodMonthly
	if instance.QuotaPeriod != nil {
		switch *instance.QuotaPeriod {
		case serviceinstance.QuotaPeriodDaily:
			period = graphql1.QuotaPeriodDaily
		case serviceinstance.QuotaPeriodWeekly:
			period = graphql1.QuotaPeriodWeekly
		case serviceinstance.QuotaPeriodMonthly:
			period = graphql1.QuotaPeriodMonthly
		}
	}

	action := graphql1.QuotaActionLogOnly
	if instance.QuotaAction != nil {
		switch *instance.QuotaAction {
		case serviceinstance.QuotaActionLOG_ONLY:
			action = graphql1.QuotaActionLogOnly
		case serviceinstance.QuotaActionALERT:
			action = graphql1.QuotaActionAlert
		case serviceinstance.QuotaActionSTOP_SERVICE:
			action = graphql1.QuotaActionStopService
		case serviceinstance.QuotaActionTHROTTLE:
			action = graphql1.QuotaActionThrottle
		}
	}

	now := time.Now()
	periodDur := quotaPeriodDuration(instance.QuotaPeriod)
	periodStartedAt := now.Add(-periodDur)
	periodEndsAt := now.Add(periodDur)

	// If QuotaResetAt is set, use it as the period boundary (when counter was last reset)
	if instance.QuotaResetAt != nil {
		periodEndsAt = *instance.QuotaResetAt
		periodStartedAt = periodEndsAt.Add(-periodDur)
	}

	// Warning threshold at 80% (hardcoded; consider making configurable)
	warningThreshold := 80

	return &graphql1.TrafficQuota{
		ID:               instance.ID,
		InstanceID:       instance.ID,
		LimitBytes:       int(quotaBytes),
		Period:           period,
		Action:           action,
		ConsumedBytes:    int(usedBytes),
		RemainingBytes:   int(remainingBytes),
		UsagePercent:     usagePercent,
		LimitReached:     usagePercent >= 100.0,
		WarningThreshold: warningThreshold,
		WarningTriggered: usagePercent >= float64(warningThreshold),
		PeriodStartedAt:  periodStartedAt,
		PeriodEndsAt:     periodEndsAt,
		CreatedAt:        instance.CreatedAt,
		UpdatedAt:        instance.UpdatedAt,
	}
}
func quotaPeriodDuration(period *serviceinstance.QuotaPeriod) time.Duration {
	if period == nil {
		return 24 * time.Hour
	}
	switch *period {
	case serviceinstance.QuotaPeriodDaily:
		return 24 * time.Hour
	case serviceinstance.QuotaPeriodWeekly:
		return 7 * 24 * time.Hour
	case serviceinstance.QuotaPeriodMonthly:
		return 30 * 24 * time.Hour
	default:
		return 24 * time.Hour
	}
}
