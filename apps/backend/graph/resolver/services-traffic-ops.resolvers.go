package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	graphql1 "backend/graph/model"
	"backend/internal/apperrors"
	"backend/internal/events"
	"context"
	"time"
)

// SetTrafficQuota is the resolver for the setTrafficQuota field.
func (r *mutationResolver) SetTrafficQuota(ctx context.Context, input graphql1.SetTrafficQuotaInput) (*graphql1.TrafficQuotaPayload, error) {
	if r.QuotaEnforcer == nil {
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "quota enforcer not available"}},
		}, nil
	}

	period, periodErr := mapQuotaPeriod(input.Period)
	if periodErr != nil {
		//nolint:nilerr // returns structured error in payload per GraphQL convention
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: periodErr.Error()}},
		}, nil
	}

	action, actionErr := mapQuotaAction(input.Action)
	if actionErr != nil {
		//nolint:nilerr // returns structured error in payload per GraphQL convention
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: actionErr.Error()}},
		}, nil
	}

	if setErr := r.QuotaEnforcer.SetQuota(ctx, input.InstanceID, int64(input.LimitBytes), period, action); setErr != nil {
		errMsg := apperrors.Wrap(setErr, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "failed to set quota").Error()
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	// Fetch the updated instance to return the quota
	instance, err := r.db.ServiceInstance.Get(ctx, input.InstanceID)
	if err != nil {
		// Quota was set, but we couldn't fetch the result â€” still a success
		//nolint:nilerr // returns structured error in payload per GraphQL convention
		return &graphql1.TrafficQuotaPayload{Success: true}, nil
	}

	return &graphql1.TrafficQuotaPayload{
		Success: true,
		Quota:   buildTrafficQuotaFromInstance(instance),
	}, nil
}

// ResetTrafficQuota is the resolver for the resetTrafficQuota field.
func (r *mutationResolver) ResetTrafficQuota(ctx context.Context, routerID string, instanceID string) (*graphql1.TrafficQuotaPayload, error) {
	if r.QuotaEnforcer == nil {
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "quota enforcer not available"}},
		}, nil
	}

	instance, err := r.db.ServiceInstance.Get(ctx, instanceID)
	if err != nil {
		errMsg := apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryResource, "instance not found").Error()
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	if resetErr := r.QuotaEnforcer.ResetQuota(ctx, instance); resetErr != nil {
		errMsg := apperrors.Wrap(resetErr, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "failed to reset quota").Error()
		return &graphql1.TrafficQuotaPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: errMsg}},
		}, nil
	}

	// Re-fetch after reset to get updated fields
	instance, err = r.db.ServiceInstance.Get(ctx, instanceID)
	if err != nil {
		//nolint:nilerr // returns structured error in payload per GraphQL convention
		return &graphql1.TrafficQuotaPayload{Success: true}, nil
	}

	return &graphql1.TrafficQuotaPayload{
		Success: true,
		Quota:   buildTrafficQuotaFromInstance(instance),
	}, nil
}

// ServiceTrafficStats is the resolver for the serviceTrafficStats field.
// Returns traffic statistics for a service instance over a specified history period.
// All traffic metrics are in BYTES (not bits).
func (r *queryResolver) ServiceTrafficStats(ctx context.Context, routerID string, instanceID string, historyHours *int) (*graphql1.ServiceTrafficStats, error) {
	if r.TrafficAggregator == nil {
		return nil, apperrors.NewResourceError(
			apperrors.CodeResourceNotFound,
			"traffic aggregator not available",
			"service",
			"traffic_aggregator",
		)
	}

	// Validate and set history duration (default: last 24 hours)
	hours := 24
	if historyHours != nil && *historyHours > 0 {
		hours = *historyHours
	}

	endTime := time.Now()
	startTime := endTime.Add(-time.Duration(hours) * time.Hour)

	records, err := r.TrafficAggregator.GetHourlyTraffic(ctx, instanceID, startTime, endTime)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "failed to fetch traffic history")
	}

	// Build history data points and aggregate totals
	// All values are in BYTES. TxBytes = upload, RxBytes = download.
	history := make([]*graphql1.TrafficDataPoint, 0, len(records))
	var totalUpload, totalDownload int64
	for _, rec := range records {
		// Cast int64 to int for GraphQL response. Large traffic amounts may be truncated.
		history = append(history, &graphql1.TrafficDataPoint{
			Timestamp:     rec.HourStart,
			UploadBytes:   int(rec.TxBytes),
			DownloadBytes: int(rec.RxBytes),
			TotalBytes:    int(rec.TxBytes + rec.RxBytes),
		})
		totalUpload += rec.TxBytes
		totalDownload += rec.RxBytes
	}

	// Fetch instance for quota and period info
	var quota *graphql1.TrafficQuota
	var periodUpload, periodDownload int64
	instance, instanceErr := r.db.ServiceInstance.Get(ctx, instanceID)
	if instanceErr == nil && instance != nil {
		if instance.QuotaBytes != nil {
			quota = buildTrafficQuotaFromInstance(instance)
		}
		periodUpload, periodDownload = r.calculatePeriodTraffic(ctx, endTime, instanceID, instance, totalUpload, totalDownload)
	} else {
		// No instance found or fetch failed; use history totals as period totals
		periodUpload = totalUpload
		periodDownload = totalDownload
	}

	lastUpdated := endTime
	if len(records) > 0 {
		lastUpdated = records[len(records)-1].HourStart
	}

	return &graphql1.ServiceTrafficStats{
		InstanceID:            instanceID,
		TotalUploadBytes:      int(totalUpload),
		TotalDownloadBytes:    int(totalDownload),
		CurrentPeriodUpload:   int(periodUpload),
		CurrentPeriodDownload: int(periodDownload),
		History:               history,
		// DeviceBreakdown is populated by the separate ServiceDeviceBreakdown query.
		// Returned as empty here to avoid fetching all device data in main query.
		DeviceBreakdown: []*graphql1.DeviceTrafficBreakdown{},
		Quota:           quota,
		LastUpdated:     lastUpdated,
	}, nil
}

// ServiceDeviceBreakdown is the resolver for the serviceDeviceBreakdown field.
func (r *queryResolver) ServiceDeviceBreakdown(ctx context.Context, routerID string, instanceID string) ([]*graphql1.DeviceTrafficBreakdown, error) {
	if r.DeviceTrafficTracker == nil {
		return nil, apperrors.NewResourceError(
			apperrors.CodeResourceNotFound,
			"device traffic tracker not available",
			"service",
			"device_traffic_tracker",
		)
	}

	breakdown, err := r.DeviceTrafficTracker.GetDeviceBreakdown(ctx, instanceID)
	if err != nil {
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "failed to get device breakdown")
	}

	return breakdown, nil
}

// ServiceTrafficUpdated is the resolver for the serviceTrafficUpdated field.
func (r *subscriptionResolver) ServiceTrafficUpdated(ctx context.Context, routerID string, instanceID string) (<-chan *graphql1.TrafficStatsEvent, error) {
	ch := make(chan *graphql1.TrafficStatsEvent, 10)

	if r.EventBus == nil {
		close(ch)
		return ch, nil
	}

	// Handler dispatches quota events for this instance as TrafficStatsEvents
	handler := func(hCtx context.Context, event events.Event) error {
		var statsEvent *graphql1.TrafficStatsEvent

		switch e := event.(type) {
		case *events.QuotaWarning80Event:
			if e.InstanceID != instanceID {
				return nil
			}
			statsEvent = &graphql1.TrafficStatsEvent{
				InstanceID:        e.InstanceID,
				RouterID:          e.RouterID,
				TotalUploadBytes:  int(e.UsedBytes),
				QuotaWarning:      true,
				QuotaLimitReached: false,
				Timestamp:         e.GetTimestamp(),
			}
		case *events.QuotaWarning90Event:
			if e.InstanceID != instanceID {
				return nil
			}
			statsEvent = &graphql1.TrafficStatsEvent{
				InstanceID:        e.InstanceID,
				RouterID:          e.RouterID,
				TotalUploadBytes:  int(e.UsedBytes),
				QuotaWarning:      true,
				QuotaLimitReached: false,
				Timestamp:         e.GetTimestamp(),
			}
		case *events.QuotaExceededEvent:
			if e.InstanceID != instanceID {
				return nil
			}
			statsEvent = &graphql1.TrafficStatsEvent{
				InstanceID:        e.InstanceID,
				RouterID:          e.RouterID,
				TotalUploadBytes:  int(e.UsedBytes),
				QuotaWarning:      true,
				QuotaLimitReached: true,
				Timestamp:         e.GetTimestamp(),
			}
		default:
			return nil
		}

		//nolint:S1009 // statsEvent is always non-nil at this point due to switch cases above
		select {
		case ch <- statsEvent:
		case <-hCtx.Done():
		default:
		}
		return nil
	}

	for _, eventType := range []string{
		events.EventTypeQuotaWarning80,
		events.EventTypeQuotaWarning90,
		events.EventTypeQuotaExceeded,
	} {
		if subErr := r.EventBus.Subscribe(eventType, handler); subErr != nil {
			close(ch)
			msg := "failed to subscribe to " + eventType + " events"
			return nil, apperrors.Wrap(
				subErr,
				apperrors.CodeResourceNotFound,
				apperrors.CategoryInternal,
				msg,
			)
		}
	}

	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
}
