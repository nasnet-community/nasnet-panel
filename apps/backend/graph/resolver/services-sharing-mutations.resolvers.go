package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	graphql1 "backend/graph/model"
	"backend/internal/apperrors"
	"backend/internal/events"
	"backend/internal/features/sharing"
	"context"
	"encoding/base64"
	"fmt"
)

// ExportServiceConfig is the resolver for the exportServiceConfig field.
func (r *mutationResolver) ExportServiceConfig(ctx context.Context, input graphql1.ExportServiceConfigInput) (*graphql1.ExportServiceConfigPayload, error) {
	// Validate inputs
	if input.InstanceID == "" {
		return &graphql1.ExportServiceConfigPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "instance ID is required"}},
		}, nil
	}

	if r.SharingService == nil {
		return &graphql1.ExportServiceConfigPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "sharing service not available"}},
		}, nil
	}

	options := sharing.ExportOptions{
		RedactSecrets:       input.RedactSecrets,
		IncludeRoutingRules: input.IncludeRoutingRules,
	}

	pkg, err := r.SharingService.Export(ctx, input.InstanceID, options)
	if err != nil {
		return nil, fmt.Errorf("export service config failed: %w", err)
	}

	modelPkg := convertSharingExportToModel(pkg)
	return &graphql1.ExportServiceConfigPayload{
		Success: true,
		Package: modelPkg,
	}, nil
}

// ImportServiceConfig is the resolver for the importServiceConfig field.
func (r *mutationResolver) ImportServiceConfig(ctx context.Context, input graphql1.ImportServiceConfigInput) (*graphql1.ImportServiceConfigPayload, error) {
	// Validate inputs
	if input.RouterID == "" {
		return &graphql1.ImportServiceConfigPayload{
			Valid:  false,
			Errors: []*graphql1.MutationError{{Message: "router ID is required"}},
		}, nil
	}
	if input.Package == nil {
		return &graphql1.ImportServiceConfigPayload{
			Valid:  false,
			Errors: []*graphql1.MutationError{{Message: "package is required"}},
		}, nil
	}

	if r.SharingService == nil {
		return &graphql1.ImportServiceConfigPayload{
			Valid:  false,
			Errors: []*graphql1.MutationError{{Message: "sharing service not available"}},
		}, nil
	}

	pkg, err := mapToExportPackage(input.Package)
	if err != nil {
		//nolint:nilerr // returns structured error in payload per GraphQL convention
		return &graphql1.ImportServiceConfigPayload{
			Valid:  false,
			Errors: []*graphql1.MutationError{{Message: "invalid package format: " + err.Error()}},
		}, nil
	}

	options := sharing.ImportOptions{
		RouterID: input.RouterID,
	}
	if input.ConflictResolution.IsSet() && input.ConflictResolution.Value() != nil {
		cr := input.ConflictResolution.Value()
		options.ConflictResolution = convertConflictResolution(cr)
	}
	if input.RedactedFieldValues.IsSet() {
		rfv := input.RedactedFieldValues.Value()
		options.RedactedFieldValues = convertRedactedFieldValues(rfv)
	}
	if input.DeviceFilter.IsSet() {
		options.DeviceFilter = input.DeviceFilter.Value()
	}
	if input.DryRun.IsSet() && input.DryRun.Value() != nil {
		options.DryRun = *input.DryRun.Value()
	}

	result, err := r.SharingService.Import(ctx, pkg, options)
	if err != nil {
		return nil, fmt.Errorf("import service config failed: %w", err)
	}

	modelResult := convertValidationResultToModel(result)
	return &graphql1.ImportServiceConfigPayload{
		Valid:            result.Valid,
		ValidationResult: modelResult,
	}, nil
}

// ApplyServiceImport is the resolver for the applyServiceImport field.
func (r *mutationResolver) ApplyServiceImport(ctx context.Context, input graphql1.ApplyServiceImportInput) (*graphql1.ApplyServiceImportPayload, error) {
	// Validate inputs
	if input.RouterID == "" {
		return &graphql1.ApplyServiceImportPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "router ID is required"}},
		}, nil
	}
	if input.Package == nil {
		return &graphql1.ApplyServiceImportPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "package is required"}},
		}, nil
	}

	if r.SharingService == nil {
		return &graphql1.ApplyServiceImportPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "sharing service not available"}},
		}, nil
	}

	pkg, err := mapToExportPackage(input.Package)
	if err != nil {
		//nolint:nilerr // returns structured error in payload per GraphQL convention
		return &graphql1.ApplyServiceImportPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "invalid package format: " + err.Error()}},
		}, nil
	}

	options := sharing.ImportOptions{
		RouterID:            input.RouterID,
		ConflictResolution:  convertConflictResolutionRequired(input.ConflictResolution),
		RedactedFieldValues: convertRedactedFieldValuesRequired(input.RedactedFieldValues),
	}
	if input.DeviceFilter.IsSet() {
		options.DeviceFilter = input.DeviceFilter.Value()
	}

	instance, err := r.SharingService.ApplyImport(ctx, pkg, options)
	if err != nil {
		return nil, fmt.Errorf("apply service import failed: %w", err)
	}

	return &graphql1.ApplyServiceImportPayload{
		Success:  true,
		Instance: convertEntInstanceToModel(instance),
	}, nil
}

// GenerateConfigQR is the resolver for the generateConfigQR field.
func (r *mutationResolver) GenerateConfigQR(ctx context.Context, input graphql1.GenerateConfigQRInput) (*graphql1.GenerateConfigQRPayload, error) {
	// Validate inputs
	if input.InstanceID == "" {
		return &graphql1.GenerateConfigQRPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "instance ID is required"}},
		}, nil
	}

	if r.SharingService == nil {
		return &graphql1.GenerateConfigQRPayload{
			Success: false,
			Errors:  []*graphql1.MutationError{{Message: "sharing service not available"}},
		}, nil
	}

	// First export the service config
	exportOptions := sharing.ExportOptions{
		RedactSecrets:       input.RedactSecrets,
		IncludeRoutingRules: input.IncludeRoutingRules,
	}

	pkg, err := r.SharingService.Export(ctx, input.InstanceID, exportOptions)
	if err != nil {
		return nil, fmt.Errorf("export for QR generation failed: %w", err)
	}

	// Build QR options
	qrOptions := sharing.QRCodeOptions{}
	if input.ImageSize.IsSet() && input.ImageSize.Value() != nil {
		qrOptions.Size = *input.ImageSize.Value()
	}

	pngData, err := r.SharingService.GenerateQR(ctx, pkg, qrOptions)
	if err != nil {
		return nil, fmt.Errorf("QR generation failed: %w", err)
	}

	// Encode PNG as base64
	encoded := base64.StdEncoding.EncodeToString(pngData)
	dataSize := len(pngData)
	// ImageSize is the rendered size in pixels, not bytes; typically width x height
	// For now, return the data size as it's not clear what the desired image size should be
	imageSize := len(encoded)

	return &graphql1.GenerateConfigQRPayload{
		Success:         true,
		ImageDataBase64: &encoded,
		DataSize:        &dataSize,
		ImageSize:       &imageSize,
	}, nil
}

// ServiceConfigShared is the resolver for the serviceConfigShared field.
func (r *subscriptionResolver) ServiceConfigShared(ctx context.Context, routerID string) (<-chan *graphql1.ServiceConfigSharedEvent, error) {
	// Validate inputs
	if routerID == "" {
		return nil, apperrors.Wrap(nil, apperrors.CodeValidationFailed, apperrors.CategoryValidation, "router ID is required")
	}

	if r.EventBus == nil {
		return nil, apperrors.Wrap(nil, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "event bus not available")
	}

	eventChan := make(chan *graphql1.ServiceConfigSharedEvent, 10)

	err := r.EventBus.Subscribe("service.config.*", func(ctx context.Context, event events.Event) error {
		sharedEvent := &graphql1.ServiceConfigSharedEvent{
			ID:        event.GetID().String(),
			EventType: event.GetType(),
			RouterID:  routerID,
			Timestamp: event.GetTimestamp(),
		}

		select {
		case eventChan <- sharedEvent:
		case <-ctx.Done():
		}
		return nil
	})
	if err != nil {
		close(eventChan)
		return nil, apperrors.Wrap(err, apperrors.CodeResourceNotFound, apperrors.CategoryInternal, "failed to subscribe to sharing events")
	}

	go func() {
		<-ctx.Done()
		close(eventChan)
	}()

	return eventChan, nil
}
