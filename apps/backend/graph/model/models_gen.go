// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

// Connection interface for paginated results (Relay pagination)
type Connection interface {
	IsConnection()
}

// Edge interface for connection edges
type Edge interface {
	IsEdge()
}

// Relay Node interface for global object identification
type Node interface {
	IsNode()
}

// Input for manually adding a new router with full credentials and protocol preference.
// This is the primary input type for the addRouter mutation.
type AddRouterInput struct {
	// Router hostname or IP address.
	// Can be an IPv4 address (e.g., '192.168.88.1'), IPv6 address, or hostname (e.g., 'router.local').
	// Hostnames will trigger DNS resolution with caching.
	Host string `json:"host"`
	// Connection port. If not specified, defaults to protocol-specific port:
	// - REST: 443 (or 80 for HTTP)
	// - API: 8728
	// - API_SSL: 8729
	// - SSH: 22
	// - Telnet: 23
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Username for authentication.
	// For MikroTik routers, this is typically 'admin' or a custom user.
	Username string `json:"username"`
	// Password for authentication.
	// This value is encrypted before storage and never logged.
	Password string `json:"password"`
	// Protocol preference for connection.
	// Defaults to AUTO which tries protocols in recommended order.
	ProtocolPreference graphql.Omittable[*ProtocolPreference] `json:"protocolPreference,omitempty"`
	// User-friendly display name for the router.
	// If not provided, a name will be generated from the host.
	Name graphql.Omittable[*string] `json:"name,omitempty"`
}

// Payload returned from the addRouter mutation.
// Contains either the created router or validation/connection errors.
type AddRouterPayload struct {
	// The newly created router (null if errors occurred)
	Router *Router `json:"router,omitempty"`
	// Connection test result from initial connection attempt
	ConnectionResult *ConnectionTestResult `json:"connectionResult,omitempty"`
	// Field-level validation errors for retry
	ValidationErrors []*ValidationError `json:"validationErrors,omitempty"`
	// General errors that occurred during creation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Authentication test status
type AuthStatus struct {
	// Whether authentication was tested
	Tested bool `json:"tested"`
	// Whether authentication succeeded
	Success bool `json:"success"`
	// Error message (if authentication failed)
	Error *string `json:"error,omitempty"`
	// Error code mapped to ErrorCodes (A5xx)
	ErrorCode *string `json:"errorCode,omitempty"`
}

type CancelScanPayload struct {
	// The cancelled scan task
	Task *ScanTask `json:"task,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Single capability with its support level and guidance
type CapabilityEntry struct {
	// Capability category
	Capability Capability `json:"capability"`
	// Support level
	Level CapabilityLevel `json:"level"`
	// Human-readable description of support
	Description *string `json:"description,omitempty"`
	// Actionable message if feature unavailable
	Guidance *string `json:"guidance,omitempty"`
}

// Event emitted when circuit breaker state changes
type CircuitBreakerEvent struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Previous state
	PreviousState CircuitBreakerState `json:"previousState"`
	// New state
	NewState CircuitBreakerState `json:"newState"`
	// Consecutive failures that triggered the change
	ConsecutiveFailures int `json:"consecutiveFailures"`
	// When the state changed
	Timestamp time.Time `json:"timestamp"`
}

// Circuit breaker status for a router
type CircuitBreakerStatus struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Current circuit breaker state
	State CircuitBreakerState `json:"state"`
	// Number of consecutive failures
	FailureCount int `json:"failureCount"`
	// Failure threshold before circuit opens
	FailureThreshold int `json:"failureThreshold"`
	// Seconds until auto-retry (when circuit is open)
	CooldownRemainingSeconds *int `json:"cooldownRemainingSeconds,omitempty"`
	// When the last failure occurred
	LastFailureAt *time.Time `json:"lastFailureAt,omitempty"`
	// When the last success occurred
	LastSuccessAt *time.Time `json:"lastSuccessAt,omitempty"`
}

// Progress information for configuration apply operations
type ConfigProgress struct {
	// Unique operation identifier
	OperationID string `json:"operationId"`
	// Current status of the operation
	Status ConfigApplyStatus `json:"status"`
	// Completion percentage (0-100)
	Percentage int `json:"percentage"`
	// Human-readable progress message
	Message string `json:"message"`
	// Current step number
	CurrentStep *int `json:"currentStep,omitempty"`
	// Total number of steps
	TotalSteps *int `json:"totalSteps,omitempty"`
	// Timestamp of this progress update
	Timestamp time.Time `json:"timestamp"`
}

type ConnectRouterPayload struct {
	// The router that was connected
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during connection
	Errors []*MutationError `json:"errors,omitempty"`
}

// Record of a single protocol connection attempt
type ConnectionAttempt struct {
	// Protocol that was attempted
	Protocol Protocol `json:"protocol"`
	// When the attempt started
	StartedAt time.Time `json:"startedAt"`
	// When the attempt ended
	EndedAt time.Time `json:"endedAt"`
	// Whether the attempt succeeded
	Success bool `json:"success"`
	// Error code if failed
	ErrorCode *string `json:"errorCode,omitempty"`
	// Error message if failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Error category for classification
	ErrorCategory *ErrorCategory `json:"errorCategory,omitempty"`
}

// Detailed connection status for a router
type ConnectionDetails struct {
	// Current connection state
	State ConnectionStatus `json:"state"`
	// Protocol currently in use
	Protocol *Protocol `json:"protocol,omitempty"`
	// User's preferred protocol (if set)
	PreferredProtocol *Protocol `json:"preferredProtocol,omitempty"`
	// When the connection was established
	ConnectedAt *time.Time `json:"connectedAt,omitempty"`
	// Connection uptime duration
	Uptime *Duration `json:"uptime,omitempty"`
	// When the last disconnection occurred
	DisconnectedAt *time.Time `json:"disconnectedAt,omitempty"`
	// Most recent error message
	LastError *string `json:"lastError,omitempty"`
	// When the last error occurred
	LastErrorTime *time.Time `json:"lastErrorTime,omitempty"`
	// Reason for disconnection
	DisconnectReason *DisconnectReason `json:"disconnectReason,omitempty"`
	// Number of reconnection attempts made
	ReconnectAttempts int `json:"reconnectAttempts"`
	// When the next reconnection attempt will be made
	NextReconnectAt *time.Time `json:"nextReconnectAt,omitempty"`
	// Current circuit breaker state
	CircuitBreakerState CircuitBreakerState `json:"circuitBreakerState"`
	// Router version (if connected)
	Version *string `json:"version,omitempty"`
	// When the last health check was performed
	LastHealthCheck *time.Time `json:"lastHealthCheck,omitempty"`
	// Consecutive passed health checks
	HealthChecksPassed int `json:"healthChecksPassed"`
	// Consecutive failed health checks
	HealthChecksFailed int `json:"healthChecksFailed"`
	// Security warning if using insecure protocol (e.g., Telnet)
	SecurityWarning *string `json:"securityWarning,omitempty"`
	// Recommendation for upgrading to a more secure protocol
	UpgradeRecommendation *string `json:"upgradeRecommendation,omitempty"`
	// Whether the current protocol is considered legacy/insecure
	IsLegacyProtocol bool `json:"isLegacyProtocol"`
}

// Detailed error information for connection failures.
// Used to provide actionable feedback to the user.
type ConnectionError struct {
	// Error code for programmatic handling
	Code ConnectionErrorCode `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Protocol that failed (if specific to a protocol)
	Protocol *Protocol `json:"protocol,omitempty"`
	// Whether the error is likely transient and retryable
	Retryable bool `json:"retryable"`
	// Suggested user action to resolve the error
	SuggestedAction *string `json:"suggestedAction,omitempty"`
	// Timeout in milliseconds (if timeout error)
	TimeoutMs *int `json:"timeoutMs,omitempty"`
}

// Connection manager statistics
type ConnectionStats struct {
	// Total number of connections
	TotalConnections int `json:"totalConnections"`
	// Number of connected routers
	Connected int `json:"connected"`
	// Number of connecting routers
	Connecting int `json:"connecting"`
	// Number of disconnected routers
	Disconnected int `json:"disconnected"`
	// Number of reconnecting routers
	Reconnecting int `json:"reconnecting"`
	// Number of routers in error state
	Error int `json:"error"`
}

// Result of a connection test attempt, including protocol detection results.
type ConnectionTestResult struct {
	// Whether the connection was successful
	Success bool `json:"success"`
	// Protocol that was successfully used
	ProtocolUsed *Protocol `json:"protocolUsed,omitempty"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// RouterOS version detected (if connection succeeded)
	RouterVersion *string `json:"routerVersion,omitempty"`
	// Router model detected (if connection succeeded)
	RouterModel *string `json:"routerModel,omitempty"`
	// Router board name (if connection succeeded)
	BoardName *string `json:"boardName,omitempty"`
	// Uptime of the router (if connection succeeded)
	Uptime *Duration `json:"uptime,omitempty"`
	// List of protocols that were attempted
	ProtocolsAttempted []Protocol `json:"protocolsAttempted"`
	// Whether the router supports containers
	SupportsContainers *bool `json:"supportsContainers,omitempty"`
	// Architecture of the router (arm, arm64, x86, etc.)
	Architecture *string `json:"architecture,omitempty"`
	// Error details if connection failed
	Error *ConnectionError `json:"error,omitempty"`
}

// Container-specific capability information
type ContainerInfo struct {
	// Whether container package is installed
	PackageInstalled bool `json:"packageInstalled"`
	// Whether container feature is enabled in system settings
	Enabled bool `json:"enabled"`
	// Whether a container registry is configured
	RegistryConfigured bool `json:"registryConfigured"`
	// Available storage for container images in bytes
	StorageAvailable Size `json:"storageAvailable"`
	// Whether network namespace is supported
	SupportsNetworkNamespace bool `json:"supportsNetworkNamespace"`
	// Maximum number of containers supported
	MaxContainers *int `json:"maxContainers,omitempty"`
}

// Input for creating a new router connection
type CreateRouterInput struct {
	// User-friendly display name
	Name string `json:"name"`
	// Router hostname or IP address
	Host string `json:"host"`
	// Connection port (default: 8728 for MikroTik API)
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Username for authentication
	Username string `json:"username"`
	// Password for authentication
	Password string `json:"password"`
	// Router platform type
	Platform graphql.Omittable[*RouterPlatform] `json:"platform,omitempty"`
}

type CreateRouterPayload struct {
	// The created router
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during creation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of testing a single router's credentials.
type CredentialTestResult struct {
	// Router ID that was tested
	RouterID string `json:"routerId"`
	// Router name for display
	RouterName string `json:"routerName"`
	// Whether the test was successful
	Success bool `json:"success"`
	// Connection status
	Status CredentialTestStatus `json:"status"`
	// Response time in milliseconds (if successful)
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if test failed
	Error *string `json:"error,omitempty"`
}

// Result of updating router credentials.
type CredentialUpdatePayload struct {
	// Whether the update was successful
	Success bool `json:"success"`
	// Human-readable message about the operation
	Message string `json:"message"`
	// Updated credential info (without password)
	Credentials *RouterCredentials `json:"credentials,omitempty"`
	// Error code if update failed
	ErrorCode *CredentialErrorCode `json:"errorCode,omitempty"`
	// Errors that occurred during update
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating router credentials.
// Both username and password must be provided.
type CredentialsInput struct {
	// Username for router authentication
	Username string `json:"username"`
	// Password for router authentication
	Password string `json:"password"`
}

type DeleteRouterPayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// ID of the deleted router
	DeletedRouterID *string `json:"deletedRouterId,omitempty"`
	// Errors that occurred during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

// Comprehensive diagnostic report for a router
type DiagnosticReport struct {
	// Router ID being diagnosed
	RouterID string `json:"routerId"`
	// When the diagnostic was run
	Timestamp time.Time `json:"timestamp"`
	// Whether the router is reachable on the network
	NetworkReachable bool `json:"networkReachable"`
	// Status of each checked port
	PortStatus []*PortStatus `json:"portStatus"`
	// TLS certificate status (if TLS ports were checked)
	TLSStatus *TLSStatus `json:"tlsStatus,omitempty"`
	// Authentication test status
	AuthStatus *AuthStatus `json:"authStatus"`
	// Actionable suggestions based on diagnostic results
	Suggestions []*DiagnosticSuggestion `json:"suggestions"`
	// Raw text report for clipboard/export
	RawReport string `json:"rawReport"`
}

// Actionable diagnostic suggestion
type DiagnosticSuggestion struct {
	// Severity level of the issue
	Severity SuggestionSeverity `json:"severity"`
	// Short title describing the issue
	Title string `json:"title"`
	// Detailed description of the issue
	Description string `json:"description"`
	// Recommended action to resolve the issue
	Action string `json:"action"`
	// Link to relevant documentation
	DocsURL *string `json:"docsUrl,omitempty"`
}

type DisconnectRouterPayload struct {
	// The router that was disconnected
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during disconnection
	Errors []*MutationError `json:"errors,omitempty"`
}

// A device discovered during a network scan.
// Only confirmed MikroTik devices are returned (confidence >= 40).
type DiscoveredDevice struct {
	// IP address of the discovered device
	IP string `json:"ip"`
	// Hostname (if reverse DNS resolves)
	Hostname *string `json:"hostname,omitempty"`
	// Open ports found on the device
	Ports []int `json:"ports"`
	// Device type classification
	DeviceType string `json:"deviceType"`
	// Device vendor (always 'MikroTik' for returned results)
	Vendor *string `json:"vendor,omitempty"`
	// RouterOS-specific information (version, board, architecture)
	RouterOSInfo *RouterOSInfo `json:"routerOSInfo,omitempty"`
	// Confidence score for RouterOS detection (40-100)
	Confidence int `json:"confidence"`
	// Detected services (mikrotik-api, mikrotik-winbox, mikrotik-rest, etc.)
	Services []string `json:"services"`
}

// Rich error extensions for detailed error diagnostics.
// Included in GraphQL error responses under the 'extensions' key.
type ErrorExtensions struct {
	// Error code for programmatic handling (e.g., 'V400', 'R200')
	Code string `json:"code"`
	// Error category (validation, protocol, network, auth, resource, internal)
	Category string `json:"category"`
	// Field path that caused the error (e.g., 'input.listenPort')
	Field *string `json:"field,omitempty"`
	// The invalid value (redacted in production for sensitive fields)
	Value map[string]interface{} `json:"value,omitempty"`
	// User-friendly suggestion for fixing the error
	SuggestedFix *string `json:"suggestedFix,omitempty"`
	// Link to relevant documentation
	DocsURL *string `json:"docsUrl,omitempty"`
	// Request correlation ID for support and debugging
	RequestID string `json:"requestId"`
	// Whether the error is recoverable (can be retried)
	Recoverable bool `json:"recoverable"`
	// Additional troubleshooting steps for complex errors
	TroubleshootingSteps []string `json:"troubleshootingSteps,omitempty"`
}

// Options for exporting router configuration.
type ExportConfigInput struct {
	// Router ID to export configuration from
	RouterID string `json:"routerId"`
	// Whether to include credentials (requires encryptionKey if true)
	IncludeCredentials graphql.Omittable[*bool] `json:"includeCredentials,omitempty"`
	// User-provided encryption key for credential export (required if includeCredentials is true)
	EncryptionKey graphql.Omittable[*string] `json:"encryptionKey,omitempty"`
}

// Result of exporting router configuration.
type ExportConfigPayload struct {
	// Whether the export was successful
	Success bool `json:"success"`
	// Exported configuration data (JSON format)
	Config map[string]interface{} `json:"config,omitempty"`
	// Security warning message about credential handling
	SecurityWarning *string `json:"securityWarning,omitempty"`
	// Errors that occurred during export
	Errors []*MutationError `json:"errors,omitempty"`
}

// Information about a feature in the compatibility matrix
type FeatureCompatibilityInfo struct {
	// Feature identifier
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	Name string `json:"name"`
	// Minimum RouterOS version required
	MinVersion string `json:"minVersion"`
	// Maximum RouterOS version supported (if any)
	MaxVersion *string `json:"maxVersion,omitempty"`
	// Minimum version for CHR (if different)
	MinVersionChr *string `json:"minVersionCHR,omitempty"`
	// Required packages
	RequiredPackages []string `json:"requiredPackages"`
	// Feature dependencies
	DependsOn []string `json:"dependsOn"`
	// URL to MikroTik documentation
	UpgradeURL *string `json:"upgradeUrl,omitempty"`
}

// Input for checking feature compatibility
type FeatureCompatibilityInput struct {
	// Feature identifier to check
	FeatureID string `json:"featureId"`
	// Whether to check for CHR-specific requirements
	IsChr graphql.Omittable[*bool] `json:"isCHR,omitempty"`
}

// Feature support information based on RouterOS version
type FeatureSupport struct {
	// Feature identifier (e.g., 'rest_api', 'container', 'wireguard')
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	Name string `json:"name"`
	// Whether the feature is supported on this router
	Supported bool `json:"supported"`
	// Capability level (none, basic, advanced, full)
	Level CapabilityLevel `json:"level"`
	// Reason why the feature is not supported (if applicable)
	Reason *string `json:"reason,omitempty"`
	// Minimum RouterOS version required for this feature
	RequiredVersion *string `json:"requiredVersion,omitempty"`
	// URL to MikroTik documentation for upgrade guidance
	UpgradeURL *string `json:"upgradeUrl,omitempty"`
	// Required packages that need to be installed
	RequiredPackages []string `json:"requiredPackages,omitempty"`
	// Missing packages (if any)
	MissingPackages []string `json:"missingPackages,omitempty"`
}

// Hardware information detected from router
type HardwareInfo struct {
	// CPU architecture (arm, arm64, x86_64, etc.)
	Architecture string `json:"architecture"`
	// Router model name
	Model *string `json:"model,omitempty"`
	// Board name
	BoardName *string `json:"boardName,omitempty"`
	// Total RAM in bytes
	TotalMemory Size `json:"totalMemory"`
	// Available storage in bytes
	AvailableStorage Size `json:"availableStorage"`
	// Number of CPU cores
	CPUCount int `json:"cpuCount"`
	// Whether wireless hardware is present
	HasWirelessChip bool `json:"hasWirelessChip"`
	// Whether LTE/cellular hardware is present
	HasLTEModule bool `json:"hasLTEModule"`
}

// Health check result for a router
type HealthCheckResult struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Whether the router is healthy
	Healthy bool `json:"healthy"`
	// When the check was performed
	CheckedAt time.Time `json:"checkedAt"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if unhealthy
	Error *string `json:"error,omitempty"`
}

// Overall system health status
type HealthStatus struct {
	// Service status
	Status ServiceStatus `json:"status"`
	// Service version
	Version string `json:"version"`
	// Server uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Connected router count
	ConnectedRouters int `json:"connectedRouters"`
	// Last health check timestamp
	CheckedAt time.Time `json:"checkedAt"`
}

// A network interface on a router
type Interface struct {
	// Unique interface identifier
	ID string `json:"id"`
	// Interface name (e.g., ether1, wlan1)
	Name string `json:"name"`
	// Interface type
	Type InterfaceType `json:"type"`
	// Whether the interface is enabled
	Enabled bool `json:"enabled"`
	// Whether the interface is running (link up)
	Running bool `json:"running"`
	// MAC address
	MacAddress *MAC `json:"macAddress,omitempty"`
	// MTU setting
	Mtu *int `json:"mtu,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// TX bytes
	TxBytes *Size `json:"txBytes,omitempty"`
	// RX bytes
	RxBytes *Size `json:"rxBytes,omitempty"`
}

func (Interface) IsNode() {}

type InterfaceConnection struct {
	Edges      []*InterfaceEdge `json:"edges"`
	PageInfo   *PageInfo        `json:"pageInfo"`
	TotalCount *int             `json:"totalCount,omitempty"`
}

func (InterfaceConnection) IsConnection() {}

type InterfaceEdge struct {
	Node   *Interface `json:"node"`
	Cursor string     `json:"cursor"`
}

func (InterfaceEdge) IsEdge() {}

type InterfaceTrafficEvent struct {
	// Interface ID
	InterfaceID string `json:"interfaceId"`
	// Interface name
	InterfaceName string `json:"interfaceName"`
	// TX rate in bytes per second
	TxRate Size `json:"txRate"`
	// RX rate in bytes per second
	RxRate Size `json:"rxRate"`
	// Total TX bytes
	TxTotal Size `json:"txTotal"`
	// Total RX bytes
	RxTotal Size `json:"rxTotal"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

type Mutation struct {
}

// Standard error type for mutations
type MutationError struct {
	// Error code for programmatic handling
	Code string `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Field that caused the error (if applicable)
	Field *string `json:"field,omitempty"`
}

// Information about pagination in a connection
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// Cursor for the first edge
	StartCursor *string `json:"startCursor,omitempty"`
	// Cursor for the last edge
	EndCursor *string `json:"endCursor,omitempty"`
}

// Standard pagination input arguments
type PaginationInput struct {
	// Number of items to fetch
	First graphql.Omittable[*int] `json:"first,omitempty"`
	// Cursor to fetch items after
	After graphql.Omittable[*string] `json:"after,omitempty"`
	// Number of items to fetch from the end
	Last graphql.Omittable[*int] `json:"last,omitempty"`
	// Cursor to fetch items before
	Before graphql.Omittable[*string] `json:"before,omitempty"`
}

// Status of a single port check
type PortStatus struct {
	// Port number checked
	Port int `json:"port"`
	// Service name (API, API-SSL, SSH, Telnet, HTTP, HTTPS)
	Service string `json:"service"`
	// Whether the port is open and accepting connections
	Open bool `json:"open"`
	// Response time in milliseconds (if port is open)
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message (if port is closed)
	Error *string `json:"error,omitempty"`
}

type Query struct {
}

type ReconnectRouterPayload struct {
	// The router being reconnected
	Router *Router `json:"router,omitempty"`
	// Updated connection details
	ConnectionDetails *ConnectionDetails `json:"connectionDetails,omitempty"`
	// Whether reconnection was initiated
	Initiated bool `json:"initiated"`
	// Rate limit wait time if rate limited
	WaitTimeMs *int `json:"waitTimeMs,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Payload for refreshCapabilities mutation
type RefreshCapabilitiesPayload struct {
	// Updated capabilities after refresh
	Capabilities *RouterCapabilities `json:"capabilities,omitempty"`
	// Errors during refresh
	Errors []*MutationError `json:"errors,omitempty"`
}

// Event emitted when a router resource is updated
type ResourceUpdatedEvent struct {
	// Unique resource identifier
	ResourceID string `json:"resourceId"`
	// Type of resource (interface, firewall-rule, dhcp-lease, etc.)
	ResourceType string `json:"resourceType"`
	// Router this resource belongs to
	RouterID string `json:"routerId"`
	// New version number after update
	Version int `json:"version"`
	// Fields that were changed
	ChangedFields []string `json:"changedFields"`
	// Type of change (create, update, delete)
	ChangeType ChangeType `json:"changeType"`
	// Timestamp of the update
	Timestamp time.Time `json:"timestamp"`
}

// A managed router device
type Router struct {
	// Unique router identifier
	ID string `json:"id"`
	// User-friendly display name
	Name string `json:"name"`
	// Router hostname or IP address
	Host string `json:"host"`
	// Connection port
	Port int `json:"port"`
	// Current connection status
	Status ConnectionStatus `json:"status"`
	// Router platform type
	Platform RouterPlatform `json:"platform"`
	// RouterOS version (if connected)
	Version *string `json:"version,omitempty"`
	// Router model
	Model *string `json:"model,omitempty"`
	// System uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Last successful connection time
	LastConnected *time.Time `json:"lastConnected,omitempty"`
	// When the router was added to NasNet
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// Detected router capabilities (requires connection)
	Capabilities *RouterCapabilities `json:"capabilities,omitempty"`
}

func (Router) IsNode() {}

// Event emitted when a new router is added.
type RouterAddedEvent struct {
	// The newly added router
	Router *Router `json:"router"`
	// Protocol used for initial connection
	ProtocolUsed Protocol `json:"protocolUsed"`
	// User who added the router (if authenticated)
	AddedBy *string `json:"addedBy,omitempty"`
	// Timestamp of addition
	Timestamp time.Time `json:"timestamp"`
}

// Complete router capabilities detected from system inspection
type RouterCapabilities struct {
	// Hardware information
	Hardware *HardwareInfo `json:"hardware"`
	// Software information
	Software *SoftwareInfo `json:"software"`
	// Container-specific capabilities
	Container *ContainerInfo `json:"container"`
	// Capability entries with support levels
	Capabilities []*CapabilityEntry `json:"capabilities"`
	// VIF requirements check
	VifRequirements *VIFRequirements `json:"vifRequirements"`
	// Features supported by this router's version and configuration
	SupportedFeatures []*FeatureSupport `json:"supportedFeatures"`
	// Features not supported by this router (with upgrade guidance)
	UnsupportedFeatures []*FeatureSupport `json:"unsupportedFeatures"`
	// Parsed RouterOS version with comparison helpers
	RouterOSVersion *RouterOSVersion `json:"routerOSVersion"`
	// When capabilities were detected
	DetectedAt time.Time `json:"detectedAt"`
	// When cache expires (24h TTL)
	ExpiresAt time.Time `json:"expiresAt"`
	// Whether cache is stale and refresh is in progress
	IsRefreshing bool `json:"isRefreshing"`
}

type RouterConnection struct {
	Edges      []*RouterEdge `json:"edges"`
	PageInfo   *PageInfo     `json:"pageInfo"`
	TotalCount *int          `json:"totalCount,omitempty"`
}

func (RouterConnection) IsConnection() {}

// Router credential information (non-sensitive).
// Password is never included - only metadata about credentials.
type RouterCredentials struct {
	// Router ID these credentials belong to
	RouterID string `json:"routerId"`
	// Username for router authentication
	Username string `json:"username"`
	// Whether a password is stored
	HasPassword bool `json:"hasPassword"`
	// Encryption algorithm used (always 'AES-256-GCM')
	EncryptionStatus string `json:"encryptionStatus"`
	// Encryption key version (for rotation tracking)
	KeyVersion int `json:"keyVersion"`
	// When credentials were last updated
	LastUpdated time.Time `json:"lastUpdated"`
	// When credentials were first created
	CreatedAt time.Time `json:"createdAt"`
}

type RouterEdge struct {
	Node   *Router `json:"node"`
	Cursor string  `json:"cursor"`
}

func (RouterEdge) IsEdge() {}

// Information about a discovered RouterOS device
type RouterOSInfo struct {
	// RouterOS version string (e.g., '7.12', '6.49.8')
	Version *string `json:"version,omitempty"`
	// Router board name (e.g., 'hAP acÂ³', 'CCR2004-1G-12S+2XS')
	BoardName *string `json:"boardName,omitempty"`
	// CPU architecture (e.g., 'arm', 'x86', 'mips')
	Architecture *string `json:"architecture,omitempty"`
	// Platform identifier
	Platform *string `json:"platform,omitempty"`
}

// Parsed RouterOS version with semantic versioning
type RouterOSVersion struct {
	// Full version string (e.g., '7.13.2')
	Raw string `json:"raw"`
	// Major version number
	Major int `json:"major"`
	// Minor version number
	Minor int `json:"minor"`
	// Patch version number
	Patch int `json:"patch"`
	// Version channel (stable, beta, rc, long-term)
	Channel *string `json:"channel,omitempty"`
	// Whether this is a Cloud Hosted Router (CHR)
	IsChr bool `json:"isCHR"`
	// Check if this version supports a specific feature
	SupportsFeature bool `json:"supportsFeature"`
	// Check if version is at least the given version (e.g., '7.1')
	IsAtLeast bool `json:"isAtLeast"`
}

type RouterStatusEvent struct {
	// The router whose status changed
	Router *Router `json:"router"`
	// Previous status
	PreviousStatus ConnectionStatus `json:"previousStatus"`
	// New status
	NewStatus ConnectionStatus `json:"newStatus"`
	// Timestamp of the change
	Timestamp time.Time `json:"timestamp"`
}

// Input for starting a network scan
type ScanNetworkInput struct {
	// Target subnet in CIDR notation (e.g., '192.168.88.0/24') or IP range (e.g., '192.168.1.1-192.168.1.100')
	Subnet string `json:"subnet"`
}

type ScanNetworkPayload struct {
	// The created scan task
	Task *ScanTask `json:"task,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Real-time progress event for scan subscriptions
type ScanProgressEvent struct {
	// Task ID this event belongs to
	TaskID string `json:"taskId"`
	// Current progress percentage (0-100)
	Progress int `json:"progress"`
	// Number of MikroTik devices found so far
	DevicesFound int `json:"devicesFound"`
	// IP address currently being scanned
	CurrentIP *string `json:"currentIP,omitempty"`
	// Current scan status
	Status ScanStatus `json:"status"`
	// Timestamp of this progress update
	Timestamp time.Time `json:"timestamp"`
}

// A network scan task that tracks scan progress and results.
// Scans are asynchronous - start with mutation, poll/subscribe for progress.
type ScanTask struct {
	// Unique task identifier
	ID string `json:"id"`
	// Target subnet (CIDR notation, IP range, or gateway scan indicator)
	Subnet string `json:"subnet"`
	// Current scan status
	Status ScanStatus `json:"status"`
	// Scan progress percentage (0-100)
	Progress int `json:"progress"`
	// Discovered devices (populated as scan progresses)
	Results []*DiscoveredDevice `json:"results"`
	// When the scan was started
	StartTime time.Time `json:"startTime"`
	// When the scan completed (null if still running)
	EndTime *time.Time `json:"endTime,omitempty"`
	// Error message if scan failed
	Error *string `json:"error,omitempty"`
	// Total IPs to scan (for progress calculation)
	TotalIPs *int `json:"totalIPs,omitempty"`
	// Number of IPs scanned so far
	ScannedIPs *int `json:"scannedIPs,omitempty"`
}

type SetPreferredProtocolPayload struct {
	// The updated router
	Router *Router `json:"router,omitempty"`
	// Updated connection details
	ConnectionDetails *ConnectionDetails `json:"connectionDetails,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Software information detected from router
type SoftwareInfo struct {
	// RouterOS version string
	Version string `json:"version"`
	// Parsed major version number
	VersionMajor int `json:"versionMajor"`
	// Parsed minor version number
	VersionMinor int `json:"versionMinor"`
	// Parsed patch version number
	VersionPatch *int `json:"versionPatch,omitempty"`
	// List of installed packages
	InstalledPackages []string `json:"installedPackages"`
	// License level (0-6)
	LicenseLevel int `json:"licenseLevel"`
	// Update channel (stable, testing, development)
	UpdateChannel *string `json:"updateChannel,omitempty"`
}

type Subscription struct {
}

// TLS certificate status for secure connections
type TLSStatus struct {
	// Whether the certificate is valid
	Valid bool `json:"valid"`
	// Certificate issuer
	Issuer *string `json:"issuer,omitempty"`
	// Certificate subject
	Subject *string `json:"subject,omitempty"`
	// Certificate expiration date
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// Error message (if certificate is invalid)
	Error *string `json:"error,omitempty"`
}

// Result of testing all router credentials.
type TestAllCredentialsPayload struct {
	// Total number of routers tested
	TotalRouters int `json:"totalRouters"`
	// Number of successful credential tests
	SuccessCount int `json:"successCount"`
	// Number of failed credential tests
	FailureCount int `json:"failureCount"`
	// Per-router test results
	Results []*CredentialTestResult `json:"results"`
}

type TestConnectionPayload struct {
	// Whether the connection test succeeded
	Success bool `json:"success"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Router version if connection succeeded
	Version *string `json:"version,omitempty"`
	// Error message if connection failed
	Error *string `json:"error,omitempty"`
}

// Input for updating router settings
type UpdateRouterInput struct {
	// Updated display name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Updated hostname or IP address
	Host graphql.Omittable[*string] `json:"host,omitempty"`
	// Updated connection port
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Updated username
	Username graphql.Omittable[*string] `json:"username,omitempty"`
	// Updated password
	Password graphql.Omittable[*string] `json:"password,omitempty"`
}

type UpdateRouterPayload struct {
	// The updated router
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during update
	Errors []*MutationError `json:"errors,omitempty"`
}

// Impact assessment for an upgrade
type UpgradeImpact struct {
	// Whether reboot is required
	RequiresReboot bool `json:"requiresReboot"`
	// Estimated downtime description
	EstimatedDowntime *string `json:"estimatedDowntime,omitempty"`
	// Whether configuration backup is recommended before upgrade
	BackupRecommended bool `json:"backupRecommended"`
	// Potential breaking changes to be aware of
	BreakingChanges []string `json:"breakingChanges"`
}

// Upgrade recommendation for enabling a feature
type UpgradeRecommendation struct {
	// Feature that requires upgrade
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	FeatureName string `json:"featureName"`
	// Current RouterOS version
	CurrentVersion string `json:"currentVersion"`
	// Minimum required version for this feature
	RequiredVersion string `json:"requiredVersion"`
	// Whether this is a major version upgrade (e.g., 6.x to 7.x)
	IsMajorUpgrade bool `json:"isMajorUpgrade"`
	// Priority level (critical, high, medium, low)
	Priority UpgradePriority `json:"priority"`
	// Steps to complete the upgrade
	Steps []*UpgradeStep `json:"steps"`
	// Estimated impact on router operation
	Impact *UpgradeImpact `json:"impact"`
	// URL to MikroTik upgrade documentation
	DocumentationURL *string `json:"documentationUrl,omitempty"`
	// Warnings or important notes about this upgrade
	Warnings []string `json:"warnings"`
}

// Single step in an upgrade process
type UpgradeStep struct {
	// Step number (1-based)
	Step int `json:"step"`
	// Step title
	Title string `json:"title"`
	// Detailed instructions
	Description string `json:"description"`
	// RouterOS command to execute (if applicable)
	Command *string `json:"command,omitempty"`
	// Whether this step is optional
	Optional bool `json:"optional"`
}

// Single step in VIF enablement guidance
type VIFGuidanceStep struct {
	// Step number (1-based)
	Step int `json:"step"`
	// Short title for the step
	Title string `json:"title"`
	// Detailed instruction
	Description string `json:"description"`
	// Whether this requirement is already met
	Completed bool `json:"completed"`
	// RouterOS command to execute (if applicable)
	RouterCommand *string `json:"routerCommand,omitempty"`
}

// VIF (Virtual Interface Factory) requirements check result
type VIFRequirements struct {
	// Whether all VIF requirements are satisfied
	Met bool `json:"met"`
	// Whether RouterOS version is sufficient (7.13+)
	RouterOSVersion bool `json:"routerOSVersion"`
	// Whether container package is installed
	ContainerPackage bool `json:"containerPackage"`
	// Whether container feature is enabled
	ContainerEnabled bool `json:"containerEnabled"`
	// Whether there's sufficient storage (>100MB)
	SufficientStorage bool `json:"sufficientStorage"`
	// Whether network namespace is supported
	NetworkNamespace bool `json:"networkNamespace"`
	// Human-readable reasons why VIF is not available
	MissingReasons []string `json:"missingReasons"`
	// Step-by-step guidance for enabling VIF
	GuidanceSteps []*VIFGuidanceStep `json:"guidanceSteps"`
}

// Field-level validation error with suggestions for fixing.
type ValidationError struct {
	// Field path that failed validation (e.g., 'input.host', 'input.port')
	Field string `json:"field"`
	// Error code for the validation failure
	Code string `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Suggestion for fixing the validation error
	Suggestion *string `json:"suggestion,omitempty"`
	// The invalid value (redacted for sensitive fields)
	ProvidedValue *string `json:"providedValue,omitempty"`
}

type CacheScope string

const (
	CacheScopePrivate CacheScope = "PRIVATE"
	CacheScopePublic  CacheScope = "PUBLIC"
)

var AllCacheScope = []CacheScope{
	CacheScopePrivate,
	CacheScopePublic,
}

func (e CacheScope) IsValid() bool {
	switch e {
	case CacheScopePrivate, CacheScopePublic:
		return true
	}
	return false
}

func (e CacheScope) String() string {
	return string(e)
}

func (e *CacheScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CacheScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CacheScope", str)
	}
	return nil
}

func (e CacheScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Feature capability categories detected on routers.
// Used to determine what features are available on a specific router.
type Capability string

const (
	// Container/Docker support
	CapabilityContainer Capability = "CONTAINER"
	// Virtual Interface Factory support
	CapabilityVif Capability = "VIF"
	// Wireless/WiFi support
	CapabilityWireless Capability = "WIRELESS"
	// Advanced routing features
	CapabilityRouting Capability = "ROUTING"
	// Firewall features
	CapabilityFirewall Capability = "FIREWALL"
	// MPLS support
	CapabilityMpls Capability = "MPLS"
	// IPv6 support
	CapabilityIPV6 Capability = "IPV6"
	// Hotspot features
	CapabilityHotspot Capability = "HOTSPOT"
	// User Manager features
	CapabilityUserManager Capability = "USER_MANAGER"
	// Dude monitoring support
	CapabilityDude Capability = "DUDE"
	// WireGuard VPN support
	CapabilityWireguard Capability = "WIREGUARD"
	// ZeroTier support
	CapabilityZerotier Capability = "ZEROTIER"
)

var AllCapability = []Capability{
	CapabilityContainer,
	CapabilityVif,
	CapabilityWireless,
	CapabilityRouting,
	CapabilityFirewall,
	CapabilityMpls,
	CapabilityIPV6,
	CapabilityHotspot,
	CapabilityUserManager,
	CapabilityDude,
	CapabilityWireguard,
	CapabilityZerotier,
}

func (e Capability) IsValid() bool {
	switch e {
	case CapabilityContainer, CapabilityVif, CapabilityWireless, CapabilityRouting, CapabilityFirewall, CapabilityMpls, CapabilityIPV6, CapabilityHotspot, CapabilityUserManager, CapabilityDude, CapabilityWireguard, CapabilityZerotier:
		return true
	}
	return false
}

func (e Capability) String() string {
	return string(e)
}

func (e *Capability) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Capability(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Capability", str)
	}
	return nil
}

func (e Capability) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Capability support level for a feature.
// Determines how the feature appears in the UI.
type CapabilityLevel string

const (
	// Feature not supported (hide in UI)
	CapabilityLevelNone CapabilityLevel = "NONE"
	// Limited support (show with warnings)
	CapabilityLevelBasic CapabilityLevel = "BASIC"
	// Full RouterOS native support
	CapabilityLevelAdvanced CapabilityLevel = "ADVANCED"
	// Complete support including container-based features
	CapabilityLevelFull CapabilityLevel = "FULL"
)

var AllCapabilityLevel = []CapabilityLevel{
	CapabilityLevelNone,
	CapabilityLevelBasic,
	CapabilityLevelAdvanced,
	CapabilityLevelFull,
}

func (e CapabilityLevel) IsValid() bool {
	switch e {
	case CapabilityLevelNone, CapabilityLevelBasic, CapabilityLevelAdvanced, CapabilityLevelFull:
		return true
	}
	return false
}

func (e CapabilityLevel) String() string {
	return string(e)
}

func (e *CapabilityLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CapabilityLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CapabilityLevel", str)
	}
	return nil
}

func (e CapabilityLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of change for resource events
type ChangeType string

const (
	ChangeTypeCreate ChangeType = "CREATE"
	ChangeTypeUpdate ChangeType = "UPDATE"
	ChangeTypeDelete ChangeType = "DELETE"
)

var AllChangeType = []ChangeType{
	ChangeTypeCreate,
	ChangeTypeUpdate,
	ChangeTypeDelete,
}

func (e ChangeType) IsValid() bool {
	switch e {
	case ChangeTypeCreate, ChangeTypeUpdate, ChangeTypeDelete:
		return true
	}
	return false
}

func (e ChangeType) String() string {
	return string(e)
}

func (e *ChangeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeType", str)
	}
	return nil
}

func (e ChangeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Circuit breaker state
type CircuitBreakerState string

const (
	// Circuit is closed (normal operation)
	CircuitBreakerStateClosed CircuitBreakerState = "CLOSED"
	// Circuit is open (blocking requests)
	CircuitBreakerStateOpen CircuitBreakerState = "OPEN"
	// Circuit is half-open (testing recovery)
	CircuitBreakerStateHalfOpen CircuitBreakerState = "HALF_OPEN"
)

var AllCircuitBreakerState = []CircuitBreakerState{
	CircuitBreakerStateClosed,
	CircuitBreakerStateOpen,
	CircuitBreakerStateHalfOpen,
}

func (e CircuitBreakerState) IsValid() bool {
	switch e {
	case CircuitBreakerStateClosed, CircuitBreakerStateOpen, CircuitBreakerStateHalfOpen:
		return true
	}
	return false
}

func (e CircuitBreakerState) String() string {
	return string(e)
}

func (e *CircuitBreakerState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CircuitBreakerState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CircuitBreakerState", str)
	}
	return nil
}

func (e CircuitBreakerState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a configuration apply operation
type ConfigApplyStatus string

const (
	ConfigApplyStatusPending    ConfigApplyStatus = "PENDING"
	ConfigApplyStatusValidating ConfigApplyStatus = "VALIDATING"
	ConfigApplyStatusApplying   ConfigApplyStatus = "APPLYING"
	ConfigApplyStatusVerifying  ConfigApplyStatus = "VERIFYING"
	ConfigApplyStatusCompleted  ConfigApplyStatus = "COMPLETED"
	ConfigApplyStatusFailed     ConfigApplyStatus = "FAILED"
	ConfigApplyStatusRolledBack ConfigApplyStatus = "ROLLED_BACK"
)

var AllConfigApplyStatus = []ConfigApplyStatus{
	ConfigApplyStatusPending,
	ConfigApplyStatusValidating,
	ConfigApplyStatusApplying,
	ConfigApplyStatusVerifying,
	ConfigApplyStatusCompleted,
	ConfigApplyStatusFailed,
	ConfigApplyStatusRolledBack,
}

func (e ConfigApplyStatus) IsValid() bool {
	switch e {
	case ConfigApplyStatusPending, ConfigApplyStatusValidating, ConfigApplyStatusApplying, ConfigApplyStatusVerifying, ConfigApplyStatusCompleted, ConfigApplyStatusFailed, ConfigApplyStatusRolledBack:
		return true
	}
	return false
}

func (e ConfigApplyStatus) String() string {
	return string(e)
}

func (e *ConfigApplyStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfigApplyStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfigApplyStatus", str)
	}
	return nil
}

func (e ConfigApplyStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error codes for connection failures.
// Each code has specific meaning and recovery suggestions.
type ConnectionErrorCode string

const (
	// Authentication failed - invalid username or password
	ConnectionErrorCodeAuthFailed ConnectionErrorCode = "AUTH_FAILED"
	// Network unreachable - cannot reach the host
	ConnectionErrorCodeNetworkUnreachable ConnectionErrorCode = "NETWORK_UNREACHABLE"
	// Connection refused - port is closed or blocked
	ConnectionErrorCodeConnectionRefused ConnectionErrorCode = "CONNECTION_REFUSED"
	// No compatible protocol found after trying all options
	ConnectionErrorCodeProtocolMismatch ConnectionErrorCode = "PROTOCOL_MISMATCH"
	// Connection or response timed out
	ConnectionErrorCodeTimeout ConnectionErrorCode = "TIMEOUT"
	// DNS resolution failed for hostname
	ConnectionErrorCodeDNSFailed ConnectionErrorCode = "DNS_FAILED"
	// Router with same host/port already exists
	ConnectionErrorCodeDuplicateRouter ConnectionErrorCode = "DUPLICATE_ROUTER"
	// TLS/SSL handshake failed
	ConnectionErrorCodeTLSError ConnectionErrorCode = "TLS_ERROR"
	// Router responded but is not a MikroTik device
	ConnectionErrorCodeNotMikrotik ConnectionErrorCode = "NOT_MIKROTIK"
	// Unknown or unexpected error
	ConnectionErrorCodeUnknown ConnectionErrorCode = "UNKNOWN"
)

var AllConnectionErrorCode = []ConnectionErrorCode{
	ConnectionErrorCodeAuthFailed,
	ConnectionErrorCodeNetworkUnreachable,
	ConnectionErrorCodeConnectionRefused,
	ConnectionErrorCodeProtocolMismatch,
	ConnectionErrorCodeTimeout,
	ConnectionErrorCodeDNSFailed,
	ConnectionErrorCodeDuplicateRouter,
	ConnectionErrorCodeTLSError,
	ConnectionErrorCodeNotMikrotik,
	ConnectionErrorCodeUnknown,
}

func (e ConnectionErrorCode) IsValid() bool {
	switch e {
	case ConnectionErrorCodeAuthFailed, ConnectionErrorCodeNetworkUnreachable, ConnectionErrorCodeConnectionRefused, ConnectionErrorCodeProtocolMismatch, ConnectionErrorCodeTimeout, ConnectionErrorCodeDNSFailed, ConnectionErrorCodeDuplicateRouter, ConnectionErrorCodeTLSError, ConnectionErrorCodeNotMikrotik, ConnectionErrorCodeUnknown:
		return true
	}
	return false
}

func (e ConnectionErrorCode) String() string {
	return string(e)
}

func (e *ConnectionErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionErrorCode", str)
	}
	return nil
}

func (e ConnectionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Router connection status
type ConnectionStatus string

const (
	// Actively connected and responsive
	ConnectionStatusConnected ConnectionStatus = "CONNECTED"
	// Connection attempt in progress
	ConnectionStatusConnecting ConnectionStatus = "CONNECTING"
	// Not connected
	ConnectionStatusDisconnected ConnectionStatus = "DISCONNECTED"
	// Connection failed with error
	ConnectionStatusError ConnectionStatus = "ERROR"
)

var AllConnectionStatus = []ConnectionStatus{
	ConnectionStatusConnected,
	ConnectionStatusConnecting,
	ConnectionStatusDisconnected,
	ConnectionStatusError,
}

func (e ConnectionStatus) IsValid() bool {
	switch e {
	case ConnectionStatusConnected, ConnectionStatusConnecting, ConnectionStatusDisconnected, ConnectionStatusError:
		return true
	}
	return false
}

func (e ConnectionStatus) String() string {
	return string(e)
}

func (e *ConnectionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionStatus", str)
	}
	return nil
}

func (e ConnectionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error codes specific to credential operations.
type CredentialErrorCode string

const (
	// Authentication failed with new credentials
	CredentialErrorCodeAuthFailed CredentialErrorCode = "AUTH_FAILED"
	// Connection timed out when testing credentials
	CredentialErrorCodeTimeout CredentialErrorCode = "TIMEOUT"
	// Connection was refused
	CredentialErrorCodeConnectionRefused CredentialErrorCode = "CONNECTION_REFUSED"
	// Router not found
	CredentialErrorCodeRouterNotFound CredentialErrorCode = "ROUTER_NOT_FOUND"
	// Credentials not found for router
	CredentialErrorCodeCredentialsNotFound CredentialErrorCode = "CREDENTIALS_NOT_FOUND"
	// Encryption failed
	CredentialErrorCodeEncryptionFailed CredentialErrorCode = "ENCRYPTION_FAILED"
	// Decryption failed (key may have rotated)
	CredentialErrorCodeDecryptionFailed CredentialErrorCode = "DECRYPTION_FAILED"
	// Invalid input provided
	CredentialErrorCodeInvalidInput CredentialErrorCode = "INVALID_INPUT"
)

var AllCredentialErrorCode = []CredentialErrorCode{
	CredentialErrorCodeAuthFailed,
	CredentialErrorCodeTimeout,
	CredentialErrorCodeConnectionRefused,
	CredentialErrorCodeRouterNotFound,
	CredentialErrorCodeCredentialsNotFound,
	CredentialErrorCodeEncryptionFailed,
	CredentialErrorCodeDecryptionFailed,
	CredentialErrorCodeInvalidInput,
}

func (e CredentialErrorCode) IsValid() bool {
	switch e {
	case CredentialErrorCodeAuthFailed, CredentialErrorCodeTimeout, CredentialErrorCodeConnectionRefused, CredentialErrorCodeRouterNotFound, CredentialErrorCodeCredentialsNotFound, CredentialErrorCodeEncryptionFailed, CredentialErrorCodeDecryptionFailed, CredentialErrorCodeInvalidInput:
		return true
	}
	return false
}

func (e CredentialErrorCode) String() string {
	return string(e)
}

func (e *CredentialErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CredentialErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CredentialErrorCode", str)
	}
	return nil
}

func (e CredentialErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a credential test.
type CredentialTestStatus string

const (
	// Credentials are valid and connection succeeded
	CredentialTestStatusSuccess CredentialTestStatus = "SUCCESS"
	// Authentication failed
	CredentialTestStatusAuthFailed CredentialTestStatus = "AUTH_FAILED"
	// Connection timed out
	CredentialTestStatusTimeout CredentialTestStatus = "TIMEOUT"
	// Connection was refused
	CredentialTestStatusConnectionRefused CredentialTestStatus = "CONNECTION_REFUSED"
	// Network unreachable
	CredentialTestStatusNetworkError CredentialTestStatus = "NETWORK_ERROR"
	// No credentials stored for this router
	CredentialTestStatusNoCredentials CredentialTestStatus = "NO_CREDENTIALS"
	// Unknown error occurred
	CredentialTestStatusError CredentialTestStatus = "ERROR"
)

var AllCredentialTestStatus = []CredentialTestStatus{
	CredentialTestStatusSuccess,
	CredentialTestStatusAuthFailed,
	CredentialTestStatusTimeout,
	CredentialTestStatusConnectionRefused,
	CredentialTestStatusNetworkError,
	CredentialTestStatusNoCredentials,
	CredentialTestStatusError,
}

func (e CredentialTestStatus) IsValid() bool {
	switch e {
	case CredentialTestStatusSuccess, CredentialTestStatusAuthFailed, CredentialTestStatusTimeout, CredentialTestStatusConnectionRefused, CredentialTestStatusNetworkError, CredentialTestStatusNoCredentials, CredentialTestStatusError:
		return true
	}
	return false
}

func (e CredentialTestStatus) String() string {
	return string(e)
}

func (e *CredentialTestStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CredentialTestStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CredentialTestStatus", str)
	}
	return nil
}

func (e CredentialTestStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for router disconnection
type DisconnectReason string

const (
	// Unknown reason
	DisconnectReasonUnknown DisconnectReason = "UNKNOWN"
	// User manually disconnected
	DisconnectReasonManual DisconnectReason = "MANUAL"
	// Network failure
	DisconnectReasonNetworkFailure DisconnectReason = "NETWORK_FAILURE"
	// Authentication failed
	DisconnectReasonAuthFailure DisconnectReason = "AUTH_FAILURE"
	// Connection timed out
	DisconnectReasonTimeout DisconnectReason = "TIMEOUT"
	// Circuit breaker is open
	DisconnectReasonCircuitOpen DisconnectReason = "CIRCUIT_OPEN"
	// Application shutting down
	DisconnectReasonShutdown DisconnectReason = "SHUTDOWN"
)

var AllDisconnectReason = []DisconnectReason{
	DisconnectReasonUnknown,
	DisconnectReasonManual,
	DisconnectReasonNetworkFailure,
	DisconnectReasonAuthFailure,
	DisconnectReasonTimeout,
	DisconnectReasonCircuitOpen,
	DisconnectReasonShutdown,
}

func (e DisconnectReason) IsValid() bool {
	switch e {
	case DisconnectReasonUnknown, DisconnectReasonManual, DisconnectReasonNetworkFailure, DisconnectReasonAuthFailure, DisconnectReasonTimeout, DisconnectReasonCircuitOpen, DisconnectReasonShutdown:
		return true
	}
	return false
}

func (e DisconnectReason) String() string {
	return string(e)
}

func (e *DisconnectReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DisconnectReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DisconnectReason", str)
	}
	return nil
}

func (e DisconnectReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Category of connection error for classification
type ErrorCategory string

const (
	// Connection or response timeout
	ErrorCategoryTimeout ErrorCategory = "TIMEOUT"
	// Connection actively refused
	ErrorCategoryRefused ErrorCategory = "REFUSED"
	// Authentication failed
	ErrorCategoryAuthFailed ErrorCategory = "AUTH_FAILED"
	// Protocol-level error
	ErrorCategoryProtocolError ErrorCategory = "PROTOCOL_ERROR"
	// Network unreachable or DNS failure
	ErrorCategoryNetworkError ErrorCategory = "NETWORK_ERROR"
	// TLS/SSL certificate or handshake error
	ErrorCategoryTLSError ErrorCategory = "TLS_ERROR"
)

var AllErrorCategory = []ErrorCategory{
	ErrorCategoryTimeout,
	ErrorCategoryRefused,
	ErrorCategoryAuthFailed,
	ErrorCategoryProtocolError,
	ErrorCategoryNetworkError,
	ErrorCategoryTLSError,
}

func (e ErrorCategory) IsValid() bool {
	switch e {
	case ErrorCategoryTimeout, ErrorCategoryRefused, ErrorCategoryAuthFailed, ErrorCategoryProtocolError, ErrorCategoryNetworkError, ErrorCategoryTLSError:
		return true
	}
	return false
}

func (e ErrorCategory) String() string {
	return string(e)
}

func (e *ErrorCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorCategory", str)
	}
	return nil
}

func (e ErrorCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of network interfaces
type InterfaceType string

const (
	InterfaceTypeEthernet InterfaceType = "ETHERNET"
	InterfaceTypeVlan     InterfaceType = "VLAN"
	InterfaceTypeBridge   InterfaceType = "BRIDGE"
	InterfaceTypeWireless InterfaceType = "WIRELESS"
	InterfaceTypeTunnel   InterfaceType = "TUNNEL"
	InterfaceTypePpp      InterfaceType = "PPP"
	InterfaceTypeBonding  InterfaceType = "BONDING"
	InterfaceTypeLoopback InterfaceType = "LOOPBACK"
	InterfaceTypeVirtual  InterfaceType = "VIRTUAL"
	InterfaceTypeOther    InterfaceType = "OTHER"
)

var AllInterfaceType = []InterfaceType{
	InterfaceTypeEthernet,
	InterfaceTypeVlan,
	InterfaceTypeBridge,
	InterfaceTypeWireless,
	InterfaceTypeTunnel,
	InterfaceTypePpp,
	InterfaceTypeBonding,
	InterfaceTypeLoopback,
	InterfaceTypeVirtual,
	InterfaceTypeOther,
}

func (e InterfaceType) IsValid() bool {
	switch e {
	case InterfaceTypeEthernet, InterfaceTypeVlan, InterfaceTypeBridge, InterfaceTypeWireless, InterfaceTypeTunnel, InterfaceTypePpp, InterfaceTypeBonding, InterfaceTypeLoopback, InterfaceTypeVirtual, InterfaceTypeOther:
		return true
	}
	return false
}

func (e InterfaceType) String() string {
	return string(e)
}

func (e *InterfaceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfaceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InterfaceType", str)
	}
	return nil
}

func (e InterfaceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Protocol used for router communication
type Protocol string

const (
	// REST API protocol (RouterOS 7.1+)
	ProtocolRest Protocol = "REST"
	// Binary API protocol (port 8728)
	ProtocolAPI Protocol = "API"
	// TLS-encrypted binary API (port 8729)
	ProtocolAPISsl Protocol = "API_SSL"
	// SSH protocol (port 22)
	ProtocolSSH Protocol = "SSH"
	// Telnet protocol (port 23)
	ProtocolTelnet Protocol = "TELNET"
)

var AllProtocol = []Protocol{
	ProtocolRest,
	ProtocolAPI,
	ProtocolAPISsl,
	ProtocolSSH,
	ProtocolTelnet,
}

func (e Protocol) IsValid() bool {
	switch e {
	case ProtocolRest, ProtocolAPI, ProtocolAPISsl, ProtocolSSH, ProtocolTelnet:
		return true
	}
	return false
}

func (e Protocol) String() string {
	return string(e)
}

func (e *Protocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Protocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Protocol", str)
	}
	return nil
}

func (e Protocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// User preference for which protocol to use when connecting to a router.
// AUTO will try protocols in the recommended fallback order.
type ProtocolPreference string

const (
	// Automatically detect best protocol (REST -> API -> API_SSL -> SSH -> Telnet)
	ProtocolPreferenceAuto ProtocolPreference = "AUTO"
	// Force REST API protocol (RouterOS 7.1+)
	ProtocolPreferenceRest ProtocolPreference = "REST"
	// Force Binary API protocol (port 8728)
	ProtocolPreferenceAPI ProtocolPreference = "API"
	// Force TLS-encrypted binary API (port 8729)
	ProtocolPreferenceAPISsl ProtocolPreference = "API_SSL"
	// Force SSH protocol (port 22)
	ProtocolPreferenceSSH ProtocolPreference = "SSH"
	// Force Telnet protocol (port 23, insecure - use only as last resort)
	ProtocolPreferenceTelnet ProtocolPreference = "TELNET"
)

var AllProtocolPreference = []ProtocolPreference{
	ProtocolPreferenceAuto,
	ProtocolPreferenceRest,
	ProtocolPreferenceAPI,
	ProtocolPreferenceAPISsl,
	ProtocolPreferenceSSH,
	ProtocolPreferenceTelnet,
}

func (e ProtocolPreference) IsValid() bool {
	switch e {
	case ProtocolPreferenceAuto, ProtocolPreferenceRest, ProtocolPreferenceAPI, ProtocolPreferenceAPISsl, ProtocolPreferenceSSH, ProtocolPreferenceTelnet:
		return true
	}
	return false
}

func (e ProtocolPreference) String() string {
	return string(e)
}

func (e *ProtocolPreference) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProtocolPreference(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProtocolPreference", str)
	}
	return nil
}

func (e ProtocolPreference) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported router platforms
type RouterPlatform string

const (
	// MikroTik RouterOS
	RouterPlatformMikrotik RouterPlatform = "MIKROTIK"
	// OpenWrt
	RouterPlatformOpenwrt RouterPlatform = "OPENWRT"
	// VyOS
	RouterPlatformVyos RouterPlatform = "VYOS"
	// Generic/Unknown
	RouterPlatformGeneric RouterPlatform = "GENERIC"
)

var AllRouterPlatform = []RouterPlatform{
	RouterPlatformMikrotik,
	RouterPlatformOpenwrt,
	RouterPlatformVyos,
	RouterPlatformGeneric,
}

func (e RouterPlatform) IsValid() bool {
	switch e {
	case RouterPlatformMikrotik, RouterPlatformOpenwrt, RouterPlatformVyos, RouterPlatformGeneric:
		return true
	}
	return false
}

func (e RouterPlatform) String() string {
	return string(e)
}

func (e *RouterPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RouterPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RouterPlatform", str)
	}
	return nil
}

func (e RouterPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a network scan operation
type ScanStatus string

const (
	// Scan is queued and waiting to start
	ScanStatusPending ScanStatus = "PENDING"
	// Scan is actively running
	ScanStatusRunning ScanStatus = "RUNNING"
	// Scan completed successfully
	ScanStatusCompleted ScanStatus = "COMPLETED"
	// Scan was cancelled by user
	ScanStatusCancelled ScanStatus = "CANCELLED"
	// Scan failed with an error
	ScanStatusFailed ScanStatus = "FAILED"
)

var AllScanStatus = []ScanStatus{
	ScanStatusPending,
	ScanStatusRunning,
	ScanStatusCompleted,
	ScanStatusCancelled,
	ScanStatusFailed,
}

func (e ScanStatus) IsValid() bool {
	switch e {
	case ScanStatusPending, ScanStatusRunning, ScanStatusCompleted, ScanStatusCancelled, ScanStatusFailed:
		return true
	}
	return false
}

func (e ScanStatus) String() string {
	return string(e)
}

func (e *ScanStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScanStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScanStatus", str)
	}
	return nil
}

func (e ScanStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Service operational status
type ServiceStatus string

const (
	// Service is fully operational
	ServiceStatusHealthy ServiceStatus = "HEALTHY"
	// Service is operational with degraded performance
	ServiceStatusDegraded ServiceStatus = "DEGRADED"
	// Service is not operational
	ServiceStatusUnhealthy ServiceStatus = "UNHEALTHY"
)

var AllServiceStatus = []ServiceStatus{
	ServiceStatusHealthy,
	ServiceStatusDegraded,
	ServiceStatusUnhealthy,
}

func (e ServiceStatus) IsValid() bool {
	switch e {
	case ServiceStatusHealthy, ServiceStatusDegraded, ServiceStatusUnhealthy:
		return true
	}
	return false
}

func (e ServiceStatus) String() string {
	return string(e)
}

func (e *ServiceStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceStatus", str)
	}
	return nil
}

func (e ServiceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Severity level for diagnostic suggestions
type SuggestionSeverity string

const (
	// Informational message, no action required
	SuggestionSeverityInfo SuggestionSeverity = "INFO"
	// Warning that may affect functionality
	SuggestionSeverityWarning SuggestionSeverity = "WARNING"
	// Error that needs to be addressed
	SuggestionSeverityError SuggestionSeverity = "ERROR"
	// Critical issue blocking connectivity
	SuggestionSeverityCritical SuggestionSeverity = "CRITICAL"
)

var AllSuggestionSeverity = []SuggestionSeverity{
	SuggestionSeverityInfo,
	SuggestionSeverityWarning,
	SuggestionSeverityError,
	SuggestionSeverityCritical,
}

func (e SuggestionSeverity) IsValid() bool {
	switch e {
	case SuggestionSeverityInfo, SuggestionSeverityWarning, SuggestionSeverityError, SuggestionSeverityCritical:
		return true
	}
	return false
}

func (e SuggestionSeverity) String() string {
	return string(e)
}

func (e *SuggestionSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SuggestionSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SuggestionSeverity", str)
	}
	return nil
}

func (e SuggestionSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Priority level for upgrade recommendations
type UpgradePriority string

const (
	// Security-related, should upgrade immediately
	UpgradePriorityCritical UpgradePriority = "CRITICAL"
	// Highly recommended for stability/features
	UpgradePriorityHigh UpgradePriority = "HIGH"
	// Recommended but not urgent
	UpgradePriorityMedium UpgradePriority = "MEDIUM"
	// Nice to have, optional
	UpgradePriorityLow UpgradePriority = "LOW"
)

var AllUpgradePriority = []UpgradePriority{
	UpgradePriorityCritical,
	UpgradePriorityHigh,
	UpgradePriorityMedium,
	UpgradePriorityLow,
}

func (e UpgradePriority) IsValid() bool {
	switch e {
	case UpgradePriorityCritical, UpgradePriorityHigh, UpgradePriorityMedium, UpgradePriorityLow:
		return true
	}
	return false
}

func (e UpgradePriority) String() string {
	return string(e)
}

func (e *UpgradePriority) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpgradePriority(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpgradePriority", str)
	}
	return nil
}

func (e UpgradePriority) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Predefined validation formats for common data types
type ValidateFormat string

const (
	ValidateFormatEmail    ValidateFormat = "EMAIL"
	ValidateFormatURL      ValidateFormat = "URL"
	ValidateFormatUUID     ValidateFormat = "UUID"
	ValidateFormatIPV4     ValidateFormat = "IPV4"
	ValidateFormatIPV6     ValidateFormat = "IPV6"
	ValidateFormatMac      ValidateFormat = "MAC"
	ValidateFormatCidr     ValidateFormat = "CIDR"
	ValidateFormatHostname ValidateFormat = "HOSTNAME"
	ValidateFormatFqdn     ValidateFormat = "FQDN"
)

var AllValidateFormat = []ValidateFormat{
	ValidateFormatEmail,
	ValidateFormatURL,
	ValidateFormatUUID,
	ValidateFormatIPV4,
	ValidateFormatIPV6,
	ValidateFormatMac,
	ValidateFormatCidr,
	ValidateFormatHostname,
	ValidateFormatFqdn,
}

func (e ValidateFormat) IsValid() bool {
	switch e {
	case ValidateFormatEmail, ValidateFormatURL, ValidateFormatUUID, ValidateFormatIPV4, ValidateFormatIPV6, ValidateFormatMac, ValidateFormatCidr, ValidateFormatHostname, ValidateFormatFqdn:
		return true
	}
	return false
}

func (e ValidateFormat) String() string {
	return string(e)
}

func (e *ValidateFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidateFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidateFormat", str)
	}
	return nil
}

func (e ValidateFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
