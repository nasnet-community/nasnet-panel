// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

// Connection interface for paginated results (Relay pagination)
type Connection interface {
	IsConnection()
}

// Edge interface for connection edges
type Edge interface {
	IsEdge()
}

// Relay Node interface for global object identification
type Node interface {
	IsNode()
}

// Universal State v2 Resource Interface.
// Every managed resource implements this interface with 8 layers:
// 1. configuration - User's desired config (mutable by user)
// 2. validation - Pre-flight check results (computed by backend)
// 3. deployment - What's on router (after Apply-Confirm)
// 4. runtime - Live operational state (polled/streamed)
// 5. telemetry - Time-series metrics (historical)
// 6. metadata - Lifecycle info, tags, ownership
// 7. relationships - Dependencies (embedded + explicit)
// 8. platform - Capabilities and field mappings
type Resource interface {
	IsResource()
}

type AddBridgePortInput struct {
	InterfaceID      string                         `json:"interfaceId"`
	Pvid             graphql.Omittable[*int]        `json:"pvid,omitempty"`
	FrameTypes       graphql.Omittable[*FrameTypes] `json:"frameTypes,omitempty"`
	IngressFiltering graphql.Omittable[*bool]       `json:"ingressFiltering,omitempty"`
}

type AddChangeSetItemPayload struct {
	// The updated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// The added item ID
	ItemID *string `json:"itemId,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for manually adding a new router with full credentials and protocol preference.
// This is the primary input type for the addRouter mutation.
type AddRouterInput struct {
	// Router hostname or IP address.
	// Can be an IPv4 address (e.g., '192.168.88.1'), IPv6 address, or hostname (e.g., 'router.local').
	// Hostnames will trigger DNS resolution with caching.
	Host string `json:"host"`
	// Connection port. If not specified, defaults to protocol-specific port:
	// - REST: 443 (or 80 for HTTP)
	// - API: 8728
	// - API_SSL: 8729
	// - SSH: 22
	// - Telnet: 23
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Username for authentication.
	// For MikroTik routers, this is typically 'admin' or a custom user.
	Username string `json:"username"`
	// Password for authentication.
	// This value is encrypted before storage and never logged.
	Password string `json:"password"`
	// Protocol preference for connection.
	// Defaults to AUTO which tries protocols in recommended order.
	ProtocolPreference graphql.Omittable[*ProtocolPreference] `json:"protocolPreference,omitempty"`
	// User-friendly display name for the router.
	// If not provided, a name will be generated from the host.
	Name graphql.Omittable[*string] `json:"name,omitempty"`
}

// Payload returned from the addRouter mutation.
// Contains either the created router or validation/connection errors.
type AddRouterPayload struct {
	// The newly created router (null if errors occurred)
	Router *Router `json:"router,omitempty"`
	// Connection test result from initial connection attempt
	ConnectionResult *ConnectionTestResult `json:"connectionResult,omitempty"`
	// Field-level validation errors for retry
	ValidationErrors []*ValidationError `json:"validationErrors,omitempty"`
	// General errors that occurred during creation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Resource affected by a configuration change
type AffectedResource struct {
	// Resource type (ip-address, dhcp-server, firewall-rule, etc.)
	Type string `json:"type"`
	// Resource ID
	ID string `json:"id"`
	// Resource name or description
	Name string `json:"name"`
	// How the resource will be affected (modified, disabled, removed)
	Impact ResourceImpact `json:"impact"`
}

// Individual alert instance triggered when rule conditions are met
type Alert struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Alert rule that triggered this alert
	Rule *AlertRule `json:"rule"`
	// Event type that triggered this alert
	EventType string `json:"eventType"`
	// Alert severity level
	Severity AlertSeverity `json:"severity"`
	// Alert title/summary
	Title string `json:"title"`
	// Detailed alert message
	Message string `json:"message"`
	// Event data and context information
	Data map[string]interface{} `json:"data,omitempty"`
	// Device ID that triggered this alert
	DeviceID *string `json:"deviceId,omitempty"`
	// When alert was triggered
	TriggeredAt time.Time `json:"triggeredAt"`
	// When alert was acknowledged
	AcknowledgedAt *time.Time `json:"acknowledgedAt,omitempty"`
	// User who acknowledged the alert
	AcknowledgedBy *string `json:"acknowledgedBy,omitempty"`
	// Delivery status per channel
	DeliveryStatus map[string]interface{} `json:"deliveryStatus,omitempty"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (Alert) IsNode() {}

// Condition for event matching in alert rules
type AlertCondition struct {
	// Field name to evaluate
	Field string `json:"field"`
	// Comparison operator
	Operator ConditionOperator `json:"operator"`
	// Value to compare against
	Value string `json:"value"`
}

// Alert condition input
type AlertConditionInput struct {
	// Field name to evaluate
	Field string `json:"field"`
	// Comparison operator
	Operator ConditionOperator `json:"operator"`
	// Value to compare against
	Value string `json:"value"`
}

// Paginated alert connection
type AlertConnection struct {
	// Alert edges
	Edges []*AlertEdge `json:"edges"`
	// Pagination information
	PageInfo *PageInfo `json:"pageInfo"`
	// Total count of alerts
	TotalCount int `json:"totalCount"`
}

func (AlertConnection) IsConnection() {}

// Alert edge for pagination
type AlertEdge struct {
	// Alert node
	Node *Alert `json:"node"`
	// Pagination cursor
	Cursor string `json:"cursor"`
}

func (AlertEdge) IsEdge() {}

// Alert event for real-time subscriptions
type AlertEvent struct {
	// The alert that changed
	Alert *Alert `json:"alert"`
	// Type of action that occurred
	Action AlertAction `json:"action"`
}

// Alert mutation payload
type AlertPayload struct {
	// Modified alert
	Alert *Alert `json:"alert,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Alert rule defines conditions that trigger notifications when met
type AlertRule struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Human-readable alert rule name
	Name string `json:"name"`
	// Optional description of what this rule monitors
	Description *string `json:"description,omitempty"`
	// Event type to match (e.g., 'router.offline', 'interface.down', 'cpu.high')
	EventType string `json:"eventType"`
	// Array of conditions for event matching
	Conditions []*AlertCondition `json:"conditions"`
	// Alert severity level
	Severity AlertSeverity `json:"severity"`
	// Notification channels to use
	Channels []string `json:"channels"`
	// Throttle configuration to prevent alert spam
	Throttle *ThrottleConfig `json:"throttle,omitempty"`
	// Quiet hours configuration for non-critical alerts
	QuietHours *QuietHoursConfig `json:"quietHours,omitempty"`
	// Optional device ID filter - rule only applies to this device
	DeviceID *string `json:"deviceId,omitempty"`
	// Whether this alert rule is enabled
	Enabled bool `json:"enabled"`
	// Record creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// Alerts triggered by this rule
	Alerts []*Alert `json:"alerts"`
}

func (AlertRule) IsNode() {}

// Alert rule mutation payload
type AlertRulePayload struct {
	// Created/updated alert rule
	AlertRule *AlertRule `json:"alertRule,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

type ApplyChangeSetPayload struct {
	// Change set ID
	ChangeSetID string `json:"changeSetId"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of applying a fix
type ApplyFixPayload struct {
	// Whether fix was applied successfully
	Success bool `json:"success"`
	// User-friendly message
	Message string `json:"message"`
	// Fix application status
	Status FixApplicationStatus `json:"status"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

type ApplyResourcePayload struct {
	// The applied resource
	Resource Resource `json:"resource,omitempty"`
	// Operation ID for progress tracking
	OperationID string `json:"operationId"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

type ArchiveResourcePayload struct {
	// Whether archive was successful
	Success bool `json:"success"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Authentication test status
type AuthStatus struct {
	// Whether authentication was tested
	Tested bool `json:"tested"`
	// Whether authentication succeeded
	Success bool `json:"success"`
	// Error message (if authentication failed)
	Error *string `json:"error,omitempty"`
	// Error code mapped to ErrorCodes (A5xx)
	ErrorCode *string `json:"errorCode,omitempty"`
}

// A bandwidth data point
type BandwidthDataPoint struct {
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
	// Bytes in during this period
	BytesIn Size `json:"bytesIn"`
	// Bytes out during this period
	BytesOut Size `json:"bytesOut"`
	// Period duration in seconds
	PeriodSeconds int `json:"periodSeconds"`
}

// Input for batch interface operations
type BatchInterfaceInput struct {
	// Interface IDs to operate on
	InterfaceIds []string `json:"interfaceIds"`
	// Action to perform
	Action BatchInterfaceAction `json:"action"`
	// Optional input for UPDATE action
	Input graphql.Omittable[*UpdateInterfaceInput] `json:"input,omitempty"`
}

// Payload returned by batchInterfaceOperation mutation
type BatchInterfacePayload struct {
	// Interfaces that were successfully updated
	Succeeded []*Interface `json:"succeeded"`
	// Interfaces that failed with reasons
	Failed []*InterfaceOperationError `json:"failed"`
	// General errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

type Bridge struct {
	ID                   string           `json:"id"`
	Name                 string           `json:"name"`
	Comment              *string          `json:"comment,omitempty"`
	Disabled             bool             `json:"disabled"`
	Running              bool             `json:"running"`
	MacAddress           *MAC             `json:"macAddress,omitempty"`
	Mtu                  *int             `json:"mtu,omitempty"`
	Protocol             StpProtocol      `json:"protocol"`
	Priority             *int             `json:"priority,omitempty"`
	VlanFiltering        bool             `json:"vlanFiltering"`
	Pvid                 *int             `json:"pvid,omitempty"`
	Ports                []*BridgePort    `json:"ports"`
	Vlans                []*BridgeVlan    `json:"vlans"`
	IPAddresses          []*IPAddress     `json:"ipAddresses"`
	StpStatus            *BridgeStpStatus `json:"stpStatus,omitempty"`
	DependentDhcpServers []*DhcpServer    `json:"dependentDhcpServers"`
	DependentRoutes      []*Route         `json:"dependentRoutes"`
}

func (Bridge) IsNode() {}

type BridgeMutationResult struct {
	Success bool             `json:"success"`
	Bridge  *Bridge          `json:"bridge,omitempty"`
	Errors  []*MutationError `json:"errors,omitempty"`
	// Previous state for undo functionality
	PreviousState map[string]interface{} `json:"previousState,omitempty"`
	// Unique operation ID for undo within 10-second window
	OperationID *string `json:"operationId,omitempty"`
}

type BridgePort struct {
	ID               string       `json:"id"`
	Bridge           *Bridge      `json:"bridge"`
	Interface        *Interface   `json:"interface"`
	Pvid             int          `json:"pvid"`
	FrameTypes       FrameTypes   `json:"frameTypes"`
	IngressFiltering bool         `json:"ingressFiltering"`
	TaggedVlans      []int        `json:"taggedVlans"`
	UntaggedVlans    []int        `json:"untaggedVlans"`
	Role             StpPortRole  `json:"role"`
	State            StpPortState `json:"state"`
	PathCost         int          `json:"pathCost"`
	Edge             bool         `json:"edge"`
}

func (BridgePort) IsNode() {}

type BridgePortMutationResult struct {
	Success       bool                   `json:"success"`
	Port          *BridgePort            `json:"port,omitempty"`
	Errors        []*MutationError       `json:"errors,omitempty"`
	PreviousState map[string]interface{} `json:"previousState,omitempty"`
	OperationID   *string                `json:"operationId,omitempty"`
}

// VLAN configuration for a bridge port (trunk/access port setup)
type BridgePortVlanConfig struct {
	// Bridge port ID
	PortID string `json:"portId"`
	// Port VLAN ID (PVID) for untagged traffic
	Pvid int `json:"pvid"`
	// Frame types allowed on this port
	FrameTypes BridgePortFrameTypes `json:"frameTypes"`
	// Tagged VLANs allowed on this port (trunk mode)
	TaggedVlans []int `json:"taggedVlans"`
	// Untagged VLANs on this port (typically just PVID)
	UntaggedVlans []int `json:"untaggedVlans"`
	// Port mode (trunk or access)
	Mode PortMode `json:"mode"`
}

// Input for configuring bridge port VLAN settings
type BridgePortVlanInput struct {
	// Port VLAN ID (PVID) for untagged traffic
	Pvid int `json:"pvid"`
	// Frame types allowed on this port
	FrameTypes BridgePortFrameTypes `json:"frameTypes"`
	// Tagged VLANs (for trunk ports)
	TaggedVlans graphql.Omittable[[]int] `json:"taggedVlans,omitempty"`
	// Port mode (trunk or access)
	Mode PortMode `json:"mode"`
}

// Bridge resource (part of LANNetwork)
type BridgeResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Bridge name
	Name string `json:"name"`
	// Ports in this bridge
	Ports []string `json:"ports"`
	// Protocol mode (rstp, stp, none)
	ProtocolMode *string `json:"protocolMode,omitempty"`
}

func (BridgeResource) IsResource() {}

func (BridgeResource) IsNode() {}

type BridgeStpStatus struct {
	RootBridge          bool       `json:"rootBridge"`
	RootBridgeID        *string    `json:"rootBridgeId,omitempty"`
	RootPort            *string    `json:"rootPort,omitempty"`
	RootPathCost        int        `json:"rootPathCost"`
	TopologyChangeCount int        `json:"topologyChangeCount"`
	LastTopologyChange  *time.Time `json:"lastTopologyChange,omitempty"`
}

type BridgeVlan struct {
	UUID          string        `json:"uuid"`
	Bridge        *Bridge       `json:"bridge"`
	VlanID        int           `json:"vlanId"`
	TaggedPorts   []*BridgePort `json:"taggedPorts"`
	UntaggedPorts []*BridgePort `json:"untaggedPorts"`
}

type BridgeVlanMutationResult struct {
	Success bool             `json:"success"`
	Vlan    *BridgeVlan      `json:"vlan,omitempty"`
	Errors  []*MutationError `json:"errors,omitempty"`
}

// Bulk alert mutation payload
type BulkAlertPayload struct {
	// Number of alerts acknowledged
	AcknowledgedCount int `json:"acknowledgedCount"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// CPU utilization metrics
type CPUMetrics struct {
	// Overall CPU usage percentage (0-100)
	Usage float64 `json:"usage"`
	// Number of CPU cores
	Cores int `json:"cores"`
	// Per-core usage percentages (one per core)
	PerCore []float64 `json:"perCore"`
	// CPU frequency in MHz (optional)
	Frequency *float64 `json:"frequency,omitempty"`
}

type CancelChangeSetPayload struct {
	// The cancelled change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Whether cancel was successful
	Success bool `json:"success"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

type CancelScanPayload struct {
	// The cancelled scan task
	Task *ScanTask `json:"task,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Single capability with its support level and guidance
type CapabilityEntry struct {
	// Capability category
	Capability Capability `json:"capability"`
	// Support level
	Level CapabilityLevel `json:"level"`
	// Human-readable description of support
	Description *string `json:"description,omitempty"`
	// Actionable message if feature unavailable
	Guidance *string `json:"guidance,omitempty"`
}

// An entry in the change log
type ChangeLogEntry struct {
	// Change timestamp
	Timestamp time.Time `json:"timestamp"`
	// User who made the change
	User string `json:"user"`
	// Type of change
	ChangeType ChangeType `json:"changeType"`
	// Changed fields
	ChangedFields []string `json:"changedFields"`
	// Brief description of the change
	Summary *string `json:"summary,omitempty"`
}

// A change set representing an atomic multi-resource operation
type ChangeSet struct {
	// Unique identifier (ULID)
	ID string `json:"id"`
	// Human-readable name
	Name string `json:"name"`
	// Optional description
	Description *string `json:"description,omitempty"`
	// Router ID this change set applies to
	RouterID string `json:"routerId"`
	// Items in this change set
	Items []*ChangeSetItem `json:"items"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Validation result
	Validation *ChangeSetValidationResult `json:"validation,omitempty"`
	// Rollback plan
	RollbackPlan []*RollbackStep `json:"rollbackPlan"`
	// Error information (if failed)
	Error *ChangeSetError `json:"error,omitempty"`
	// Created timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Apply started timestamp
	ApplyStartedAt *time.Time `json:"applyStartedAt,omitempty"`
	// Completed timestamp
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	// User who created the change set
	CreatedBy *string `json:"createdBy,omitempty"`
	// Source wizard/feature
	Source *string `json:"source,omitempty"`
	// Version for optimistic concurrency
	Version int `json:"version"`
}

// Conflict between change set items
type ChangeSetConflict struct {
	// First conflicting item ID
	ItemID1 string `json:"itemId1"`
	// Second conflicting item ID or resource UUID
	ItemID2OrResourceUUID string `json:"itemId2OrResourceUuid"`
	// Whether conflict is with existing resource
	IsExternalConflict bool `json:"isExternalConflict"`
	// Description of the conflict
	Description string `json:"description"`
	// Suggested resolution
	Resolution *string `json:"resolution,omitempty"`
}

// Detailed error for failed change sets
type ChangeSetError struct {
	// Error message
	Message string `json:"message"`
	// Item ID that caused the failure
	FailedItemID string `json:"failedItemId"`
	// Error code
	Code *string `json:"code,omitempty"`
	// Items applied before failure
	PartiallyAppliedItemIds []string `json:"partiallyAppliedItemIds"`
	// Items that failed rollback
	FailedRollbackItemIds []string `json:"failedRollbackItemIds"`
	// Whether manual intervention is required
	RequiresManualIntervention bool `json:"requiresManualIntervention"`
}

// Individual item within a change set
type ChangeSetItem struct {
	// Unique identifier for this item
	ID string `json:"id"`
	// Resource type identifier
	ResourceType string `json:"resourceType"`
	// Resource category
	ResourceCategory ResourceCategory `json:"resourceCategory"`
	// Existing resource UUID (null for create operations)
	ResourceUUID *string `json:"resourceUuid,omitempty"`
	// User-friendly name
	Name string `json:"name"`
	// Optional description
	Description *string `json:"description,omitempty"`
	// Operation to perform
	Operation ChangeOperation `json:"operation"`
	// New/updated configuration
	Configuration map[string]interface{} `json:"configuration"`
	// Previous state (for rollback)
	PreviousState map[string]interface{} `json:"previousState,omitempty"`
	// Item IDs this depends on
	Dependencies []string `json:"dependencies"`
	// Current status
	Status ChangeSetItemStatus `json:"status"`
	// Error message if failed
	Error *string `json:"error,omitempty"`
	// Apply started timestamp
	ApplyStartedAt *time.Time `json:"applyStartedAt,omitempty"`
	// Apply completed timestamp
	ApplyCompletedAt *time.Time `json:"applyCompletedAt,omitempty"`
	// Order in which this item will be applied
	ApplyOrder int `json:"applyOrder"`
}

// Input for adding an item to a change set
type ChangeSetItemInput struct {
	// Resource type identifier
	ResourceType string `json:"resourceType"`
	// Resource category
	ResourceCategory ResourceCategory `json:"resourceCategory"`
	// Existing resource UUID (for update/delete)
	ResourceUUID graphql.Omittable[*string] `json:"resourceUuid,omitempty"`
	// User-friendly name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Operation to perform
	Operation ChangeOperation `json:"operation"`
	// Configuration
	Configuration map[string]interface{} `json:"configuration"`
	// Previous state (for rollback on update/delete)
	PreviousState graphql.Omittable[map[string]interface{}] `json:"previousState,omitempty"`
	// Item IDs this depends on
	Dependencies graphql.Omittable[[]string] `json:"dependencies,omitempty"`
}

// Progress event for real-time updates during apply
type ChangeSetProgressEvent struct {
	// Change set ID
	ChangeSetID string `json:"changeSetId"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Currently processing item
	CurrentItem *CurrentItemInfo `json:"currentItem,omitempty"`
	// Number of items applied
	AppliedCount int `json:"appliedCount"`
	// Total number of items
	TotalCount int `json:"totalCount"`
	// Progress percentage (0-100)
	ProgressPercent float64 `json:"progressPercent"`
	// Estimated time remaining in milliseconds
	EstimatedRemainingMs *int `json:"estimatedRemainingMs,omitempty"`
	// Error if failed
	Error *ChangeSetError `json:"error,omitempty"`
	// Timestamp of this event
	Timestamp time.Time `json:"timestamp"`
}

// Change set status change event
type ChangeSetStatusEvent struct {
	// Change set ID
	ChangeSetID string `json:"changeSetId"`
	// Previous status
	PreviousStatus ChangeSetStatus `json:"previousStatus"`
	// New status
	NewStatus ChangeSetStatus `json:"newStatus"`
	// Error if failed
	Error *ChangeSetError `json:"error,omitempty"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// Summary of a change set for list displays
type ChangeSetSummary struct {
	// Change set ID
	ID string `json:"id"`
	// Name
	Name string `json:"name"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Operation counts
	OperationCounts *OperationCounts `json:"operationCounts"`
	// Total items
	TotalItems int `json:"totalItems"`
	// Created timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Has validation errors
	HasErrors bool `json:"hasErrors"`
	// Has validation warnings
	HasWarnings bool `json:"hasWarnings"`
}

// Validation error for a change set item
type ChangeSetValidationError struct {
	// Item ID with validation error
	ItemID string `json:"itemId"`
	// Field path within the item configuration
	Field string `json:"field"`
	// Error message
	Message string `json:"message"`
	// Severity level
	Severity ValidationSeverity `json:"severity"`
	// Error code
	Code *string `json:"code,omitempty"`
}

// Validation result for a change set
type ChangeSetValidationResult struct {
	// Whether the change set can be applied
	CanApply bool `json:"canApply"`
	// Validation errors (blocking)
	Errors []*ChangeSetValidationError `json:"errors"`
	// Validation warnings (non-blocking)
	Warnings []*ChangeSetValidationError `json:"warnings"`
	// Detected conflicts
	Conflicts []*ChangeSetConflict `json:"conflicts"`
	// Missing dependencies
	MissingDependencies []*MissingDependency `json:"missingDependencies"`
	// Circular dependencies (if any)
	CircularDependencies [][]string `json:"circularDependencies,omitempty"`
}

// Event emitted when circuit breaker state changes
type CircuitBreakerEvent struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Previous state
	PreviousState CircuitBreakerState `json:"previousState"`
	// New state
	NewState CircuitBreakerState `json:"newState"`
	// Consecutive failures that triggered the change
	ConsecutiveFailures int `json:"consecutiveFailures"`
	// When the state changed
	Timestamp time.Time `json:"timestamp"`
}

// Circuit breaker status for a router
type CircuitBreakerStatus struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Current circuit breaker state
	State CircuitBreakerState `json:"state"`
	// Number of consecutive failures
	FailureCount int `json:"failureCount"`
	// Failure threshold before circuit opens
	FailureThreshold int `json:"failureThreshold"`
	// Seconds until auto-retry (when circuit is open)
	CooldownRemainingSeconds *int `json:"cooldownRemainingSeconds,omitempty"`
	// When the last failure occurred
	LastFailureAt *time.Time `json:"lastFailureAt,omitempty"`
	// When the last success occurred
	LastSuccessAt *time.Time `json:"lastSuccessAt,omitempty"`
}

// A composite resource with all related sub-resources
type CompositeResource struct {
	// The root resource
	Root Resource `json:"root"`
	// All child/related resources
	Children []Resource `json:"children"`
	// Flattened relationship graph
	Relationships []*ResourceRelationshipEdge `json:"relationships"`
}

// Preview of RouterOS configuration commands
type ConfigPreview struct {
	// RouterOS commands to be executed
	Commands []string `json:"commands"`
	// Warnings about the configuration changes
	Warnings []string `json:"warnings,omitempty"`
	// Resources that will be affected
	AffectedResources []*AffectedResource `json:"affectedResources,omitempty"`
}

// Progress information for configuration apply operations
type ConfigProgress struct {
	// Unique operation identifier
	OperationID string `json:"operationId"`
	// Current status of the operation
	Status ConfigApplyStatus `json:"status"`
	// Completion percentage (0-100)
	Percentage int `json:"percentage"`
	// Human-readable progress message
	Message string `json:"message"`
	// Current step number
	CurrentStep *int `json:"currentStep,omitempty"`
	// Total number of steps
	TotalSteps *int `json:"totalSteps,omitempty"`
	// Timestamp of this progress update
	Timestamp time.Time `json:"timestamp"`
}

type ConnectRouterPayload struct {
	// The router that was connected
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during connection
	Errors []*MutationError `json:"errors,omitempty"`
}

// Record of a single protocol connection attempt
type ConnectionAttempt struct {
	// Protocol that was attempted
	Protocol Protocol `json:"protocol"`
	// When the attempt started
	StartedAt time.Time `json:"startedAt"`
	// When the attempt ended
	EndedAt time.Time `json:"endedAt"`
	// Whether the attempt succeeded
	Success bool `json:"success"`
	// Error code if failed
	ErrorCode *string `json:"errorCode,omitempty"`
	// Error message if failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Error category for classification
	ErrorCategory *ErrorCategory `json:"errorCategory,omitempty"`
}

// Detailed connection status for a router
type ConnectionDetails struct {
	// Current connection state
	State ConnectionStatus `json:"state"`
	// Protocol currently in use
	Protocol *Protocol `json:"protocol,omitempty"`
	// User's preferred protocol (if set)
	PreferredProtocol *Protocol `json:"preferredProtocol,omitempty"`
	// When the connection was established
	ConnectedAt *time.Time `json:"connectedAt,omitempty"`
	// Connection uptime duration
	Uptime *Duration `json:"uptime,omitempty"`
	// When the last disconnection occurred
	DisconnectedAt *time.Time `json:"disconnectedAt,omitempty"`
	// Most recent error message
	LastError *string `json:"lastError,omitempty"`
	// When the last error occurred
	LastErrorTime *time.Time `json:"lastErrorTime,omitempty"`
	// Reason for disconnection
	DisconnectReason *DisconnectReason `json:"disconnectReason,omitempty"`
	// Number of reconnection attempts made
	ReconnectAttempts int `json:"reconnectAttempts"`
	// When the next reconnection attempt will be made
	NextReconnectAt *time.Time `json:"nextReconnectAt,omitempty"`
	// Current circuit breaker state
	CircuitBreakerState CircuitBreakerState `json:"circuitBreakerState"`
	// Router version (if connected)
	Version *string `json:"version,omitempty"`
	// When the last health check was performed
	LastHealthCheck *time.Time `json:"lastHealthCheck,omitempty"`
	// Consecutive passed health checks
	HealthChecksPassed int `json:"healthChecksPassed"`
	// Consecutive failed health checks
	HealthChecksFailed int `json:"healthChecksFailed"`
	// Security warning if using insecure protocol (e.g., Telnet)
	SecurityWarning *string `json:"securityWarning,omitempty"`
	// Recommendation for upgrading to a more secure protocol
	UpgradeRecommendation *string `json:"upgradeRecommendation,omitempty"`
	// Whether the current protocol is considered legacy/insecure
	IsLegacyProtocol bool `json:"isLegacyProtocol"`
}

// Detailed error information for connection failures.
// Used to provide actionable feedback to the user.
type ConnectionError struct {
	// Error code for programmatic handling
	Code ConnectionErrorCode `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Protocol that failed (if specific to a protocol)
	Protocol *Protocol `json:"protocol,omitempty"`
	// Whether the error is likely transient and retryable
	Retryable bool `json:"retryable"`
	// Suggested user action to resolve the error
	SuggestedAction *string `json:"suggestedAction,omitempty"`
	// Timeout in milliseconds (if timeout error)
	TimeoutMs *int `json:"timeoutMs,omitempty"`
}

// Connection manager statistics
type ConnectionStats struct {
	// Total number of connections
	TotalConnections int `json:"totalConnections"`
	// Number of connected routers
	Connected int `json:"connected"`
	// Number of connecting routers
	Connecting int `json:"connecting"`
	// Number of disconnected routers
	Disconnected int `json:"disconnected"`
	// Number of reconnecting routers
	Reconnecting int `json:"reconnecting"`
	// Number of routers in error state
	Error int `json:"error"`
}

// Result of a connection test attempt, including protocol detection results.
type ConnectionTestResult struct {
	// Whether the connection was successful
	Success bool `json:"success"`
	// Protocol that was successfully used
	ProtocolUsed *Protocol `json:"protocolUsed,omitempty"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// RouterOS version detected (if connection succeeded)
	RouterVersion *string `json:"routerVersion,omitempty"`
	// Router model detected (if connection succeeded)
	RouterModel *string `json:"routerModel,omitempty"`
	// Router board name (if connection succeeded)
	BoardName *string `json:"boardName,omitempty"`
	// Uptime of the router (if connection succeeded)
	Uptime *Duration `json:"uptime,omitempty"`
	// List of protocols that were attempted
	ProtocolsAttempted []Protocol `json:"protocolsAttempted"`
	// Whether the router supports containers
	SupportsContainers *bool `json:"supportsContainers,omitempty"`
	// Architecture of the router (arm, arm64, x86, etc.)
	Architecture *string `json:"architecture,omitempty"`
	// Error details if connection failed
	Error *ConnectionError `json:"error,omitempty"`
}

// Container-specific capability information
type ContainerInfo struct {
	// Whether container package is installed
	PackageInstalled bool `json:"packageInstalled"`
	// Whether container feature is enabled in system settings
	Enabled bool `json:"enabled"`
	// Whether a container registry is configured
	RegistryConfigured bool `json:"registryConfigured"`
	// Available storage for container images in bytes
	StorageAvailable Size `json:"storageAvailable"`
	// Whether network namespace is supported
	SupportsNetworkNamespace bool `json:"supportsNetworkNamespace"`
	// Maximum number of containers supported
	MaxContainers *int `json:"maxContainers,omitempty"`
}

// Input for creating an alert rule
type CreateAlertRuleInput struct {
	// Human-readable alert rule name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Event type to match
	EventType string `json:"eventType"`
	// Array of conditions
	Conditions graphql.Omittable[[]*AlertConditionInput] `json:"conditions,omitempty"`
	// Alert severity level
	Severity AlertSeverity `json:"severity"`
	// Notification channels
	Channels []string `json:"channels"`
	// Throttle configuration
	Throttle graphql.Omittable[*ThrottleConfigInput] `json:"throttle,omitempty"`
	// Quiet hours configuration
	QuietHours graphql.Omittable[*QuietHoursConfigInput] `json:"quietHours,omitempty"`
	// Optional device ID filter
	DeviceID graphql.Omittable[*string] `json:"deviceId,omitempty"`
	// Whether rule is enabled (default: true)
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

type CreateBridgeInput struct {
	Name          string                          `json:"name"`
	Comment       graphql.Omittable[*string]      `json:"comment,omitempty"`
	Protocol      graphql.Omittable[*StpProtocol] `json:"protocol,omitempty"`
	Priority      graphql.Omittable[*int]         `json:"priority,omitempty"`
	VlanFiltering graphql.Omittable[*bool]        `json:"vlanFiltering,omitempty"`
	Pvid          graphql.Omittable[*int]         `json:"pvid,omitempty"`
	Mtu           graphql.Omittable[*int]         `json:"mtu,omitempty"`
}

type CreateBridgeVlanInput struct {
	VlanID          int                         `json:"vlanId"`
	TaggedPortIds   graphql.Omittable[[]string] `json:"taggedPortIds,omitempty"`
	UntaggedPortIds graphql.Omittable[[]string] `json:"untaggedPortIds,omitempty"`
}

// Input for creating a new change set
type CreateChangeSetInput struct {
	// Router to apply changes to
	RouterID string `json:"routerId"`
	// Human-readable name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Source wizard/feature
	Source graphql.Omittable[*string] `json:"source,omitempty"`
}

type CreateChangeSetPayload struct {
	// The created change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for creating a new resource
type CreateResourceInput struct {
	// Router to create resource on
	RouterID string `json:"routerId"`
	// Resource type (e.g., 'vpn.wireguard.client')
	Type string `json:"type"`
	// Resource category
	Category ResourceCategory `json:"category"`
	// Initial configuration
	Configuration map[string]interface{} `json:"configuration"`
	// User-defined relationships
	Relationships graphql.Omittable[*ResourceRelationshipsInput] `json:"relationships,omitempty"`
	// Initial tags
	Tags graphql.Omittable[[]string] `json:"tags,omitempty"`
	// Resource description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

type CreateResourcePayload struct {
	// The created resource
	Resource Resource `json:"resource,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for creating a new router connection
type CreateRouterInput struct {
	// User-friendly display name
	Name string `json:"name"`
	// Router hostname or IP address
	Host string `json:"host"`
	// Connection port (default: 8728 for MikroTik API)
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Username for authentication
	Username string `json:"username"`
	// Password for authentication
	Password string `json:"password"`
	// Router platform type
	Platform graphql.Omittable[*RouterPlatform] `json:"platform,omitempty"`
}

type CreateRouterPayload struct {
	// The created router
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during creation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of testing a single router's credentials.
type CredentialTestResult struct {
	// Router ID that was tested
	RouterID string `json:"routerId"`
	// Router name for display
	RouterName string `json:"routerName"`
	// Whether the test was successful
	Success bool `json:"success"`
	// Connection status
	Status CredentialTestStatus `json:"status"`
	// Response time in milliseconds (if successful)
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if test failed
	Error *string `json:"error,omitempty"`
}

// Result of updating router credentials.
type CredentialUpdatePayload struct {
	// Whether the update was successful
	Success bool `json:"success"`
	// Human-readable message about the operation
	Message string `json:"message"`
	// Updated credential info (without password)
	Credentials *RouterCredentials `json:"credentials,omitempty"`
	// Error code if update failed
	ErrorCode *CredentialErrorCode `json:"errorCode,omitempty"`
	// Errors that occurred during update
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating router credentials.
// Both username and password must be provided.
type CredentialsInput struct {
	// Username for router authentication
	Username string `json:"username"`
	// Password for router authentication
	Password string `json:"password"`
}

// Current item information in progress event
type CurrentItemInfo struct {
	ID        string              `json:"id"`
	Name      string              `json:"name"`
	Operation ChangeOperation     `json:"operation"`
	Status    ChangeSetItemStatus `json:"status"`
}

// DHCP Server resource
type DHCPServerResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Server name
	Name string `json:"name"`
	// Interface serving DHCP
	Interface string `json:"interface"`
	// Address pool name
	AddressPool string `json:"addressPool"`
	// Lease time
	LeaseTime Duration `json:"leaseTime"`
	// Number of active leases
	ActiveLeases *int `json:"activeLeases,omitempty"`
}

func (DHCPServerResource) IsResource() {}

func (DHCPServerResource) IsNode() {}

// Daily statistics
type DailyStats struct {
	// Date (UTC)
	Date time.Time `json:"date"`
	// Total bytes in
	TotalBytesIn Size `json:"totalBytesIn"`
	// Total bytes out
	TotalBytesOut Size `json:"totalBytesOut"`
	// Uptime percentage (0-100)
	UptimePercent float64 `json:"uptimePercent"`
	// Error count
	ErrorCount int `json:"errorCount"`
	// Peak throughput in (bytes/sec)
	PeakThroughputIn Size `json:"peakThroughputIn"`
	// Peak throughput out (bytes/sec)
	PeakThroughputOut Size `json:"peakThroughputOut"`
}

type DeleteChangeSetPayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Delete operation payload
type DeletePayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// ID of deleted item
	DeletedID *string `json:"deletedId,omitempty"`
	// Errors encountered during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

type DeleteResourcePayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// ID of deleted resource
	DeletedID *string `json:"deletedId,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of a delete operation
type DeleteResult struct {
	// Whether the deletion succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// Errors that occurred during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

type DeleteRouterPayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// ID of the deleted router
	DeletedRouterID *string `json:"deletedRouterId,omitempty"`
	// Errors that occurred during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

// Status of a required dependency
type DependencyStatus struct {
	// Dependency resource UUID
	ResourceUUID string `json:"resourceUuid"`
	// Dependency resource type
	ResourceType string `json:"resourceType"`
	// Whether the dependency is active
	IsActive bool `json:"isActive"`
	// Current state of the dependency
	State ResourceLifecycleState `json:"state"`
	// Why this dependency is required
	Reason string `json:"reason"`
}

// Layer 3: What's actually on router after Apply-Confirm.
// Includes router-generated fields like IDs and computed values.
type DeploymentState struct {
	// Router-generated resource ID (e.g., '*1A' in MikroTik)
	RouterResourceID *string `json:"routerResourceId,omitempty"`
	// When the resource was applied
	AppliedAt time.Time `json:"appliedAt"`
	// User who applied the resource
	AppliedBy *string `json:"appliedBy,omitempty"`
	// Version number on router
	RouterVersion *int `json:"routerVersion,omitempty"`
	// Router-generated fields (public key, computed values, etc.)
	GeneratedFields map[string]interface{} `json:"generatedFields,omitempty"`
	// Whether deployment matches configuration (no drift)
	IsInSync bool `json:"isInSync"`
	// Detected drift from configuration
	Drift *DriftInfo `json:"drift,omitempty"`
	// Apply operation ID for audit trail
	ApplyOperationID *string `json:"applyOperationId,omitempty"`
}

type DeprecateResourcePayload struct {
	// The deprecated resource
	Resource Resource `json:"resource,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Device (router) for querying resource metrics
type Device struct {
	// Device identifier
	ID string `json:"id"`
	// Current resource utilization metrics
	ResourceMetrics *ResourceMetrics `json:"resourceMetrics"`
}

// DHCP client configuration for dynamic WAN IP
type DhcpClient struct {
	// Unique identifier
	ID string `json:"id"`
	// Interface name
	Interface string `json:"interface"`
	// Whether DHCP client is disabled
	Disabled bool `json:"disabled"`
	// Add default route from DHCP
	AddDefaultRoute bool `json:"addDefaultRoute"`
	// Use DNS servers from DHCP
	UsePeerDNS bool `json:"usePeerDNS"`
	// Use NTP servers from DHCP
	UsePeerNtp bool `json:"usePeerNTP"`
	// Current DHCP status
	Status string `json:"status"`
	// Assigned IP address
	Address *IPv4 `json:"address,omitempty"`
	// DHCP server address
	DhcpServer *IPv4 `json:"dhcpServer,omitempty"`
	// Gateway from DHCP
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Lease expiry time
	ExpiresAfter *Duration `json:"expiresAfter,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (DhcpClient) IsNode() {}

// Input for creating/updating DHCP client
type DhcpClientInput struct {
	// Interface to enable DHCP client on
	Interface string `json:"interface"`
	// Add default route (default: true)
	AddDefaultRoute graphql.Omittable[*bool] `json:"addDefaultRoute,omitempty"`
	// Use peer DNS (default: true)
	UsePeerDNS graphql.Omittable[*bool] `json:"usePeerDNS,omitempty"`
	// Use peer NTP (default: true)
	UsePeerNtp graphql.Omittable[*bool] `json:"usePeerNTP,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// DHCP server (minimal type for dependencies)
type DhcpServer struct {
	// DHCP server ID
	ID string `json:"id"`
	// DHCP server name
	Name string `json:"name"`
	// Interface the DHCP server is bound to
	Interface *Interface `json:"interface"`
	// Whether the DHCP server is disabled
	Disabled bool `json:"disabled"`
}

// Comprehensive diagnostic report for a router
type DiagnosticReport struct {
	// Router ID being diagnosed
	RouterID string `json:"routerId"`
	// When the diagnostic was run
	Timestamp time.Time `json:"timestamp"`
	// Whether the router is reachable on the network
	NetworkReachable bool `json:"networkReachable"`
	// Status of each checked port
	PortStatus []*PortStatus `json:"portStatus"`
	// TLS certificate status (if TLS ports were checked)
	TLSStatus *TLSStatus `json:"tlsStatus,omitempty"`
	// Authentication test status
	AuthStatus *AuthStatus `json:"authStatus"`
	// Actionable suggestions based on diagnostic results
	Suggestions []*DiagnosticSuggestion `json:"suggestions"`
	// Raw text report for clipboard/export
	RawReport string `json:"rawReport"`
}

// Actionable diagnostic suggestion
type DiagnosticSuggestion struct {
	// Severity level of the issue
	Severity SuggestionSeverity `json:"severity"`
	// Short title describing the issue
	Title string `json:"title"`
	// Detailed description of the issue
	Description string `json:"description"`
	// Recommended action to resolve the issue
	Action string `json:"action"`
	// Link to relevant documentation
	DocsURL *string `json:"docsUrl,omitempty"`
}

type DisconnectRouterPayload struct {
	// The router that was disconnected
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during disconnection
	Errors []*MutationError `json:"errors,omitempty"`
}

// A device discovered during a network scan.
// Only confirmed MikroTik devices are returned (confidence >= 40).
type DiscoveredDevice struct {
	// IP address of the discovered device
	IP string `json:"ip"`
	// Hostname (if reverse DNS resolves)
	Hostname *string `json:"hostname,omitempty"`
	// Open ports found on the device
	Ports []int `json:"ports"`
	// Device type classification
	DeviceType string `json:"deviceType"`
	// Device vendor (always 'MikroTik' for returned results)
	Vendor *string `json:"vendor,omitempty"`
	// RouterOS-specific information (version, board, architecture)
	RouterOSInfo *RouterOSInfo `json:"routerOSInfo,omitempty"`
	// Confidence score for RouterOS detection (40-100)
	Confidence int `json:"confidence"`
	// Detected services (mikrotik-api, mikrotik-winbox, mikrotik-rest, etc.)
	Services []string `json:"services"`
}

// Input for DNS lookup operation
type DNSLookupInput struct {
	// Device/router ID to run lookup from
	DeviceID string `json:"deviceId"`
	// Hostname or IP address to look up
	Hostname string `json:"hostname"`
	// DNS record type to query
	RecordType DNSRecordType `json:"recordType"`
	// DNS server to use (defaults to router's configured DNS)
	Server graphql.Omittable[*string] `json:"server,omitempty"`
	// Query timeout in seconds (default: 5)
	Timeout graphql.Omittable[*int] `json:"timeout,omitempty"`
}

// Result of a DNS lookup operation
type DNSLookupResult struct {
	// Hostname that was queried
	Hostname string `json:"hostname"`
	// Record type that was queried
	RecordType DNSRecordType `json:"recordType"`
	// Query status
	Status DNSLookupStatus `json:"status"`
	// Resolved records
	Records []*DNSRecord `json:"records"`
	// DNS server used
	Server string `json:"server"`
	// Query time in milliseconds
	QueryTime int `json:"queryTime"`
	// Whether response was authoritative
	Authoritative bool `json:"authoritative"`
	// Error message (if query failed)
	Error *string `json:"error,omitempty"`
	// When the query was executed
	Timestamp time.Time `json:"timestamp"`
}

// Single DNS record
type DNSRecord struct {
	// Record name (query hostname)
	Name string `json:"name"`
	// Record type
	Type DNSRecordType `json:"type"`
	// Time to live in seconds
	TTL int `json:"ttl"`
	// Record data (IP, hostname, text, etc.)
	Data string `json:"data"`
	// Priority (for MX/SRV records)
	Priority *int `json:"priority,omitempty"`
	// Weight (for SRV records)
	Weight *int `json:"weight,omitempty"`
	// Port (for SRV records)
	Port *int `json:"port,omitempty"`
}

// DNS server configuration
type DNSServer struct {
	// Server IP address
	Address string `json:"address"`
	// Whether this is the primary DNS server
	IsPrimary bool `json:"isPrimary"`
	// Whether this is the secondary DNS server
	IsSecondary bool `json:"isSecondary"`
}

// Collection of DNS servers
type DNSServers struct {
	// All configured DNS servers
	Servers []*DNSServer `json:"servers"`
	// Primary DNS server address
	Primary string `json:"primary"`
	// Secondary DNS server address (if configured)
	Secondary *string `json:"secondary,omitempty"`
}

// A field that has drifted from configuration
type DriftField struct {
	// Field path
	Path string `json:"path"`
	// Expected value (from configuration)
	Expected map[string]interface{} `json:"expected,omitempty"`
	// Actual value (from router)
	Actual map[string]interface{} `json:"actual,omitempty"`
}

// Information about configuration drift
type DriftInfo struct {
	// When drift was detected
	DetectedAt time.Time `json:"detectedAt"`
	// Fields that have drifted
	DriftedFields []*DriftField `json:"driftedFields"`
	// Suggested action to resolve drift
	SuggestedAction DriftAction `json:"suggestedAction"`
}

// Rich error extensions for detailed error diagnostics.
// Included in GraphQL error responses under the 'extensions' key.
type ErrorExtensions struct {
	// Error code for programmatic handling (e.g., 'V400', 'R200')
	Code string `json:"code"`
	// Error category (validation, protocol, network, auth, resource, internal)
	Category string `json:"category"`
	// Field path that caused the error (e.g., 'input.listenPort')
	Field *string `json:"field,omitempty"`
	// The invalid value (redacted in production for sensitive fields)
	Value map[string]interface{} `json:"value,omitempty"`
	// User-friendly suggestion for fixing the error
	SuggestedFix *string `json:"suggestedFix,omitempty"`
	// Link to relevant documentation
	DocsURL *string `json:"docsUrl,omitempty"`
	// Request correlation ID for support and debugging
	RequestID string `json:"requestId"`
	// Whether the error is recoverable (can be retried)
	Recoverable bool `json:"recoverable"`
	// Additional troubleshooting steps for complex errors
	TroubleshootingSteps []string `json:"troubleshootingSteps,omitempty"`
}

// Options for exporting router configuration.
type ExportConfigInput struct {
	// Router ID to export configuration from
	RouterID string `json:"routerId"`
	// Whether to include credentials (requires encryptionKey if true)
	IncludeCredentials graphql.Omittable[*bool] `json:"includeCredentials,omitempty"`
	// User-provided encryption key for credential export (required if includeCredentials is true)
	EncryptionKey graphql.Omittable[*string] `json:"encryptionKey,omitempty"`
}

// Result of exporting router configuration.
type ExportConfigPayload struct {
	// Whether the export was successful
	Success bool `json:"success"`
	// Exported configuration data (JSON format)
	Config map[string]interface{} `json:"config,omitempty"`
	// Security warning message about credential handling
	SecurityWarning *string `json:"securityWarning,omitempty"`
	// Errors that occurred during export
	Errors []*MutationError `json:"errors,omitempty"`
}

// Information about a feature in the compatibility matrix
type FeatureCompatibilityInfo struct {
	// Feature identifier
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	Name string `json:"name"`
	// Minimum RouterOS version required
	MinVersion string `json:"minVersion"`
	// Maximum RouterOS version supported (if any)
	MaxVersion *string `json:"maxVersion,omitempty"`
	// Minimum version for CHR (if different)
	MinVersionChr *string `json:"minVersionCHR,omitempty"`
	// Required packages
	RequiredPackages []string `json:"requiredPackages"`
	// Feature dependencies
	DependsOn []string `json:"dependsOn"`
	// URL to MikroTik documentation
	UpgradeURL *string `json:"upgradeUrl,omitempty"`
}

// Input for checking feature compatibility
type FeatureCompatibilityInput struct {
	// Feature identifier to check
	FeatureID string `json:"featureId"`
	// Whether to check for CHR-specific requirements
	IsChr graphql.Omittable[*bool] `json:"isCHR,omitempty"`
}

// Feature deployment state
type FeatureDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Container ID (if containerized)
	ContainerID *string `json:"containerId,omitempty"`
	// Container image used
	ContainerImage *string `json:"containerImage,omitempty"`
	// Assigned ports
	AssignedPorts []Port `json:"assignedPorts,omitempty"`
	// Assigned IP address
	AssignedIP *IPv4 `json:"assignedIP,omitempty"`
}

// Marketplace Feature resource (Tor, AdGuard, sing-box, etc.)
type FeatureResource struct {
	ID                string                 `json:"id"`
	ScopedID          string                 `json:"scopedId"`
	Type              string                 `json:"type"`
	Category          ResourceCategory       `json:"category"`
	Configuration     map[string]interface{} `json:"configuration,omitempty"`
	Validation        *ValidationResult      `json:"validation,omitempty"`
	Deployment        *DeploymentState       `json:"deployment,omitempty"`
	Runtime           *RuntimeState          `json:"runtime,omitempty"`
	Telemetry         *TelemetryData         `json:"telemetry,omitempty"`
	Metadata          *ResourceMetadata      `json:"metadata"`
	Relationships     *ResourceRelationships `json:"relationships,omitempty"`
	Platform          *PlatformInfo          `json:"platform,omitempty"`
	FeatureDeployment *FeatureDeployment     `json:"featureDeployment,omitempty"`
	FeatureRuntime    *FeatureRuntime        `json:"featureRuntime,omitempty"`
	// Feature identifier
	FeatureID string `json:"featureId"`
	// Feature name
	Name string `json:"name"`
	// Feature version
	Version string `json:"version"`
	// Virtual interface assigned
	VirtualInterface *string `json:"virtualInterface,omitempty"`
}

func (FeatureResource) IsResource() {}

func (FeatureResource) IsNode() {}

// Feature runtime state
type FeatureRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Container status
	ContainerStatus *string `json:"containerStatus,omitempty"`
	// Memory usage
	MemoryUsage *Size `json:"memoryUsage,omitempty"`
	// CPU usage percentage
	CPUUsagePercent *float64 `json:"cpuUsagePercent,omitempty"`
	// Devices routed through this feature
	RoutedDevices *int `json:"routedDevices,omitempty"`
}

// Feature support information based on RouterOS version
type FeatureSupport struct {
	// Feature identifier (e.g., 'rest_api', 'container', 'wireguard')
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	Name string `json:"name"`
	// Whether the feature is supported on this router
	Supported bool `json:"supported"`
	// Capability level (none, basic, advanced, full)
	Level CapabilityLevel `json:"level"`
	// Reason why the feature is not supported (if applicable)
	Reason *string `json:"reason,omitempty"`
	// Minimum RouterOS version required for this feature
	RequiredVersion *string `json:"requiredVersion,omitempty"`
	// URL to MikroTik documentation for upgrade guidance
	UpgradeURL *string `json:"upgradeUrl,omitempty"`
	// Required packages that need to be installed
	RequiredPackages []string `json:"requiredPackages,omitempty"`
	// Missing packages (if any)
	MissingPackages []string `json:"missingPackages,omitempty"`
}

// Firewall rule (minimal type for dependencies)
type FirewallRule struct {
	// Firewall rule ID
	ID string `json:"id"`
	// Rule chain
	Chain string `json:"chain"`
	// Rule action
	Action string `json:"action"`
	// Input interface filter
	InInterface *string `json:"inInterface,omitempty"`
	// Output interface filter
	OutInterface *string `json:"outInterface,omitempty"`
	// Whether the rule is disabled
	Disabled bool `json:"disabled"`
}

// Firewall Rule resource
type FirewallRuleResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Rule chain (input, forward, output)
	Chain string `json:"chain"`
	// Rule action (accept, drop, reject)
	Action string `json:"action"`
	// Source address/network
	SrcAddress *string `json:"srcAddress,omitempty"`
	// Destination address/network
	DstAddress *string `json:"dstAddress,omitempty"`
	// Source port(s)
	SrcPort *string `json:"srcPort,omitempty"`
	// Destination port(s)
	DstPort *string `json:"dstPort,omitempty"`
	// Protocol (tcp, udp, icmp, etc.)
	Protocol *string `json:"protocol,omitempty"`
	// Rule comment
	Comment *string `json:"comment,omitempty"`
	// Whether rule is enabled
	Enabled bool `json:"enabled"`
	// Hit counter
	HitCount *int `json:"hitCount,omitempty"`
}

func (FirewallRuleResource) IsResource() {}

func (FirewallRuleResource) IsNode() {}

// Result of checking gateway reachability
type GatewayReachabilityResult struct {
	// Whether the gateway is reachable
	Reachable bool `json:"reachable"`
	// Ping latency in milliseconds (null if unreachable)
	Latency *int `json:"latency,omitempty"`
	// Interface through which gateway is reachable (null if unreachable)
	Interface *string `json:"interface,omitempty"`
	// Human-readable message about reachability
	Message string `json:"message"`
}

// Hardware information detected from router
type HardwareInfo struct {
	// CPU architecture (arm, arm64, x86_64, etc.)
	Architecture string `json:"architecture"`
	// Router model name
	Model *string `json:"model,omitempty"`
	// Board name
	BoardName *string `json:"boardName,omitempty"`
	// Total RAM in bytes
	TotalMemory Size `json:"totalMemory"`
	// Available storage in bytes
	AvailableStorage Size `json:"availableStorage"`
	// Number of CPU cores
	CPUCount int `json:"cpuCount"`
	// Whether wireless hardware is present
	HasWirelessChip bool `json:"hasWirelessChip"`
	// Whether LTE/cellular hardware is present
	HasLTEModule bool `json:"hasLTEModule"`
}

// Health check result for a router
type HealthCheckResult struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Whether the router is healthy
	Healthy bool `json:"healthy"`
	// When the check was performed
	CheckedAt time.Time `json:"checkedAt"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if unhealthy
	Error *string `json:"error,omitempty"`
}

// Overall system health status
type HealthStatus struct {
	// Service status
	Status ServiceStatus `json:"status"`
	// Service version
	Version string `json:"version"`
	// Server uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Connected router count
	ConnectedRouters int `json:"connectedRouters"`
	// Last health check timestamp
	CheckedAt time.Time `json:"checkedAt"`
}

// A single probe result within a hop
type HopProbe struct {
	// Probe number (1-3 typically)
	ProbeNumber int `json:"probeNumber"`
	// Latency in milliseconds (null for timeout)
	LatencyMs *float64 `json:"latencyMs,omitempty"`
	// Whether the probe succeeded
	Success bool `json:"success"`
	// ICMP error code if probe failed
	ICMPCode *string `json:"icmpCode,omitempty"`
}

// Hourly statistics
type HourlyStats struct {
	// Hour start timestamp
	Hour time.Time `json:"hour"`
	// Total bytes in
	TotalBytesIn Size `json:"totalBytesIn"`
	// Total bytes out
	TotalBytesOut Size `json:"totalBytesOut"`
	// Uptime percentage (0-100)
	UptimePercent float64 `json:"uptimePercent"`
	// Error count
	ErrorCount int `json:"errorCount"`
}

// ISP contact information
type ISPInfo struct {
	// ISP name
	Name string `json:"name"`
	// ISP support phone number
	Phone *string `json:"phone,omitempty"`
	// ISP support website URL
	URL *string `json:"url,omitempty"`
}

// Integer range for filtering
type IntRange struct {
	// Minimum value (inclusive)
	Min graphql.Omittable[*int] `json:"min,omitempty"`
	// Maximum value (inclusive)
	Max graphql.Omittable[*int] `json:"max,omitempty"`
}

// A network interface on a router
type Interface struct {
	// Unique interface identifier
	ID string `json:"id"`
	// Interface name (e.g., ether1, wlan1)
	Name string `json:"name"`
	// Interface type
	Type InterfaceType `json:"type"`
	// Whether the interface is enabled
	Enabled bool `json:"enabled"`
	// Whether the interface is running (link up)
	Running bool `json:"running"`
	// MAC address
	MacAddress *MAC `json:"macAddress,omitempty"`
	// MTU setting
	Mtu *int `json:"mtu,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// TX bytes
	TxBytes *Size `json:"txBytes,omitempty"`
	// RX bytes
	RxBytes *Size `json:"rxBytes,omitempty"`
	// IP address assigned to this interface
	IP *IPv4 `json:"ip,omitempty"`
	// Operational status of the interface
	Status InterfaceStatus `json:"status"`
	// Current transmit rate in bytes per second
	TxRate *Size `json:"txRate,omitempty"`
	// Current receive rate in bytes per second
	RxRate *Size `json:"rxRate,omitempty"`
	// Link speed (e.g., 1Gbps, 100Mbps)
	LinkSpeed *string `json:"linkSpeed,omitempty"`
	// Last time this interface was seen/queried
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// Connected device information from LLDP
	LinkPartner *string `json:"linkPartner,omitempty"`
	// Services using this interface (bridge, VPN, etc.)
	UsedBy []string `json:"usedBy,omitempty"`
}

func (Interface) IsNode() {}

type InterfaceConnection struct {
	Edges      []*InterfaceEdge `json:"edges"`
	PageInfo   *PageInfo        `json:"pageInfo"`
	TotalCount *int             `json:"totalCount,omitempty"`
}

func (InterfaceConnection) IsConnection() {}

type InterfaceEdge struct {
	Node   *Interface `json:"node"`
	Cursor string     `json:"cursor"`
}

func (InterfaceEdge) IsEdge() {}

// Error information for a single interface operation in a batch
type InterfaceOperationError struct {
	// Interface ID that failed
	InterfaceID string `json:"interfaceId"`
	// Interface name
	InterfaceName string `json:"interfaceName"`
	// Error message describing why the operation failed
	Error string `json:"error"`
}

// Interface traffic statistics
type InterfaceStats struct {
	// Total bytes transmitted
	TxBytes Size `json:"txBytes"`
	// Total bytes received
	RxBytes Size `json:"rxBytes"`
	// Total packets transmitted
	TxPackets Size `json:"txPackets"`
	// Total packets received
	RxPackets Size `json:"rxPackets"`
	// Transmission errors
	TxErrors int `json:"txErrors"`
	// Receive errors
	RxErrors int `json:"rxErrors"`
	// Transmission drops
	TxDrops int `json:"txDrops"`
	// Receive drops
	RxDrops int `json:"rxDrops"`
}

// Historical interface statistics with time-series data
type InterfaceStatsHistory struct {
	// Interface ID
	InterfaceID string `json:"interfaceId"`
	// Time-series data points
	DataPoints []*StatsDataPoint `json:"dataPoints"`
	// Aggregation interval (e.g., 5m, 1h)
	Interval Duration `json:"interval"`
	// Start of the time range
	StartTime time.Time `json:"startTime"`
	// End of the time range
	EndTime time.Time `json:"endTime"`
}

// Event emitted when an interface status changes
type InterfaceStatusEvent struct {
	// Interface ID
	InterfaceID string `json:"interfaceId"`
	// Interface name
	InterfaceName string `json:"interfaceName"`
	// New status
	Status InterfaceStatus `json:"status"`
	// Previous status
	PreviousStatus InterfaceStatus `json:"previousStatus"`
	// Event timestamp
	Timestamp time.Time `json:"timestamp"`
}

type InterfaceTrafficEvent struct {
	// Interface ID
	InterfaceID string `json:"interfaceId"`
	// Interface name
	InterfaceName string `json:"interfaceName"`
	// TX rate in bytes per second
	TxRate Size `json:"txRate"`
	// RX rate in bytes per second
	RxRate Size `json:"rxRate"`
	// Total TX bytes
	TxTotal Size `json:"txTotal"`
	// Total RX bytes
	RxTotal Size `json:"rxTotal"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// An IP address assigned to an interface
type IPAddress struct {
	// Unique IP address identifier
	ID string `json:"id"`
	// IP address with CIDR notation (e.g., 192.168.10.1/24)
	Address string `json:"address"`
	// Network address (calculated from address and netmask)
	Network *string `json:"network,omitempty"`
	// Broadcast address (calculated from address and netmask)
	Broadcast *string `json:"broadcast,omitempty"`
	// Interface this IP is assigned to
	Interface *Interface `json:"interface"`
	// Whether this IP is disabled
	Disabled bool `json:"disabled"`
	// Whether this IP was dynamically assigned (via DHCP client)
	Dynamic bool `json:"dynamic"`
	// Whether this IP is invalid (conflicting or error state)
	Invalid bool `json:"invalid"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (IPAddress) IsNode() {}

// Event emitted when an IP address changes
type IPAddressChangeEvent struct {
	// Type of change (CREATED, UPDATED, DELETED)
	ChangeType ChangeType `json:"changeType"`
	// The IP address that changed
	IPAddress *IPAddress `json:"ipAddress,omitempty"`
	// IP address ID (for deletions)
	IPAddressID string `json:"ipAddressId"`
	// Timestamp of the change
	Timestamp time.Time `json:"timestamp"`
}

// Result of an IP address deletion with dependency checking
type IPAddressDeleteResult struct {
	// Whether the deletion succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// Impact analysis for this IP address deletion
	ImpactAnalysis *IPAddressImpactAnalysis `json:"impactAnalysis,omitempty"`
	// Errors that occurred during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

// Dependencies for an IP address
type IPAddressDependencies struct {
	// IP address ID
	IPAddressID string `json:"ipAddressId"`
	// DHCP servers using this IP as gateway
	DhcpServers []*DhcpServer `json:"dhcpServers"`
	// Static routes using this IP
	Routes []*Route `json:"routes"`
	// NAT rules referencing this IP
	NatRules []*NatRule `json:"natRules"`
	// Firewall rules referencing this IP
	FirewallRules []*FirewallRule `json:"firewallRules"`
	// Whether the IP has any dependencies
	HasDependencies bool `json:"hasDependencies"`
}

// Analysis of the impact of deleting an IP address
type IPAddressImpactAnalysis struct {
	// Whether this IP is used as a gateway by DHCP servers
	UsedByDhcpServers []*DhcpServer `json:"usedByDhcpServers"`
	// Whether this IP is referenced in firewall rules
	UsedInFirewallRules []*FirewallRule `json:"usedInFirewallRules"`
	// Whether this IP is used in NAT rules
	UsedInNatRules []*NatRule `json:"usedInNatRules"`
	// Number of active connections using this IP
	ActiveConnections int `json:"activeConnections"`
	// Severity of the deletion
	Severity ConfirmationSeverity `json:"severity"`
	// Human-readable impact message
	Message string `json:"message"`
	// List of consequences of deleting this IP
	Consequences []string `json:"consequences"`
	// Whether the IP can be safely deleted
	CanDelete bool `json:"canDelete"`
}

// Input for creating or updating an IP address
type IPAddressInput struct {
	// IP address with CIDR notation (e.g., 192.168.10.1/24)
	Address string `json:"address"`
	// Interface ID to assign this IP to
	InterfaceID string `json:"interfaceId"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
	// Whether this IP is disabled
	Disabled graphql.Omittable[*bool] `json:"disabled,omitempty"`
}

// Result of an IP address mutation (create, update)
type IPAddressMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The created or updated IP address (if successful)
	IPAddress *IPAddress `json:"ipAddress,omitempty"`
	// Configuration preview (RouterOS commands)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Errors that occurred during the operation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Details about an IP address conflict
type IPConflict struct {
	// Conflicting IP address ID
	ID string `json:"id"`
	// Conflicting IP address
	Address string `json:"address"`
	// Interface where conflict exists
	Interface *Interface `json:"interface"`
	// Type of conflict
	ConflictType IPConflictType `json:"conflictType"`
	// Explanation of the conflict
	Explanation string `json:"explanation"`
}

// Result of checking IP address conflicts
type IPConflictResult struct {
	// Whether the IP conflicts with existing assignments
	HasConflict bool `json:"hasConflict"`
	// List of conflicting IP addresses
	Conflicts []*IPConflict `json:"conflicts"`
	// Human-readable message
	Message string `json:"message"`
}

// LAN Network composite resource - groups bridge, DHCP, firewall, routing
type LANNetwork struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration,omitempty"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	Config        *LANNetworkConfig      `json:"config"`
	LanDeployment *LANNetworkDeployment  `json:"lanDeployment,omitempty"`
	LanRuntime    *LANNetworkRuntime     `json:"lanRuntime,omitempty"`
	// Bridge interface
	Bridge *BridgeResource `json:"bridge,omitempty"`
	// DHCP server configuration
	DhcpServer *DHCPServerResource `json:"dhcpServer,omitempty"`
	// Firewall rules for this LAN
	FirewallRules []*FirewallRuleResource `json:"firewallRules"`
	// Static routes
	Routes []*RouteResource `json:"routes"`
}

func (LANNetwork) IsResource() {}

func (LANNetwork) IsNode() {}

// LAN Network configuration
type LANNetworkConfig struct {
	// Network name
	Name string `json:"name"`
	// IP address for the LAN
	IPAddress IPv4 `json:"ipAddress"`
	// Subnet mask in CIDR notation
	SubnetMask int `json:"subnetMask"`
	// Interfaces to include in bridge
	Interfaces []string `json:"interfaces"`
	// Enable DHCP server
	DhcpEnabled bool `json:"dhcpEnabled"`
	// DHCP pool start
	DhcpPoolStart *IPv4 `json:"dhcpPoolStart,omitempty"`
	// DHCP pool end
	DhcpPoolEnd *IPv4 `json:"dhcpPoolEnd,omitempty"`
	// DHCP lease time
	DhcpLeaseTime *Duration `json:"dhcpLeaseTime,omitempty"`
	// DNS servers for DHCP
	DNSServers []IPv4 `json:"dnsServers,omitempty"`
	// Enable NAT masquerading
	EnableNat bool `json:"enableNat"`
	// VLAN ID (optional)
	VlanID *int `json:"vlanId,omitempty"`
}

// LAN Network deployment state
type LANNetworkDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Bridge interface ID on router
	BridgeID *string `json:"bridgeId,omitempty"`
	// DHCP server ID on router
	DhcpServerID *string `json:"dhcpServerId,omitempty"`
	// IP address ID on router
	IPAddressID *string `json:"ipAddressId,omitempty"`
}

// LAN Network runtime state
type LANNetworkRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Number of active clients
	ActiveClients int `json:"activeClients"`
	// Active DHCP leases
	DhcpLeases int `json:"dhcpLeases"`
	// Total traffic in
	TotalBytesIn Size `json:"totalBytesIn"`
	// Total traffic out
	TotalBytesOut Size `json:"totalBytesOut"`
}

// LTE/cellular modem configuration
type LteModem struct {
	// Unique identifier
	ID string `json:"id"`
	// LTE interface name
	Name string `json:"name"`
	// APN (Access Point Name)
	Apn string `json:"apn"`
	// Signal strength (RSSI in dBm)
	SignalStrength *int `json:"signalStrength,omitempty"`
	// Connection status
	Running bool `json:"running"`
	// Operator name
	Operator *string `json:"operator,omitempty"`
	// Network type (LTE, 3G, etc.)
	NetworkType *string `json:"networkType,omitempty"`
	// PIN code configured
	PinConfigured bool `json:"pinConfigured"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (LteModem) IsNode() {}

// Input for configuring LTE modem
type LteModemInput struct {
	// LTE interface name
	Name string `json:"name"`
	// APN (Access Point Name)
	Apn string `json:"apn"`
	// PIN code (optional, for SIM card)
	Pin graphql.Omittable[*string] `json:"pin,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Memory utilization metrics
type MemoryMetrics struct {
	// Used memory in bytes
	Used float64 `json:"used"`
	// Total memory in bytes
	Total float64 `json:"total"`
	// Memory usage percentage (0-100)
	Percentage float64 `json:"percentage"`
}

// Missing dependency information
type MissingDependency struct {
	// Item ID with missing dependency
	ItemID string `json:"itemId"`
	// Missing resource type
	MissingResourceType string `json:"missingResourceType"`
	// Missing resource ID
	MissingResourceID string `json:"missingResourceId"`
}

type Mutation struct {
}

// Standard error type for mutations
type MutationError struct {
	// Error code for programmatic handling
	Code string `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Field that caused the error (if applicable)
	Field *string `json:"field,omitempty"`
}

// NAT rule reference type
type NatRule struct {
	// NAT rule ID
	ID string `json:"id"`
	// Rule chain (srcnat, dstnat)
	Chain string `json:"chain"`
	// Action (masquerade, dst-nat, src-nat)
	Action string `json:"action"`
	// Source address
	SrcAddress *string `json:"srcAddress,omitempty"`
	// Destination address
	DstAddress *string `json:"dstAddress,omitempty"`
	// To address (for dst-nat)
	ToAddress *string `json:"toAddress,omitempty"`
	// Whether the rule is disabled
	Disabled bool `json:"disabled"`
}

// Network configuration detection result
type NetworkConfigDetection struct {
	// Detected WAN interface name
	WanInterface string `json:"wanInterface"`
	// Detected default gateway IP
	Gateway *string `json:"gateway,omitempty"`
	// Detected ISP information
	IspInfo *ISPInfo `json:"ispInfo,omitempty"`
}

// Operation counts by type
type OperationCounts struct {
	Create int `json:"create"`
	Update int `json:"update"`
	Delete int `json:"delete"`
}

// Information about pagination in a connection
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// Cursor for the first edge
	StartCursor *string `json:"startCursor,omitempty"`
	// Cursor for the last edge
	EndCursor *string `json:"endCursor,omitempty"`
}

// Standard pagination input arguments
type PaginationInput struct {
	// Number of items to fetch
	First graphql.Omittable[*int] `json:"first,omitempty"`
	// Cursor to fetch items after
	After graphql.Omittable[*string] `json:"after,omitempty"`
	// Number of items to fetch from the end
	Last graphql.Omittable[*int] `json:"last,omitempty"`
	// Cursor to fetch items before
	Before graphql.Omittable[*string] `json:"before,omitempty"`
}

// Platform capabilities for a resource type
type PlatformCapabilities struct {
	// Whether this resource type is supported
	IsSupported bool `json:"isSupported"`
	// Capability level
	Level CapabilityLevel `json:"level"`
	// Minimum platform version required
	MinVersion *string `json:"minVersion,omitempty"`
	// Required packages
	RequiredPackages []string `json:"requiredPackages,omitempty"`
	// Capability-specific details
	Details map[string]interface{} `json:"details,omitempty"`
}

// A platform-specific feature
type PlatformFeature struct {
	// Feature identifier
	ID string `json:"id"`
	// Feature name
	Name string `json:"name"`
	// Whether feature is enabled
	Enabled bool `json:"enabled"`
	// Feature description
	Description *string `json:"description,omitempty"`
}

// Layer 8: Platform-specific capabilities and field mappings.
// From platform adapter (MikroTik, OpenWrt, VyOS).
type PlatformInfo struct {
	// Current platform
	Current RouterPlatform `json:"current"`
	// Platform-specific capabilities for this resource type
	Capabilities *PlatformCapabilities `json:"capabilities"`
	// Field mappings between GraphQL and platform-native names
	FieldMappings map[string]interface{} `json:"fieldMappings,omitempty"`
	// Platform-specific limitations or constraints
	Limitations []*PlatformLimitation `json:"limitations,omitempty"`
	// Platform-specific features available
	Features []*PlatformFeature `json:"features,omitempty"`
}

// A platform-specific limitation
type PlatformLimitation struct {
	// Limitation identifier
	Code string `json:"code"`
	// Human-readable description
	Description string `json:"description"`
	// Affected fields
	AffectedFields []string `json:"affectedFields,omitempty"`
	// Workaround if available
	Workaround *string `json:"workaround,omitempty"`
}

// Status of a single port check
type PortStatus struct {
	// Port number checked
	Port int `json:"port"`
	// Service name (API, API-SSL, SSH, Telnet, HTTP, HTTPS)
	Service string `json:"service"`
	// Whether the port is open and accepting connections
	Open bool `json:"open"`
	// Response time in milliseconds (if port is open)
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message (if port is closed)
	Error *string `json:"error,omitempty"`
}

// PPPoE client configuration for dial-up WAN
type PppoeClient struct {
	// Unique identifier
	ID string `json:"id"`
	// PPPoE interface name
	Name string `json:"name"`
	// Underlying interface (ethernet/bridge)
	Interface string `json:"interface"`
	// Whether PPPoE is disabled
	Disabled bool `json:"disabled"`
	// Username for authentication
	Username string `json:"username"`
	// Service name (optional)
	ServiceName *string `json:"serviceName,omitempty"`
	// Add default route
	AddDefaultRoute bool `json:"addDefaultRoute"`
	// Use peer DNS
	UsePeerDNS bool `json:"usePeerDNS"`
	// Current connection status
	Running bool `json:"running"`
	// MTU setting
	Mtu *int `json:"mtu,omitempty"`
	// MRU setting
	Mru *int `json:"mru,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (PppoeClient) IsNode() {}

// Input for creating/updating PPPoE client
type PppoeClientInput struct {
	// PPPoE interface name
	Name string `json:"name"`
	// Physical interface (ether1, bridge, etc.)
	Interface string `json:"interface"`
	// Username for ISP authentication
	Username string `json:"username"`
	// Password for ISP authentication
	Password string `json:"password"`
	// Service name (optional, ISP-specific)
	ServiceName graphql.Omittable[*string] `json:"serviceName,omitempty"`
	// Add default route (default: true)
	AddDefaultRoute graphql.Omittable[*bool] `json:"addDefaultRoute,omitempty"`
	// Use peer DNS (default: true)
	UsePeerDNS graphql.Omittable[*bool] `json:"usePeerDNS,omitempty"`
	// MTU (default: auto)
	Mtu graphql.Omittable[*int] `json:"mtu,omitempty"`
	// MRU (default: auto)
	Mru graphql.Omittable[*int] `json:"mru,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

type Query struct {
}

// Quiet hours configuration
type QuietHoursConfig struct {
	// Start time in HH:MM format
	StartTime string `json:"startTime"`
	// End time in HH:MM format
	EndTime string `json:"endTime"`
	// Timezone (IANA timezone database name)
	Timezone string `json:"timezone"`
	// Whether critical alerts bypass quiet hours
	BypassCritical bool `json:"bypassCritical"`
}

// Quiet hours configuration input
type QuietHoursConfigInput struct {
	// Start time in HH:MM format
	StartTime string `json:"startTime"`
	// End time in HH:MM format
	EndTime string `json:"endTime"`
	// Timezone (default: UTC)
	Timezone graphql.Omittable[*string] `json:"timezone,omitempty"`
	// Whether critical alerts bypass quiet hours (default: true)
	BypassCritical graphql.Omittable[*bool] `json:"bypassCritical,omitempty"`
}

type ReconnectRouterPayload struct {
	// The router being reconnected
	Router *Router `json:"router,omitempty"`
	// Updated connection details
	ConnectionDetails *ConnectionDetails `json:"connectionDetails,omitempty"`
	// Whether reconnection was initiated
	Initiated bool `json:"initiated"`
	// Rate limit wait time if rate limited
	WaitTimeMs *int `json:"waitTimeMs,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Payload for refreshCapabilities mutation
type RefreshCapabilitiesPayload struct {
	// Updated capabilities after refresh
	Capabilities *RouterCapabilities `json:"capabilities,omitempty"`
	// Errors during refresh
	Errors []*MutationError `json:"errors,omitempty"`
}

type RemoveChangeSetItemPayload struct {
	// The updated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Conflict with another resource
type ResourceConflict struct {
	// Type of conflict
	Type ConflictType `json:"type"`
	// The conflicting resource
	ConflictingResource Resource `json:"conflictingResource,omitempty"`
	// Conflicting resource UUID (if resource is not loaded)
	ConflictingResourceUUID string `json:"conflictingResourceUuid"`
	// Description of the conflict
	Description string `json:"description"`
	// Suggested resolution
	Resolution *string `json:"resolution,omitempty"`
}

type ResourceConnection struct {
	Edges      []*ResourceEdge `json:"edges"`
	PageInfo   *PageInfo       `json:"pageInfo"`
	TotalCount *int            `json:"totalCount,omitempty"`
}

func (ResourceConnection) IsConnection() {}

type ResourceEdge struct {
	Cursor string   `json:"cursor"`
	Node   Resource `json:"node"`
}

func (ResourceEdge) IsEdge() {}

// Layer 6: Resource lifecycle info, tags, ownership.
// System-managed with some user-editable fields.
type ResourceMetadata struct {
	// Resource creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// User who created the resource
	CreatedBy string `json:"createdBy"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// User who last updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
	// Current lifecycle state
	State ResourceLifecycleState `json:"state"`
	// Optimistic locking version
	Version int `json:"version"`
	// User-defined tags for organization
	Tags []string `json:"tags"`
	// Resource description
	Description *string `json:"description,omitempty"`
	// Whether resource is marked as favorite
	IsFavorite bool `json:"isFavorite"`
	// Whether resource is pinned
	IsPinned bool `json:"isPinned"`
	// Custom user notes
	Notes *string `json:"notes,omitempty"`
	// Audit trail of recent changes
	RecentChanges []*ChangeLogEntry `json:"recentChanges,omitempty"`
}

// Real-time resource utilization metrics for a device
type ResourceMetrics struct {
	// CPU utilization metrics
	CPU *CPUMetrics `json:"cpu"`
	// Memory utilization metrics
	Memory *MemoryMetrics `json:"memory"`
	// Storage utilization metrics
	Storage *StorageMetrics `json:"storage"`
	// Temperature in Celsius (null if not supported)
	Temperature *float64 `json:"temperature,omitempty"`
	// Timestamp when metrics were collected
	Timestamp time.Time `json:"timestamp"`
}

// Reference to another resource
type ResourceReference struct {
	// Resource UUID
	UUID string `json:"uuid"`
	// Resource scoped ID
	ID string `json:"id"`
	// Resource type
	Type string `json:"type"`
	// Resource category
	Category ResourceCategory `json:"category"`
	// Current lifecycle state
	State ResourceLifecycleState `json:"state"`
}

// Edge in the resource relationship graph
type ResourceRelationshipEdge struct {
	// Source resource ID
	From string `json:"from"`
	// Target resource ID
	To string `json:"to"`
	// Relationship type
	Type ResourceRelationshipType `json:"type"`
}

// Layer 7: Dependencies and relationships between resources.
// Combines user-defined relationships and system-discovered dependencies.
type ResourceRelationships struct {
	// Resources this resource depends on
	DependsOn []*ResourceReference `json:"dependsOn"`
	// Resources that depend on this resource
	Dependents []*ResourceReference `json:"dependents"`
	// Resource this routes traffic via
	RoutesVia *ResourceReference `json:"routesVia,omitempty"`
	// Resources that route traffic via this resource
	RoutedBy []*ResourceReference `json:"routedBy"`
	// Parent resource (for hierarchical resources)
	Parent *ResourceReference `json:"parent,omitempty"`
	// Child resources (for hierarchical resources)
	Children []*ResourceReference `json:"children"`
	// Custom relationships
	Custom map[string]interface{} `json:"custom,omitempty"`
}

// Input for resource relationships
type ResourceRelationshipsInput struct {
	// Resources this resource depends on (IDs)
	DependsOn graphql.Omittable[[]string] `json:"dependsOn,omitempty"`
	// Resources that route traffic via this resource (ID)
	RoutesVia graphql.Omittable[*string] `json:"routesVia,omitempty"`
	// Parent resource ID (for hierarchical resources)
	Parent graphql.Omittable[*string] `json:"parent,omitempty"`
	// Custom relationship data
	Custom graphql.Omittable[map[string]interface{}] `json:"custom,omitempty"`
}

// Runtime update event for a resource
type ResourceRuntimeEvent struct {
	// Resource ID (ULID)
	ID string `json:"id"`
	// Resource type
	Type string `json:"type"`
	// Updated runtime state
	Runtime *RuntimeState `json:"runtime"`
	// Timestamp of update
	Timestamp time.Time `json:"timestamp"`
}

// Lifecycle state change event
type ResourceStateEvent struct {
	// Resource ID (ULID)
	ID string `json:"id"`
	// Resource type
	Type string `json:"type"`
	// Previous state
	PreviousState ResourceLifecycleState `json:"previousState"`
	// New state
	NewState ResourceLifecycleState `json:"newState"`
	// Error message if state is ERROR
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Timestamp of change
	Timestamp time.Time `json:"timestamp"`
}

// Event emitted when a router resource is updated
type ResourceUpdatedEvent struct {
	// Unique resource identifier
	ResourceID string `json:"resourceId"`
	// Type of resource (interface, firewall-rule, dhcp-lease, etc.)
	ResourceType string `json:"resourceType"`
	// Router this resource belongs to
	RouterID string `json:"routerId"`
	// New version number after update
	Version int `json:"version"`
	// Fields that were changed
	ChangedFields []string `json:"changedFields"`
	// Type of change (create, update, delete)
	ChangeType ChangeType `json:"changeType"`
	// Timestamp of the update
	Timestamp time.Time `json:"timestamp"`
}

type RollbackChangeSetPayload struct {
	// The rolled back change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Whether rollback was successful
	Success bool `json:"success"`
	// Items that failed to rollback
	FailedItems []string `json:"failedItems,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Rollback step for recovery
type RollbackStep struct {
	// Item ID being rolled back
	ItemID string `json:"itemId"`
	// Rollback operation
	Operation RollbackOperation `json:"operation"`
	// State to restore
	RestoreState map[string]interface{} `json:"restoreState,omitempty"`
	// Resource UUID on router
	ResourceUUID *string `json:"resourceUuid,omitempty"`
	// Whether rollback succeeded
	Success bool `json:"success"`
	// Error message if failed
	Error *string `json:"error,omitempty"`
	// Order in rollback sequence
	RollbackOrder int `json:"rollbackOrder"`
}

// Route type for static and dynamic routing
type Route struct {
	// Route ID
	ID string `json:"id"`
	// Destination network in CIDR notation
	Destination CIDR `json:"destination"`
	// Gateway address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Interface used for this route
	Interface *string `json:"interface,omitempty"`
	// Route distance/metric (1-255)
	Distance int `json:"distance"`
	// Routing mark for policy routing
	RoutingMark *string `json:"routingMark,omitempty"`
	// Routing table name (main, vpn, etc.)
	RoutingTable *string `json:"routingTable,omitempty"`
	// Route type (static, connected, dynamic, BGP, OSPF)
	Type RouteType `json:"type"`
	// Route scope
	Scope RouteScope `json:"scope"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// Whether the route is active
	Active bool `json:"active"`
	// Whether the route is disabled
	Disabled *bool `json:"disabled,omitempty"`
}

func (Route) IsNode() {}

// Result of a route deletion with impact analysis
type RouteDeleteResult struct {
	// Whether the deletion succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// Impact analysis for this route deletion
	ImpactAnalysis *RouteImpactAnalysis `json:"impactAnalysis"`
}

// Analysis of the impact of deleting a route
type RouteImpactAnalysis struct {
	// Whether this is the default route (0.0.0.0/0)
	IsDefaultRoute bool `json:"isDefaultRoute"`
	// Description of affected traffic
	AffectedTraffic string `json:"affectedTraffic"`
	// Severity of the deletion (CRITICAL for default route, STANDARD for others)
	Severity ConfirmationSeverity `json:"severity"`
	// Human-readable message about the impact
	Message string `json:"message"`
	// List of consequences of deleting this route
	Consequences []string `json:"consequences"`
}

// Input for creating or updating a route
type RouteInput struct {
	// Destination network in CIDR notation
	Destination CIDR `json:"destination"`
	// Gateway address (optional if interface is provided)
	Gateway graphql.Omittable[*IPv4] `json:"gateway,omitempty"`
	// Interface used for this route (optional if gateway is provided)
	Interface graphql.Omittable[*string] `json:"interface,omitempty"`
	// Route distance/metric (1-255, default: 1)
	Distance graphql.Omittable[*int] `json:"distance,omitempty"`
	// Routing mark for policy routing
	RoutingMark graphql.Omittable[*string] `json:"routingMark,omitempty"`
	// Routing table name (default: main)
	RoutingTable graphql.Omittable[*string] `json:"routingTable,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Result of a route mutation (create, update)
type RouteMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// The created or updated route (if successful)
	Route *Route `json:"route,omitempty"`
}

// Route resource
type RouteResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Destination network
	DstAddress CIDR `json:"dstAddress"`
	// Gateway address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Outgoing interface
	Interface *string `json:"interface,omitempty"`
	// Route distance/metric
	Distance *int `json:"distance,omitempty"`
	// Whether route is active
	Active bool `json:"active"`
}

func (RouteResource) IsResource() {}

func (RouteResource) IsNode() {}

// A managed router device
type Router struct {
	// Unique router identifier
	ID string `json:"id"`
	// User-friendly display name
	Name string `json:"name"`
	// Router hostname or IP address
	Host string `json:"host"`
	// Connection port
	Port int `json:"port"`
	// Current connection status
	Status ConnectionStatus `json:"status"`
	// Router platform type
	Platform RouterPlatform `json:"platform"`
	// RouterOS version (if connected)
	Version *string `json:"version,omitempty"`
	// Router model
	Model *string `json:"model,omitempty"`
	// System uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Last successful connection time
	LastConnected *time.Time `json:"lastConnected,omitempty"`
	// When the router was added to NasNet
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// Detected router capabilities (requires connection)
	Capabilities *RouterCapabilities `json:"capabilities,omitempty"`
}

func (Router) IsNode() {}

// Event emitted when a new router is added.
type RouterAddedEvent struct {
	// The newly added router
	Router *Router `json:"router"`
	// Protocol used for initial connection
	ProtocolUsed Protocol `json:"protocolUsed"`
	// User who added the router (if authenticated)
	AddedBy *string `json:"addedBy,omitempty"`
	// Timestamp of addition
	Timestamp time.Time `json:"timestamp"`
}

// Complete router capabilities detected from system inspection
type RouterCapabilities struct {
	// Hardware information
	Hardware *HardwareInfo `json:"hardware"`
	// Software information
	Software *SoftwareInfo `json:"software"`
	// Container-specific capabilities
	Container *ContainerInfo `json:"container"`
	// Capability entries with support levels
	Capabilities []*CapabilityEntry `json:"capabilities"`
	// VIF requirements check
	VifRequirements *VIFRequirements `json:"vifRequirements"`
	// Features supported by this router's version and configuration
	SupportedFeatures []*FeatureSupport `json:"supportedFeatures"`
	// Features not supported by this router (with upgrade guidance)
	UnsupportedFeatures []*FeatureSupport `json:"unsupportedFeatures"`
	// Parsed RouterOS version with comparison helpers
	RouterOSVersion *RouterOSVersion `json:"routerOSVersion"`
	// When capabilities were detected
	DetectedAt time.Time `json:"detectedAt"`
	// When cache expires (24h TTL)
	ExpiresAt time.Time `json:"expiresAt"`
	// Whether cache is stale and refresh is in progress
	IsRefreshing bool `json:"isRefreshing"`
}

type RouterConnection struct {
	Edges      []*RouterEdge `json:"edges"`
	PageInfo   *PageInfo     `json:"pageInfo"`
	TotalCount *int          `json:"totalCount,omitempty"`
}

func (RouterConnection) IsConnection() {}

// Router credential information (non-sensitive).
// Password is never included - only metadata about credentials.
type RouterCredentials struct {
	// Router ID these credentials belong to
	RouterID string `json:"routerId"`
	// Username for router authentication
	Username string `json:"username"`
	// Whether a password is stored
	HasPassword bool `json:"hasPassword"`
	// Encryption algorithm used (always 'AES-256-GCM')
	EncryptionStatus string `json:"encryptionStatus"`
	// Encryption key version (for rotation tracking)
	KeyVersion int `json:"keyVersion"`
	// When credentials were last updated
	LastUpdated time.Time `json:"lastUpdated"`
	// When credentials were first created
	CreatedAt time.Time `json:"createdAt"`
}

type RouterEdge struct {
	Node   *Router `json:"node"`
	Cursor string  `json:"cursor"`
}

func (RouterEdge) IsEdge() {}

// Information about a discovered RouterOS device
type RouterOSInfo struct {
	// RouterOS version string (e.g., '7.12', '6.49.8')
	Version *string `json:"version,omitempty"`
	// Router board name (e.g., 'hAP ac', 'CCR2004-1G-12S+2XS')
	BoardName *string `json:"boardName,omitempty"`
	// CPU architecture (e.g., 'arm', 'x86', 'mips')
	Architecture *string `json:"architecture,omitempty"`
	// Platform identifier
	Platform *string `json:"platform,omitempty"`
}

// Parsed RouterOS version with semantic versioning
type RouterOSVersion struct {
	// Full version string (e.g., '7.13.2')
	Raw string `json:"raw"`
	// Major version number
	Major int `json:"major"`
	// Minor version number
	Minor int `json:"minor"`
	// Patch version number
	Patch int `json:"patch"`
	// Version channel (stable, beta, rc, long-term)
	Channel *string `json:"channel,omitempty"`
	// Whether this is a Cloud Hosted Router (CHR)
	IsChr bool `json:"isCHR"`
	// Check if this version supports a specific feature
	SupportsFeature bool `json:"supportsFeature"`
	// Check if version is at least the given version (e.g., '7.1')
	IsAtLeast bool `json:"isAtLeast"`
}

type RouterStatusEvent struct {
	// The router whose status changed
	Router *Router `json:"router"`
	// Previous status
	PreviousStatus ConnectionStatus `json:"previousStatus"`
	// New status
	NewStatus ConnectionStatus `json:"newStatus"`
	// Timestamp of the change
	Timestamp time.Time `json:"timestamp"`
}

// Result of running a diagnostic step
type RunTroubleshootStepPayload struct {
	// Updated step with result
	Step *TroubleshootStep `json:"step"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Resource-specific runtime metrics
type RuntimeMetrics struct {
	// Bytes received
	BytesIn *Size `json:"bytesIn,omitempty"`
	// Bytes transmitted
	BytesOut *Size `json:"bytesOut,omitempty"`
	// Packets received
	PacketsIn *int `json:"packetsIn,omitempty"`
	// Packets transmitted
	PacketsOut *int `json:"packetsOut,omitempty"`
	// Error count
	Errors *int `json:"errors,omitempty"`
	// Drops count
	Drops *int `json:"drops,omitempty"`
	// Current throughput in (bytes/sec)
	ThroughputIn *Size `json:"throughputIn,omitempty"`
	// Current throughput out (bytes/sec)
	ThroughputOut *Size `json:"throughputOut,omitempty"`
	// Resource-specific custom metrics
	Custom map[string]interface{} `json:"custom,omitempty"`
}

// Layer 4: Live operational state polled/streamed from router.
// Updated via polling (5-60s interval) or WebSocket push.
type RuntimeState struct {
	// Whether the resource is currently running/active
	IsRunning bool `json:"isRunning"`
	// Health status of the resource
	Health RuntimeHealth `json:"health"`
	// Error message if resource is unhealthy
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Resource-specific runtime metrics
	Metrics *RuntimeMetrics `json:"metrics,omitempty"`
	// Last time runtime was updated
	LastUpdated time.Time `json:"lastUpdated"`
	// Time since last successful operation
	LastSuccessfulOperation *time.Time `json:"lastSuccessfulOperation,omitempty"`
	// Current peers/connections (for VPN, etc.)
	ActiveConnections *int `json:"activeConnections,omitempty"`
	// Resource uptime
	Uptime *Duration `json:"uptime,omitempty"`
}

// Input for starting a network scan
type ScanNetworkInput struct {
	// Target subnet in CIDR notation (e.g., '192.168.88.0/24') or IP range (e.g., '192.168.1.1-192.168.1.100')
	Subnet string `json:"subnet"`
}

type ScanNetworkPayload struct {
	// The created scan task
	Task *ScanTask `json:"task,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Real-time progress event for scan subscriptions
type ScanProgressEvent struct {
	// Task ID this event belongs to
	TaskID string `json:"taskId"`
	// Current progress percentage (0-100)
	Progress int `json:"progress"`
	// Number of MikroTik devices found so far
	DevicesFound int `json:"devicesFound"`
	// IP address currently being scanned
	CurrentIP *string `json:"currentIP,omitempty"`
	// Current scan status
	Status ScanStatus `json:"status"`
	// Timestamp of this progress update
	Timestamp time.Time `json:"timestamp"`
}

// A network scan task that tracks scan progress and results.
// Scans are asynchronous - start with mutation, poll/subscribe for progress.
type ScanTask struct {
	// Unique task identifier
	ID string `json:"id"`
	// Target subnet (CIDR notation, IP range, or gateway scan indicator)
	Subnet string `json:"subnet"`
	// Current scan status
	Status ScanStatus `json:"status"`
	// Scan progress percentage (0-100)
	Progress int `json:"progress"`
	// Discovered devices (populated as scan progresses)
	Results []*DiscoveredDevice `json:"results"`
	// When the scan was started
	StartTime time.Time `json:"startTime"`
	// When the scan completed (null if still running)
	EndTime *time.Time `json:"endTime,omitempty"`
	// Error message if scan failed
	Error *string `json:"error,omitempty"`
	// Total IPs to scan (for progress calculation)
	TotalIPs *int `json:"totalIPs,omitempty"`
	// Number of IPs scanned so far
	ScannedIPs *int `json:"scannedIPs,omitempty"`
}

type SetPreferredProtocolPayload struct {
	// The updated router
	Router *Router `json:"router,omitempty"`
	// Updated connection details
	ConnectionDetails *ConnectionDetails `json:"connectionDetails,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Software information detected from router
type SoftwareInfo struct {
	// RouterOS version string
	Version string `json:"version"`
	// Parsed major version number
	VersionMajor int `json:"versionMajor"`
	// Parsed minor version number
	VersionMinor int `json:"versionMinor"`
	// Parsed patch version number
	VersionPatch *int `json:"versionPatch,omitempty"`
	// List of installed packages
	InstalledPackages []string `json:"installedPackages"`
	// License level (0-6)
	LicenseLevel int `json:"licenseLevel"`
	// Update channel (stable, testing, development)
	UpdateChannel *string `json:"updateChannel,omitempty"`
}

// Result of starting a troubleshooting session
type StartTroubleshootPayload struct {
	// The created session
	Session *TroubleshootSession `json:"session,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Static IP WAN configuration
type StaticIPConfig struct {
	// Unique identifier
	ID string `json:"id"`
	// Interface name
	Interface string `json:"interface"`
	// Static IP address with CIDR
	Address CIDR `json:"address"`
	// Gateway IP address
	Gateway IPv4 `json:"gateway"`
	// Primary DNS server
	PrimaryDNS *IPv4 `json:"primaryDNS,omitempty"`
	// Secondary DNS server
	SecondaryDNS *IPv4 `json:"secondaryDNS,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (StaticIPConfig) IsNode() {}

// Input for configuring static IP WAN
type StaticIPInput struct {
	// Interface to configure
	Interface string `json:"interface"`
	// Static IP address with CIDR (e.g., 203.0.113.5/30)
	Address CIDR `json:"address"`
	// Gateway IP address
	Gateway IPv4 `json:"gateway"`
	// Primary DNS server
	PrimaryDNS graphql.Omittable[*IPv4] `json:"primaryDNS,omitempty"`
	// Secondary DNS server
	SecondaryDNS graphql.Omittable[*IPv4] `json:"secondaryDNS,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// A single data point in interface statistics history
type StatsDataPoint struct {
	// Timestamp of the data point
	Timestamp time.Time `json:"timestamp"`
	// Transmit rate in bytes per second
	TxBytesPerSec float64 `json:"txBytesPerSec"`
	// Receive rate in bytes per second
	RxBytesPerSec float64 `json:"rxBytesPerSec"`
	// Transmit rate in packets per second
	TxPacketsPerSec float64 `json:"txPacketsPerSec"`
	// Receive rate in packets per second
	RxPacketsPerSec float64 `json:"rxPacketsPerSec"`
	// Transmission errors in this interval
	TxErrors int `json:"txErrors"`
	// Receive errors in this interval
	RxErrors int `json:"rxErrors"`
}

// Input for specifying a time range
type StatsTimeRangeInput struct {
	// Start of the time range
	Start time.Time `json:"start"`
	// End of the time range
	End time.Time `json:"end"`
}

// Storage utilization metrics
type StorageMetrics struct {
	// Used storage in bytes
	Used float64 `json:"used"`
	// Total storage in bytes
	Total float64 `json:"total"`
	// Storage usage percentage (0-100)
	Percentage float64 `json:"percentage"`
}

type Subscription struct {
}

// TLS certificate status for secure connections
type TLSStatus struct {
	// Whether the certificate is valid
	Valid bool `json:"valid"`
	// Certificate issuer
	Issuer *string `json:"issuer,omitempty"`
	// Certificate subject
	Subject *string `json:"subject,omitempty"`
	// Certificate expiration date
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// Error message (if certificate is invalid)
	Error *string `json:"error,omitempty"`
}

// Layer 5: Time-series metrics and historical data.
// Collected over time for analytics and trending.
type TelemetryData struct {
	// Bandwidth history (last 24h)
	BandwidthHistory []*BandwidthDataPoint `json:"bandwidthHistory,omitempty"`
	// Uptime history (availability)
	UptimeHistory []*UptimeDataPoint `json:"uptimeHistory,omitempty"`
	// Hourly statistics
	HourlyStats []*HourlyStats `json:"hourlyStats,omitempty"`
	// Daily statistics
	DailyStats []*DailyStats `json:"dailyStats,omitempty"`
	// First data point timestamp
	DataStartedAt *time.Time `json:"dataStartedAt,omitempty"`
	// Last data point timestamp
	LastUpdatedAt *time.Time `json:"lastUpdatedAt,omitempty"`
	// Data retention period
	RetentionDays int `json:"retentionDays"`
}

// Result of testing all router credentials.
type TestAllCredentialsPayload struct {
	// Total number of routers tested
	TotalRouters int `json:"totalRouters"`
	// Number of successful credential tests
	SuccessCount int `json:"successCount"`
	// Number of failed credential tests
	FailureCount int `json:"failureCount"`
	// Per-router test results
	Results []*CredentialTestResult `json:"results"`
}

type TestConnectionPayload struct {
	// Whether the connection test succeeded
	Success bool `json:"success"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Router version if connection succeeded
	Version *string `json:"version,omitempty"`
	// Error message if connection failed
	Error *string `json:"error,omitempty"`
}

// Test notification payload
type TestNotificationPayload struct {
	// Whether test was successful
	Success bool `json:"success"`
	// Test result message
	Message *string `json:"message,omitempty"`
	// Errors encountered during test
	Errors []*MutationError `json:"errors,omitempty"`
}

// Throttle configuration to prevent alert spam
type ThrottleConfig struct {
	// Maximum number of alerts allowed
	MaxAlerts int `json:"maxAlerts"`
	// Time period in seconds
	PeriodSeconds int `json:"periodSeconds"`
	// Optional field to group alerts by
	GroupByField *string `json:"groupByField,omitempty"`
}

// Throttle configuration input
type ThrottleConfigInput struct {
	// Maximum number of alerts allowed
	MaxAlerts int `json:"maxAlerts"`
	// Time period in seconds
	PeriodSeconds int `json:"periodSeconds"`
	// Optional field to group alerts by
	GroupByField graphql.Omittable[*string] `json:"groupByField,omitempty"`
}

// Edge connecting nodes in a topology
type TopologyEdge struct {
	// Edge ID
	ID string `json:"id"`
	// Source node ID
	Source string `json:"source"`
	// Target node ID
	Target string `json:"target"`
	// Edge label (optional)
	Label *string `json:"label,omitempty"`
	// Additional edge data
	Data map[string]interface{} `json:"data,omitempty"`
	// Edge styling
	Style *TopologyEdgeStyle `json:"style,omitempty"`
}

// Styling for topology edges
type TopologyEdgeStyle struct {
	// Stroke color (CSS color)
	Stroke *string `json:"stroke,omitempty"`
	// Stroke width in pixels
	StrokeWidth *float64 `json:"strokeWidth,omitempty"`
	// Stroke dash array (for dashed lines)
	StrokeDasharray *string `json:"strokeDasharray,omitempty"`
}

// Node in a VLAN network topology diagram
type TopologyNode struct {
	// Node ID
	ID string `json:"id"`
	// Node type (bridge, vlan, port)
	Type TopologyNodeType `json:"type"`
	// Display label
	Label string `json:"label"`
	// Sub-label (optional)
	Sublabel *string `json:"sublabel,omitempty"`
	// Node position in the diagram
	Position *TopologyPosition `json:"position"`
	// Additional node data
	Data map[string]interface{} `json:"data,omitempty"`
	// Node styling
	Style *TopologyNodeStyle `json:"style,omitempty"`
}

// Styling for topology nodes
type TopologyNodeStyle struct {
	// Fill color (CSS color)
	Fill *string `json:"fill,omitempty"`
	// Stroke color (CSS color)
	Stroke *string `json:"stroke,omitempty"`
	// Stroke width in pixels
	StrokeWidth *float64 `json:"strokeWidth,omitempty"`
}

// Position of a node in the topology
type TopologyPosition struct {
	// X coordinate
	X float64 `json:"x"`
	// Y coordinate
	Y float64 `json:"y"`
}

// A single hop in the traceroute path
type TracerouteHop struct {
	// Hop number (1-based)
	HopNumber int `json:"hopNumber"`
	// IP address of the hop (null for timeout)
	Address *string `json:"address,omitempty"`
	// Reverse DNS hostname (if available)
	Hostname *string `json:"hostname,omitempty"`
	// Individual probe results for this hop
	Probes []*HopProbe `json:"probes"`
	// Status of this hop
	Status HopStatus `json:"status"`
	// Average latency across successful probes
	AvgLatencyMs *float64 `json:"avgLatencyMs,omitempty"`
	// Packet loss percentage for this hop (0-100)
	PacketLoss float64 `json:"packetLoss"`
}

// Input parameters for starting a traceroute
type TracerouteInput struct {
	// Target hostname or IP address
	Target string `json:"target"`
	// Maximum number of hops (default: 30, max: 64)
	MaxHops graphql.Omittable[*int] `json:"maxHops,omitempty"`
	// Timeout per hop in milliseconds (default: 3000)
	Timeout graphql.Omittable[*int] `json:"timeout,omitempty"`
	// Number of probes per hop (default: 3)
	ProbeCount graphql.Omittable[*int] `json:"probeCount,omitempty"`
	// Protocol to use for probes (default: ICMP)
	Protocol graphql.Omittable[*TracerouteProtocol] `json:"protocol,omitempty"`
}

// Traceroute job reference for subscription tracking
type TracerouteJob struct {
	// Unique job identifier
	JobID string `json:"jobId"`
	// Current job status
	Status JobStatus `json:"status"`
}

// Progress event emitted during traceroute execution
type TracerouteProgressEvent struct {
	// Job identifier
	JobID string `json:"jobId"`
	// Type of event
	EventType TracerouteEventType `json:"eventType"`
	// Newly discovered hop (for HOP_DISCOVERED events)
	Hop *TracerouteHop `json:"hop,omitempty"`
	// Final result (for COMPLETE events)
	Result *TracerouteResult `json:"result,omitempty"`
	// Error message (for ERROR events)
	Error *string `json:"error,omitempty"`
}

// Complete traceroute result
type TracerouteResult struct {
	// Target hostname or IP address
	Target string `json:"target"`
	// Resolved target IP address
	TargetIP string `json:"targetIp"`
	// Protocol used for probes
	Protocol TracerouteProtocol `json:"protocol"`
	// Maximum hops configured
	MaxHops int `json:"maxHops"`
	// Discovered hops in order
	Hops []*TracerouteHop `json:"hops"`
	// Whether traceroute completed
	Completed bool `json:"completed"`
	// Whether destination was reached
	ReachedDestination bool `json:"reachedDestination"`
	// Total time from start to completion (ms)
	TotalTimeMs float64 `json:"totalTimeMs"`
	// When the traceroute started
	StartedAt time.Time `json:"startedAt"`
	// When the traceroute completed (if finished)
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

// Suggested fix for a failed diagnostic step
type TroubleshootFixSuggestion struct {
	// Unique issue code (e.g., WAN_DISABLED, NO_DEFAULT_ROUTE)
	IssueCode string `json:"issueCode"`
	// User-friendly fix title
	Title string `json:"title"`
	// Detailed explanation of what will be fixed
	Explanation string `json:"explanation"`
	// Confidence level for this fix
	Confidence FixConfidence `json:"confidence"`
	// Whether user confirmation is required before applying
	RequiresConfirmation bool `json:"requiresConfirmation"`
	// Whether this is a manual fix (requires user action)
	IsManualFix bool `json:"isManualFix"`
	// Manual steps if this cannot be automated
	ManualSteps []string `json:"manualSteps,omitempty"`
	// RouterOS command that will be executed
	Command *string `json:"command,omitempty"`
	// Rollback command if fix needs to be reverted
	RollbackCommand *string `json:"rollbackCommand,omitempty"`
}

// Complete troubleshooting session
type TroubleshootSession struct {
	// Unique session identifier
	ID string `json:"id"`
	// Router being diagnosed
	RouterID string `json:"routerId"`
	// All diagnostic steps
	Steps []*TroubleshootStep `json:"steps"`
	// Current step index (0-based)
	CurrentStepIndex int `json:"currentStepIndex"`
	// Overall session status
	Status TroubleshootSessionStatus `json:"status"`
	// Detected WAN interface name
	WanInterface *string `json:"wanInterface,omitempty"`
	// Detected default gateway IP
	Gateway *string `json:"gateway,omitempty"`
	// Detected ISP information
	IspInfo *ISPInfo `json:"ispInfo,omitempty"`
	// Fixes that have been applied
	AppliedFixes []string `json:"appliedFixes"`
	// When the session started
	StartedAt time.Time `json:"startedAt"`
	// When the session completed
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

// A single step in the troubleshooting wizard
type TroubleshootStep struct {
	// Step type/ID
	ID TroubleshootStepType `json:"id"`
	// Step display name
	Name string `json:"name"`
	// Step description
	Description string `json:"description"`
	// Current status of this step
	Status TroubleshootStepStatus `json:"status"`
	// Result of executing this step
	Result *TroubleshootStepResult `json:"result,omitempty"`
	// Suggested fix if step failed
	Fix *TroubleshootFixSuggestion `json:"fix,omitempty"`
	// When the step started
	StartedAt *time.Time `json:"startedAt,omitempty"`
	// When the step completed
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

// Result of a single diagnostic step
type TroubleshootStepResult struct {
	// Whether the check passed
	Success bool `json:"success"`
	// User-friendly message about the result
	Message string `json:"message"`
	// Technical details for debugging
	Details *string `json:"details,omitempty"`
	// Execution time in milliseconds
	ExecutionTimeMs int `json:"executionTimeMs"`
	// Detected error code
	IssueCode *string `json:"issueCode,omitempty"`
	// Target that was checked (IP, interface name, etc.)
	Target *string `json:"target,omitempty"`
}

// Input for updating an alert rule
type UpdateAlertRuleInput struct {
	// Human-readable alert rule name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Event type to match
	EventType graphql.Omittable[*string] `json:"eventType,omitempty"`
	// Array of conditions
	Conditions graphql.Omittable[[]*AlertConditionInput] `json:"conditions,omitempty"`
	// Alert severity level
	Severity graphql.Omittable[*AlertSeverity] `json:"severity,omitempty"`
	// Notification channels
	Channels graphql.Omittable[[]string] `json:"channels,omitempty"`
	// Throttle configuration
	Throttle graphql.Omittable[*ThrottleConfigInput] `json:"throttle,omitempty"`
	// Quiet hours configuration
	QuietHours graphql.Omittable[*QuietHoursConfigInput] `json:"quietHours,omitempty"`
	// Optional device ID filter
	DeviceID graphql.Omittable[*string] `json:"deviceId,omitempty"`
	// Whether rule is enabled
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

type UpdateBridgeInput struct {
	Comment       graphql.Omittable[*string]      `json:"comment,omitempty"`
	Protocol      graphql.Omittable[*StpProtocol] `json:"protocol,omitempty"`
	Priority      graphql.Omittable[*int]         `json:"priority,omitempty"`
	VlanFiltering graphql.Omittable[*bool]        `json:"vlanFiltering,omitempty"`
	Pvid          graphql.Omittable[*int]         `json:"pvid,omitempty"`
	Mtu           graphql.Omittable[*int]         `json:"mtu,omitempty"`
	Disabled      graphql.Omittable[*bool]        `json:"disabled,omitempty"`
}

type UpdateBridgePortInput struct {
	Pvid             graphql.Omittable[*int]        `json:"pvid,omitempty"`
	FrameTypes       graphql.Omittable[*FrameTypes] `json:"frameTypes,omitempty"`
	IngressFiltering graphql.Omittable[*bool]       `json:"ingressFiltering,omitempty"`
	TaggedVlans      graphql.Omittable[[]int]       `json:"taggedVlans,omitempty"`
	UntaggedVlans    graphql.Omittable[[]int]       `json:"untaggedVlans,omitempty"`
	Edge             graphql.Omittable[*bool]       `json:"edge,omitempty"`
	PathCost         graphql.Omittable[*int]        `json:"pathCost,omitempty"`
}

// Input for updating an item in a change set
type UpdateChangeSetItemInput struct {
	// Updated name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Updated description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Updated configuration
	Configuration graphql.Omittable[map[string]interface{}] `json:"configuration,omitempty"`
	// Updated dependencies
	Dependencies graphql.Omittable[[]string] `json:"dependencies,omitempty"`
}

type UpdateChangeSetItemPayload struct {
	// The updated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating interface settings
type UpdateInterfaceInput struct {
	// Enable or disable the interface
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
	// MTU size (68-9000 bytes)
	Mtu graphql.Omittable[*int] `json:"mtu,omitempty"`
	// Interface comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Payload returned by updateInterface, enableInterface, and disableInterface mutations
type UpdateInterfacePayload struct {
	// Updated interface
	Interface *Interface `json:"interface,omitempty"`
	// Errors that occurred during the operation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating resource configuration
type UpdateResourceInput struct {
	// Updated configuration (partial or full)
	Configuration graphql.Omittable[map[string]interface{}] `json:"configuration,omitempty"`
	// Updated relationships
	Relationships graphql.Omittable[*ResourceRelationshipsInput] `json:"relationships,omitempty"`
	// Updated tags
	Tags graphql.Omittable[[]string] `json:"tags,omitempty"`
	// Updated description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

type UpdateResourcePayload struct {
	// The updated resource
	Resource Resource `json:"resource,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating router settings
type UpdateRouterInput struct {
	// Updated display name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Updated hostname or IP address
	Host graphql.Omittable[*string] `json:"host,omitempty"`
	// Updated connection port
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Updated username
	Username graphql.Omittable[*string] `json:"username,omitempty"`
	// Updated password
	Password graphql.Omittable[*string] `json:"password,omitempty"`
}

type UpdateRouterPayload struct {
	// The updated router
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during update
	Errors []*MutationError `json:"errors,omitempty"`
}

// Impact assessment for an upgrade
type UpgradeImpact struct {
	// Whether reboot is required
	RequiresReboot bool `json:"requiresReboot"`
	// Estimated downtime description
	EstimatedDowntime *string `json:"estimatedDowntime,omitempty"`
	// Whether configuration backup is recommended before upgrade
	BackupRecommended bool `json:"backupRecommended"`
	// Potential breaking changes to be aware of
	BreakingChanges []string `json:"breakingChanges"`
}

// Upgrade recommendation for enabling a feature
type UpgradeRecommendation struct {
	// Feature that requires upgrade
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	FeatureName string `json:"featureName"`
	// Current RouterOS version
	CurrentVersion string `json:"currentVersion"`
	// Minimum required version for this feature
	RequiredVersion string `json:"requiredVersion"`
	// Whether this is a major version upgrade (e.g., 6.x to 7.x)
	IsMajorUpgrade bool `json:"isMajorUpgrade"`
	// Priority level (critical, high, medium, low)
	Priority UpgradePriority `json:"priority"`
	// Steps to complete the upgrade
	Steps []*UpgradeStep `json:"steps"`
	// Estimated impact on router operation
	Impact *UpgradeImpact `json:"impact"`
	// URL to MikroTik upgrade documentation
	DocumentationURL *string `json:"documentationUrl,omitempty"`
	// Warnings or important notes about this upgrade
	Warnings []string `json:"warnings"`
}

// Single step in an upgrade process
type UpgradeStep struct {
	// Step number (1-based)
	Step int `json:"step"`
	// Step title
	Title string `json:"title"`
	// Detailed instructions
	Description string `json:"description"`
	// RouterOS command to execute (if applicable)
	Command *string `json:"command,omitempty"`
	// Whether this step is optional
	Optional bool `json:"optional"`
}

// An uptime data point
type UptimeDataPoint struct {
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
	// Whether resource was up during this period
	IsUp bool `json:"isUp"`
	// Period duration in seconds
	PeriodSeconds int `json:"periodSeconds"`
}

// Single step in VIF enablement guidance
type VIFGuidanceStep struct {
	// Step number (1-based)
	Step int `json:"step"`
	// Short title for the step
	Title string `json:"title"`
	// Detailed instruction
	Description string `json:"description"`
	// Whether this requirement is already met
	Completed bool `json:"completed"`
	// RouterOS command to execute (if applicable)
	RouterCommand *string `json:"routerCommand,omitempty"`
}

// VIF (Virtual Interface Factory) requirements check result
type VIFRequirements struct {
	// Whether all VIF requirements are satisfied
	Met bool `json:"met"`
	// Whether RouterOS version is sufficient (7.13+)
	RouterOSVersion bool `json:"routerOSVersion"`
	// Whether container package is installed
	ContainerPackage bool `json:"containerPackage"`
	// Whether container feature is enabled
	ContainerEnabled bool `json:"containerEnabled"`
	// Whether there's sufficient storage (>100MB)
	SufficientStorage bool `json:"sufficientStorage"`
	// Whether network namespace is supported
	NetworkNamespace bool `json:"networkNamespace"`
	// Human-readable reasons why VIF is not available
	MissingReasons []string `json:"missingReasons"`
	// Step-by-step guidance for enabling VIF
	GuidanceSteps []*VIFGuidanceStep `json:"guidanceSteps"`
}

type ValidateChangeSetPayload struct {
	// The validated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Validation result
	Validation *ChangeSetValidationResult `json:"validation,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

type ValidateResourcePayload struct {
	// The validated resource
	Resource Resource `json:"resource,omitempty"`
	// Validation result
	Validation *ValidationResult `json:"validation,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Field-level validation error with suggestions for fixing.
type ValidationError struct {
	// Field path that failed validation (e.g., 'input.host', 'input.port')
	Field string `json:"field"`
	// Error code for the validation failure
	Code string `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Suggestion for fixing the validation error
	Suggestion *string `json:"suggestion,omitempty"`
	// The invalid value (redacted for sensitive fields)
	ProvidedValue *string `json:"providedValue,omitempty"`
}

// A validation issue (error or warning)
type ValidationIssue struct {
	// Error code for programmatic handling
	Code string `json:"code"`
	// Human-readable message
	Message string `json:"message"`
	// Field path that caused the issue (e.g., 'configuration.listenPort')
	Field *string `json:"field,omitempty"`
	// Severity level
	Severity ValidationSeverity `json:"severity"`
	// Suggested fix
	SuggestedFix *string `json:"suggestedFix,omitempty"`
	// Link to documentation
	DocsURL *string `json:"docsUrl,omitempty"`
}

// Layer 2: Validation result from 7-stage backend validation pipeline.
// Computed on every configuration change.
type ValidationResult struct {
	// Whether the resource can be applied
	CanApply bool `json:"canApply"`
	// Current validation stage
	Stage ValidationStage `json:"stage"`
	// Validation errors (blocking)
	Errors []*ValidationIssue `json:"errors"`
	// Validation warnings (non-blocking)
	Warnings []*ValidationIssue `json:"warnings"`
	// Resource conflicts detected
	Conflicts []*ResourceConflict `json:"conflicts"`
	// Required dependencies that must be active
	RequiredDependencies []*DependencyStatus `json:"requiredDependencies"`
	// When validation was performed
	ValidatedAt time.Time `json:"validatedAt"`
	// Duration of validation in milliseconds
	ValidationDurationMs int `json:"validationDurationMs"`
}

// A VLAN (Virtual LAN) interface for network segmentation using 802.1Q tagging
type Vlan struct {
	// Unique VLAN identifier
	ID string `json:"id"`
	// VLAN interface name (e.g., vlan10, vlan-guest)
	Name string `json:"name"`
	// 802.1Q VLAN ID (1-4094)
	VlanID int `json:"vlanId"`
	// Parent interface (bridge or physical interface)
	Interface *Interface `json:"interface"`
	// MTU setting (optional, inherits from parent if not set)
	Mtu *int `json:"mtu,omitempty"`
	// MAC address of the VLAN interface
	MacAddress *MAC `json:"macAddress,omitempty"`
	// Whether the VLAN interface is disabled
	Disabled bool `json:"disabled"`
	// Whether the VLAN interface is running (link up)
	Running bool `json:"running"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// IP addresses assigned to this VLAN
	IPAddresses []*IPAddress `json:"ipAddresses"`
	// Traffic statistics for this VLAN
	Statistics *InterfaceStats `json:"statistics,omitempty"`
}

func (Vlan) IsNode() {}

// Resources that depend on a VLAN interface
type VlanDependencies struct {
	// VLAN interface ID
	VlanID string `json:"vlanId"`
	// IP addresses assigned to this VLAN
	IPAddresses []*IPAddress `json:"ipAddresses"`
	// DHCP servers using this VLAN
	DhcpServers []*DhcpServer `json:"dhcpServers"`
	// Firewall rules referencing this VLAN
	FirewallRules []*FirewallRule `json:"firewallRules"`
	// Routes using this VLAN interface
	Routes []*Route `json:"routes"`
	// Number of active connections on this VLAN
	ActiveConnections int `json:"activeConnections"`
	// Whether the VLAN has any dependencies
	HasDependencies bool `json:"hasDependencies"`
}

// Filter options for querying VLANs
type VlanFilter struct {
	// Filter by parent interface ID
	ParentInterface graphql.Omittable[*string] `json:"parentInterface,omitempty"`
	// Filter by VLAN ID range
	VlanIDRange graphql.Omittable[*IntRange] `json:"vlanIdRange,omitempty"`
	// Filter by name containing this string
	NameContains graphql.Omittable[*string] `json:"nameContains,omitempty"`
}

// Input for creating a new VLAN interface
type VlanInput struct {
	// VLAN interface name (alphanumeric, hyphens, underscores)
	Name string `json:"name"`
	// 802.1Q VLAN ID (1-4094)
	VlanID int `json:"vlanId"`
	// Parent interface ID (bridge or physical interface)
	Interface string `json:"interface"`
	// MTU setting (optional, inherits from parent if not set)
	Mtu graphql.Omittable[*int] `json:"mtu,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Result of a VLAN mutation (create, update)
type VlanMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The created or updated VLAN (if successful)
	Vlan *Vlan `json:"vlan,omitempty"`
	// Configuration preview (RouterOS commands that will be executed)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Errors that occurred during the operation
	Errors []*MutationError `json:"errors,omitempty"`
}

// VLAN topology data (nodes and edges)
type VlanTopology struct {
	// Topology nodes (bridges, VLANs, ports)
	Nodes []*TopologyNode `json:"nodes"`
	// Topology edges (connections)
	Edges []*TopologyEdge `json:"edges"`
}

// WAN connection history entry
type WANConnectionEvent struct {
	// Event ID
	ID string `json:"id"`
	// WAN interface ID
	WanInterfaceID string `json:"wanInterfaceId"`
	// Event type
	EventType WANEventType `json:"eventType"`
	// Event timestamp
	Timestamp time.Time `json:"timestamp"`
	// Public IP at the time (if applicable)
	PublicIP *IPv4 `json:"publicIP,omitempty"`
	// Gateway IP
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Reason/error message (if applicable)
	Reason *string `json:"reason,omitempty"`
	// Connection duration (for disconnect events)
	Duration *Duration `json:"duration,omitempty"`
}

// Connection history pagination
type WANConnectionEventConnection struct {
	Edges      []*WANConnectionEventEdge `json:"edges"`
	PageInfo   *PageInfo                 `json:"pageInfo"`
	TotalCount *int                      `json:"totalCount,omitempty"`
}

func (WANConnectionEventConnection) IsConnection() {}

type WANConnectionEventEdge struct {
	Node   *WANConnectionEvent `json:"node"`
	Cursor string              `json:"cursor"`
}

func (WANConnectionEventEdge) IsEdge() {}

// Input for configuring WAN health check
type WANHealthCheckInput struct {
	// Target host to ping (IP or hostname)
	Target string `json:"target"`
	// Check interval in seconds
	Interval int `json:"interval"`
	// Enable health check
	Enabled bool `json:"enabled"`
}

// WAN health check status
type WANHealthStatus struct {
	// Overall health status
	Status HealthCheckStatus `json:"status"`
	// Target host being monitored
	Target string `json:"target"`
	// Check interval
	Interval Duration `json:"interval"`
	// Current latency (if reachable)
	Latency *int `json:"latency,omitempty"`
	// Packet loss percentage (0-100)
	PacketLoss int `json:"packetLoss"`
	// Consecutive successful checks
	SuccessCount int `json:"successCount"`
	// Consecutive failed checks
	FailureCount int `json:"failureCount"`
	// Last check timestamp
	LastCheck time.Time `json:"lastCheck"`
	// Whether health check is enabled
	Enabled bool `json:"enabled"`
}

// WAN interface status with connection details
type WANInterface struct {
	// Unique identifier
	ID string `json:"id"`
	// Underlying network interface
	Interface *Interface `json:"interface"`
	// WAN connection type
	Type WANConnectionType `json:"type"`
	// Current connection status
	Status WANStatus `json:"status"`
	// Public IP address (if connected)
	PublicIP *IPv4 `json:"publicIP,omitempty"`
	// Gateway IP address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Primary DNS server
	PrimaryDNS *IPv4 `json:"primaryDNS,omitempty"`
	// Secondary DNS server
	SecondaryDNS *IPv4 `json:"secondaryDNS,omitempty"`
	// Connection uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Last connection time
	LastConnected *time.Time `json:"lastConnected,omitempty"`
	// Health check status
	Health *WANHealthStatus `json:"health,omitempty"`
	// DHCP client configuration (if type is DHCP)
	DhcpClient *DhcpClient `json:"dhcpClient,omitempty"`
	// PPPoE client configuration (if type is PPPOE)
	PppoeClient *PppoeClient `json:"pppoeClient,omitempty"`
	// Static IP configuration (if type is STATIC)
	StaticConfig *StaticIPConfig `json:"staticConfig,omitempty"`
	// LTE modem configuration (if type is LTE)
	LteModem *LteModem `json:"lteModem,omitempty"`
	// Whether this is the default route
	IsDefaultRoute bool `json:"isDefaultRoute"`
	// Traffic statistics
	Statistics *InterfaceStats `json:"statistics,omitempty"`
}

func (WANInterface) IsNode() {}

// WAN Link resource for internet connectivity
type WANLink struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration,omitempty"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	WanRuntime    *WANLinkRuntime        `json:"wanRuntime,omitempty"`
	// Interface name
	Interface string `json:"interface"`
	// Connection type (static, dhcp, pppoe)
	ConnectionType WANConnectionType `json:"connectionType"`
	// Whether this is the primary WAN
	IsPrimary bool `json:"isPrimary"`
	// Failover priority (lower = higher priority)
	FailoverPriority *int `json:"failoverPriority,omitempty"`
}

func (WANLink) IsResource() {}

func (WANLink) IsNode() {}

// WAN Link runtime state
type WANLinkRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Current IP address
	CurrentIP *IPv4 `json:"currentIP,omitempty"`
	// Gateway address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Public IP (may differ due to NAT)
	PublicIP *IPv4 `json:"publicIP,omitempty"`
	// DNS servers received
	DNSServers []IPv4 `json:"dnsServers,omitempty"`
	// Current uplink speed (bytes/sec)
	UplinkSpeed *Size `json:"uplinkSpeed,omitempty"`
	// Current downlink speed (bytes/sec)
	DownlinkSpeed *Size `json:"downlinkSpeed,omitempty"`
	// Total uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Last connection change
	LastStateChange *time.Time `json:"lastStateChange,omitempty"`
}

// Result of WAN configuration mutation
type WANMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The configured WAN interface
	WanInterface *WANInterface `json:"wanInterface,omitempty"`
	// Configuration preview (RouterOS commands)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// WireGuard VPN Client resource implementing 8-layer model
type WireGuardClient struct {
	ID                  string                 `json:"id"`
	ScopedID            string                 `json:"scopedId"`
	Type                string                 `json:"type"`
	Category            ResourceCategory       `json:"category"`
	Configuration       map[string]interface{} `json:"configuration,omitempty"`
	Validation          *ValidationResult      `json:"validation,omitempty"`
	Deployment          *DeploymentState       `json:"deployment,omitempty"`
	Runtime             *RuntimeState          `json:"runtime,omitempty"`
	Telemetry           *TelemetryData         `json:"telemetry,omitempty"`
	Metadata            *ResourceMetadata      `json:"metadata"`
	Relationships       *ResourceRelationships `json:"relationships,omitempty"`
	Platform            *PlatformInfo          `json:"platform,omitempty"`
	Config              *WireGuardClientConfig `json:"config"`
	WireguardDeployment *WireGuardDeployment   `json:"wireguardDeployment,omitempty"`
	WireguardRuntime    *WireGuardRuntime      `json:"wireguardRuntime,omitempty"`
}

func (WireGuardClient) IsResource() {}

func (WireGuardClient) IsNode() {}

// WireGuard client configuration
type WireGuardClientConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// WireGuard private key
	PrivateKey string `json:"privateKey"`
	// Peer public key
	PeerPublicKey string `json:"peerPublicKey"`
	// Peer endpoint (IP:port)
	PeerEndpoint string `json:"peerEndpoint"`
	// Allowed IPs (CIDR notation)
	AllowedIPs []CIDR `json:"allowedIPs"`
	// Persistent keepalive interval
	PersistentKeepalive *Duration `json:"persistentKeepalive,omitempty"`
	// Listen port (0 for auto)
	ListenPort *Port `json:"listenPort,omitempty"`
	// WAN interface to use
	WanInterface *string `json:"wanInterface,omitempty"`
	// Enable kill switch
	KillSwitch *bool `json:"killSwitch,omitempty"`
	// DNS servers to use
	DNSServers []IPv4 `json:"dnsServers,omitempty"`
}

// WireGuard deployment state (router-generated)
type WireGuardDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Generated public key
	PublicKey *string `json:"publicKey,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// WireGuard runtime state
type WireGuardRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether connected to peer
	IsConnected bool `json:"isConnected"`
	// Last handshake time
	LastHandshake *time.Time `json:"lastHandshake,omitempty"`
	// Current endpoint (may differ from configured)
	CurrentEndpoint *string `json:"currentEndpoint,omitempty"`
	// Bytes transferred in
	BytesIn Size `json:"bytesIn"`
	// Bytes transferred out
	BytesOut Size `json:"bytesOut"`
	// Current active peers count
	ActivePeers int `json:"activePeers"`
}

// Alert action types for subscriptions
type AlertAction string

const (
	// Alert was created/triggered
	AlertActionCreated AlertAction = "CREATED"
	// Alert was acknowledged
	AlertActionAcknowledged AlertAction = "ACKNOWLEDGED"
	// Alert was resolved
	AlertActionResolved AlertAction = "RESOLVED"
)

var AllAlertAction = []AlertAction{
	AlertActionCreated,
	AlertActionAcknowledged,
	AlertActionResolved,
}

func (e AlertAction) IsValid() bool {
	switch e {
	case AlertActionCreated, AlertActionAcknowledged, AlertActionResolved:
		return true
	}
	return false
}

func (e AlertAction) String() string {
	return string(e)
}

func (e *AlertAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertAction", str)
	}
	return nil
}

func (e AlertAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Alert severity levels
type AlertSeverity string

const (
	// Critical - requires immediate attention
	AlertSeverityCritical AlertSeverity = "CRITICAL"
	// Warning - attention needed soon
	AlertSeverityWarning AlertSeverity = "WARNING"
	// Info - informational only
	AlertSeverityInfo AlertSeverity = "INFO"
)

var AllAlertSeverity = []AlertSeverity{
	AlertSeverityCritical,
	AlertSeverityWarning,
	AlertSeverityInfo,
}

func (e AlertSeverity) IsValid() bool {
	switch e {
	case AlertSeverityCritical, AlertSeverityWarning, AlertSeverityInfo:
		return true
	}
	return false
}

func (e AlertSeverity) String() string {
	return string(e)
}

func (e *AlertSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertSeverity", str)
	}
	return nil
}

func (e AlertSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Actions available for batch interface operations
type BatchInterfaceAction string

const (
	BatchInterfaceActionEnable  BatchInterfaceAction = "ENABLE"
	BatchInterfaceActionDisable BatchInterfaceAction = "DISABLE"
	BatchInterfaceActionUpdate  BatchInterfaceAction = "UPDATE"
)

var AllBatchInterfaceAction = []BatchInterfaceAction{
	BatchInterfaceActionEnable,
	BatchInterfaceActionDisable,
	BatchInterfaceActionUpdate,
}

func (e BatchInterfaceAction) IsValid() bool {
	switch e {
	case BatchInterfaceActionEnable, BatchInterfaceActionDisable, BatchInterfaceActionUpdate:
		return true
	}
	return false
}

func (e BatchInterfaceAction) String() string {
	return string(e)
}

func (e *BatchInterfaceAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BatchInterfaceAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BatchInterfaceAction", str)
	}
	return nil
}

func (e BatchInterfaceAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Frame types that can be admitted on a bridge port
type BridgePortFrameTypes string

const (
	// Accept all frames (tagged and untagged)
	BridgePortFrameTypesAdmitAll BridgePortFrameTypes = "ADMIT_ALL"
	// Accept only untagged and priority-tagged frames
	BridgePortFrameTypesAdmitOnlyUntaggedAndPriorityTagged BridgePortFrameTypes = "ADMIT_ONLY_UNTAGGED_AND_PRIORITY_TAGGED"
	// Accept only VLAN-tagged frames
	BridgePortFrameTypesAdmitOnlyVlanTagged BridgePortFrameTypes = "ADMIT_ONLY_VLAN_TAGGED"
)

var AllBridgePortFrameTypes = []BridgePortFrameTypes{
	BridgePortFrameTypesAdmitAll,
	BridgePortFrameTypesAdmitOnlyUntaggedAndPriorityTagged,
	BridgePortFrameTypesAdmitOnlyVlanTagged,
}

func (e BridgePortFrameTypes) IsValid() bool {
	switch e {
	case BridgePortFrameTypesAdmitAll, BridgePortFrameTypesAdmitOnlyUntaggedAndPriorityTagged, BridgePortFrameTypesAdmitOnlyVlanTagged:
		return true
	}
	return false
}

func (e BridgePortFrameTypes) String() string {
	return string(e)
}

func (e *BridgePortFrameTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BridgePortFrameTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BridgePortFrameTypes", str)
	}
	return nil
}

func (e BridgePortFrameTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CacheScope string

const (
	CacheScopePrivate CacheScope = "PRIVATE"
	CacheScopePublic  CacheScope = "PUBLIC"
)

var AllCacheScope = []CacheScope{
	CacheScopePrivate,
	CacheScopePublic,
}

func (e CacheScope) IsValid() bool {
	switch e {
	case CacheScopePrivate, CacheScopePublic:
		return true
	}
	return false
}

func (e CacheScope) String() string {
	return string(e)
}

func (e *CacheScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CacheScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CacheScope", str)
	}
	return nil
}

func (e CacheScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Feature capability categories detected on routers.
// Used to determine what features are available on a specific router.
type Capability string

const (
	// Container/Docker support
	CapabilityContainer Capability = "CONTAINER"
	// Virtual Interface Factory support
	CapabilityVif Capability = "VIF"
	// Wireless/WiFi support
	CapabilityWireless Capability = "WIRELESS"
	// Advanced routing features
	CapabilityRouting Capability = "ROUTING"
	// Firewall features
	CapabilityFirewall Capability = "FIREWALL"
	// MPLS support
	CapabilityMpls Capability = "MPLS"
	// IPv6 support
	CapabilityIPV6 Capability = "IPV6"
	// Hotspot features
	CapabilityHotspot Capability = "HOTSPOT"
	// User Manager features
	CapabilityUserManager Capability = "USER_MANAGER"
	// Dude monitoring support
	CapabilityDude Capability = "DUDE"
	// WireGuard VPN support
	CapabilityWireguard Capability = "WIREGUARD"
	// ZeroTier support
	CapabilityZerotier Capability = "ZEROTIER"
)

var AllCapability = []Capability{
	CapabilityContainer,
	CapabilityVif,
	CapabilityWireless,
	CapabilityRouting,
	CapabilityFirewall,
	CapabilityMpls,
	CapabilityIPV6,
	CapabilityHotspot,
	CapabilityUserManager,
	CapabilityDude,
	CapabilityWireguard,
	CapabilityZerotier,
}

func (e Capability) IsValid() bool {
	switch e {
	case CapabilityContainer, CapabilityVif, CapabilityWireless, CapabilityRouting, CapabilityFirewall, CapabilityMpls, CapabilityIPV6, CapabilityHotspot, CapabilityUserManager, CapabilityDude, CapabilityWireguard, CapabilityZerotier:
		return true
	}
	return false
}

func (e Capability) String() string {
	return string(e)
}

func (e *Capability) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Capability(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Capability", str)
	}
	return nil
}

func (e Capability) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Capability support level for a feature.
// Determines how the feature appears in the UI.
type CapabilityLevel string

const (
	// Feature not supported (hide in UI)
	CapabilityLevelNone CapabilityLevel = "NONE"
	// Limited support (show with warnings)
	CapabilityLevelBasic CapabilityLevel = "BASIC"
	// Full RouterOS native support
	CapabilityLevelAdvanced CapabilityLevel = "ADVANCED"
	// Complete support including container-based features
	CapabilityLevelFull CapabilityLevel = "FULL"
)

var AllCapabilityLevel = []CapabilityLevel{
	CapabilityLevelNone,
	CapabilityLevelBasic,
	CapabilityLevelAdvanced,
	CapabilityLevelFull,
}

func (e CapabilityLevel) IsValid() bool {
	switch e {
	case CapabilityLevelNone, CapabilityLevelBasic, CapabilityLevelAdvanced, CapabilityLevelFull:
		return true
	}
	return false
}

func (e CapabilityLevel) String() string {
	return string(e)
}

func (e *CapabilityLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CapabilityLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CapabilityLevel", str)
	}
	return nil
}

func (e CapabilityLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of operation to perform on a resource
type ChangeOperation string

const (
	// Create a new resource
	ChangeOperationCreate ChangeOperation = "CREATE"
	// Update an existing resource
	ChangeOperationUpdate ChangeOperation = "UPDATE"
	// Delete an existing resource
	ChangeOperationDelete ChangeOperation = "DELETE"
)

var AllChangeOperation = []ChangeOperation{
	ChangeOperationCreate,
	ChangeOperationUpdate,
	ChangeOperationDelete,
}

func (e ChangeOperation) IsValid() bool {
	switch e {
	case ChangeOperationCreate, ChangeOperationUpdate, ChangeOperationDelete:
		return true
	}
	return false
}

func (e ChangeOperation) String() string {
	return string(e)
}

func (e *ChangeOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeOperation", str)
	}
	return nil
}

func (e ChangeOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of individual items within a change set
type ChangeSetItemStatus string

const (
	// Waiting to be applied
	ChangeSetItemStatusPending ChangeSetItemStatus = "PENDING"
	// Currently being applied
	ChangeSetItemStatusApplying ChangeSetItemStatus = "APPLYING"
	// Successfully applied
	ChangeSetItemStatusApplied ChangeSetItemStatus = "APPLIED"
	// Application failed
	ChangeSetItemStatusFailed ChangeSetItemStatus = "FAILED"
	// Successfully rolled back
	ChangeSetItemStatusRolledBack ChangeSetItemStatus = "ROLLED_BACK"
	// Rollback failed - manual intervention needed
	ChangeSetItemStatusRollbackFailed ChangeSetItemStatus = "ROLLBACK_FAILED"
	// Skipped due to dependency failure
	ChangeSetItemStatusSkipped ChangeSetItemStatus = "SKIPPED"
)

var AllChangeSetItemStatus = []ChangeSetItemStatus{
	ChangeSetItemStatusPending,
	ChangeSetItemStatusApplying,
	ChangeSetItemStatusApplied,
	ChangeSetItemStatusFailed,
	ChangeSetItemStatusRolledBack,
	ChangeSetItemStatusRollbackFailed,
	ChangeSetItemStatusSkipped,
}

func (e ChangeSetItemStatus) IsValid() bool {
	switch e {
	case ChangeSetItemStatusPending, ChangeSetItemStatusApplying, ChangeSetItemStatusApplied, ChangeSetItemStatusFailed, ChangeSetItemStatusRolledBack, ChangeSetItemStatusRollbackFailed, ChangeSetItemStatusSkipped:
		return true
	}
	return false
}

func (e ChangeSetItemStatus) String() string {
	return string(e)
}

func (e *ChangeSetItemStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeSetItemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeSetItemStatus", str)
	}
	return nil
}

func (e ChangeSetItemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Change set lifecycle status
type ChangeSetStatus string

const (
	// Initial state - adding items, not yet validated
	ChangeSetStatusDraft ChangeSetStatus = "DRAFT"
	// Running validation on all items
	ChangeSetStatusValidating ChangeSetStatus = "VALIDATING"
	// All items validated, ready to apply
	ChangeSetStatusReady ChangeSetStatus = "READY"
	// Applying resources in dependency order
	ChangeSetStatusApplying ChangeSetStatus = "APPLYING"
	// All resources applied successfully
	ChangeSetStatusCompleted ChangeSetStatus = "COMPLETED"
	// Apply failed, may have partial application
	ChangeSetStatusFailed ChangeSetStatus = "FAILED"
	// Rolling back applied changes
	ChangeSetStatusRollingBack ChangeSetStatus = "ROLLING_BACK"
	// Rollback completed successfully
	ChangeSetStatusRolledBack ChangeSetStatus = "ROLLED_BACK"
	// Rollback partially failed - manual intervention needed
	ChangeSetStatusPartialFailure ChangeSetStatus = "PARTIAL_FAILURE"
	// User cancelled the operation
	ChangeSetStatusCancelled ChangeSetStatus = "CANCELLED"
)

var AllChangeSetStatus = []ChangeSetStatus{
	ChangeSetStatusDraft,
	ChangeSetStatusValidating,
	ChangeSetStatusReady,
	ChangeSetStatusApplying,
	ChangeSetStatusCompleted,
	ChangeSetStatusFailed,
	ChangeSetStatusRollingBack,
	ChangeSetStatusRolledBack,
	ChangeSetStatusPartialFailure,
	ChangeSetStatusCancelled,
}

func (e ChangeSetStatus) IsValid() bool {
	switch e {
	case ChangeSetStatusDraft, ChangeSetStatusValidating, ChangeSetStatusReady, ChangeSetStatusApplying, ChangeSetStatusCompleted, ChangeSetStatusFailed, ChangeSetStatusRollingBack, ChangeSetStatusRolledBack, ChangeSetStatusPartialFailure, ChangeSetStatusCancelled:
		return true
	}
	return false
}

func (e ChangeSetStatus) String() string {
	return string(e)
}

func (e *ChangeSetStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeSetStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeSetStatus", str)
	}
	return nil
}

func (e ChangeSetStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of change for resource events
type ChangeType string

const (
	ChangeTypeCreate ChangeType = "CREATE"
	ChangeTypeUpdate ChangeType = "UPDATE"
	ChangeTypeDelete ChangeType = "DELETE"
)

var AllChangeType = []ChangeType{
	ChangeTypeCreate,
	ChangeTypeUpdate,
	ChangeTypeDelete,
}

func (e ChangeType) IsValid() bool {
	switch e {
	case ChangeTypeCreate, ChangeTypeUpdate, ChangeTypeDelete:
		return true
	}
	return false
}

func (e ChangeType) String() string {
	return string(e)
}

func (e *ChangeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeType", str)
	}
	return nil
}

func (e ChangeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Circuit breaker state
type CircuitBreakerState string

const (
	// Circuit is closed (normal operation)
	CircuitBreakerStateClosed CircuitBreakerState = "CLOSED"
	// Circuit is open (blocking requests)
	CircuitBreakerStateOpen CircuitBreakerState = "OPEN"
	// Circuit is half-open (testing recovery)
	CircuitBreakerStateHalfOpen CircuitBreakerState = "HALF_OPEN"
)

var AllCircuitBreakerState = []CircuitBreakerState{
	CircuitBreakerStateClosed,
	CircuitBreakerStateOpen,
	CircuitBreakerStateHalfOpen,
}

func (e CircuitBreakerState) IsValid() bool {
	switch e {
	case CircuitBreakerStateClosed, CircuitBreakerStateOpen, CircuitBreakerStateHalfOpen:
		return true
	}
	return false
}

func (e CircuitBreakerState) String() string {
	return string(e)
}

func (e *CircuitBreakerState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CircuitBreakerState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CircuitBreakerState", str)
	}
	return nil
}

func (e CircuitBreakerState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Condition comparison operators
type ConditionOperator string

const (
	// Exact match
	ConditionOperatorEquals ConditionOperator = "EQUALS"
	// Not equal
	ConditionOperatorNotEquals ConditionOperator = "NOT_EQUALS"
	// Numeric greater than
	ConditionOperatorGreaterThan ConditionOperator = "GREATER_THAN"
	// Numeric less than
	ConditionOperatorLessThan ConditionOperator = "LESS_THAN"
	// String contains
	ConditionOperatorContains ConditionOperator = "CONTAINS"
	// Regular expression match
	ConditionOperatorRegex ConditionOperator = "REGEX"
)

var AllConditionOperator = []ConditionOperator{
	ConditionOperatorEquals,
	ConditionOperatorNotEquals,
	ConditionOperatorGreaterThan,
	ConditionOperatorLessThan,
	ConditionOperatorContains,
	ConditionOperatorRegex,
}

func (e ConditionOperator) IsValid() bool {
	switch e {
	case ConditionOperatorEquals, ConditionOperatorNotEquals, ConditionOperatorGreaterThan, ConditionOperatorLessThan, ConditionOperatorContains, ConditionOperatorRegex:
		return true
	}
	return false
}

func (e ConditionOperator) String() string {
	return string(e)
}

func (e *ConditionOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionOperator", str)
	}
	return nil
}

func (e ConditionOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a configuration apply operation
type ConfigApplyStatus string

const (
	ConfigApplyStatusPending    ConfigApplyStatus = "PENDING"
	ConfigApplyStatusValidating ConfigApplyStatus = "VALIDATING"
	ConfigApplyStatusApplying   ConfigApplyStatus = "APPLYING"
	ConfigApplyStatusVerifying  ConfigApplyStatus = "VERIFYING"
	ConfigApplyStatusCompleted  ConfigApplyStatus = "COMPLETED"
	ConfigApplyStatusFailed     ConfigApplyStatus = "FAILED"
	ConfigApplyStatusRolledBack ConfigApplyStatus = "ROLLED_BACK"
)

var AllConfigApplyStatus = []ConfigApplyStatus{
	ConfigApplyStatusPending,
	ConfigApplyStatusValidating,
	ConfigApplyStatusApplying,
	ConfigApplyStatusVerifying,
	ConfigApplyStatusCompleted,
	ConfigApplyStatusFailed,
	ConfigApplyStatusRolledBack,
}

func (e ConfigApplyStatus) IsValid() bool {
	switch e {
	case ConfigApplyStatusPending, ConfigApplyStatusValidating, ConfigApplyStatusApplying, ConfigApplyStatusVerifying, ConfigApplyStatusCompleted, ConfigApplyStatusFailed, ConfigApplyStatusRolledBack:
		return true
	}
	return false
}

func (e ConfigApplyStatus) String() string {
	return string(e)
}

func (e *ConfigApplyStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfigApplyStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfigApplyStatus", str)
	}
	return nil
}

func (e ConfigApplyStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Severity level for confirmation dialogs
type ConfirmationSeverity string

const (
	// Critical operation requiring explicit confirmation
	ConfirmationSeverityCritical ConfirmationSeverity = "CRITICAL"
	// Standard operation with brief confirmation
	ConfirmationSeverityStandard ConfirmationSeverity = "STANDARD"
)

var AllConfirmationSeverity = []ConfirmationSeverity{
	ConfirmationSeverityCritical,
	ConfirmationSeverityStandard,
}

func (e ConfirmationSeverity) IsValid() bool {
	switch e {
	case ConfirmationSeverityCritical, ConfirmationSeverityStandard:
		return true
	}
	return false
}

func (e ConfirmationSeverity) String() string {
	return string(e)
}

func (e *ConfirmationSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfirmationSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfirmationSeverity", str)
	}
	return nil
}

func (e ConfirmationSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of resource conflicts
type ConflictType string

const (
	// Port number conflict
	ConflictTypePort ConflictType = "PORT"
	// IP address conflict
	ConflictTypeIPAddress ConflictType = "IP_ADDRESS"
	// Route overlap
	ConflictTypeRoute ConflictType = "ROUTE"
	// Interface conflict
	ConflictTypeInterface ConflictType = "INTERFACE"
	// Name collision
	ConflictTypeName ConflictType = "NAME"
	// Configuration incompatibility
	ConflictTypeConfiguration ConflictType = "CONFIGURATION"
)

var AllConflictType = []ConflictType{
	ConflictTypePort,
	ConflictTypeIPAddress,
	ConflictTypeRoute,
	ConflictTypeInterface,
	ConflictTypeName,
	ConflictTypeConfiguration,
}

func (e ConflictType) IsValid() bool {
	switch e {
	case ConflictTypePort, ConflictTypeIPAddress, ConflictTypeRoute, ConflictTypeInterface, ConflictTypeName, ConflictTypeConfiguration:
		return true
	}
	return false
}

func (e ConflictType) String() string {
	return string(e)
}

func (e *ConflictType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConflictType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConflictType", str)
	}
	return nil
}

func (e ConflictType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error codes for connection failures.
// Each code has specific meaning and recovery suggestions.
type ConnectionErrorCode string

const (
	// Authentication failed - invalid username or password
	ConnectionErrorCodeAuthFailed ConnectionErrorCode = "AUTH_FAILED"
	// Network unreachable - cannot reach the host
	ConnectionErrorCodeNetworkUnreachable ConnectionErrorCode = "NETWORK_UNREACHABLE"
	// Connection refused - port is closed or blocked
	ConnectionErrorCodeConnectionRefused ConnectionErrorCode = "CONNECTION_REFUSED"
	// No compatible protocol found after trying all options
	ConnectionErrorCodeProtocolMismatch ConnectionErrorCode = "PROTOCOL_MISMATCH"
	// Connection or response timed out
	ConnectionErrorCodeTimeout ConnectionErrorCode = "TIMEOUT"
	// DNS resolution failed for hostname
	ConnectionErrorCodeDNSFailed ConnectionErrorCode = "DNS_FAILED"
	// Router with same host/port already exists
	ConnectionErrorCodeDuplicateRouter ConnectionErrorCode = "DUPLICATE_ROUTER"
	// TLS/SSL handshake failed
	ConnectionErrorCodeTLSError ConnectionErrorCode = "TLS_ERROR"
	// Router responded but is not a MikroTik device
	ConnectionErrorCodeNotMikrotik ConnectionErrorCode = "NOT_MIKROTIK"
	// Unknown or unexpected error
	ConnectionErrorCodeUnknown ConnectionErrorCode = "UNKNOWN"
)

var AllConnectionErrorCode = []ConnectionErrorCode{
	ConnectionErrorCodeAuthFailed,
	ConnectionErrorCodeNetworkUnreachable,
	ConnectionErrorCodeConnectionRefused,
	ConnectionErrorCodeProtocolMismatch,
	ConnectionErrorCodeTimeout,
	ConnectionErrorCodeDNSFailed,
	ConnectionErrorCodeDuplicateRouter,
	ConnectionErrorCodeTLSError,
	ConnectionErrorCodeNotMikrotik,
	ConnectionErrorCodeUnknown,
}

func (e ConnectionErrorCode) IsValid() bool {
	switch e {
	case ConnectionErrorCodeAuthFailed, ConnectionErrorCodeNetworkUnreachable, ConnectionErrorCodeConnectionRefused, ConnectionErrorCodeProtocolMismatch, ConnectionErrorCodeTimeout, ConnectionErrorCodeDNSFailed, ConnectionErrorCodeDuplicateRouter, ConnectionErrorCodeTLSError, ConnectionErrorCodeNotMikrotik, ConnectionErrorCodeUnknown:
		return true
	}
	return false
}

func (e ConnectionErrorCode) String() string {
	return string(e)
}

func (e *ConnectionErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionErrorCode", str)
	}
	return nil
}

func (e ConnectionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Router connection status
type ConnectionStatus string

const (
	// Actively connected and responsive
	ConnectionStatusConnected ConnectionStatus = "CONNECTED"
	// Connection attempt in progress
	ConnectionStatusConnecting ConnectionStatus = "CONNECTING"
	// Not connected
	ConnectionStatusDisconnected ConnectionStatus = "DISCONNECTED"
	// Connection failed with error
	ConnectionStatusError ConnectionStatus = "ERROR"
)

var AllConnectionStatus = []ConnectionStatus{
	ConnectionStatusConnected,
	ConnectionStatusConnecting,
	ConnectionStatusDisconnected,
	ConnectionStatusError,
}

func (e ConnectionStatus) IsValid() bool {
	switch e {
	case ConnectionStatusConnected, ConnectionStatusConnecting, ConnectionStatusDisconnected, ConnectionStatusError:
		return true
	}
	return false
}

func (e ConnectionStatus) String() string {
	return string(e)
}

func (e *ConnectionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionStatus", str)
	}
	return nil
}

func (e ConnectionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error codes specific to credential operations.
type CredentialErrorCode string

const (
	// Authentication failed with new credentials
	CredentialErrorCodeAuthFailed CredentialErrorCode = "AUTH_FAILED"
	// Connection timed out when testing credentials
	CredentialErrorCodeTimeout CredentialErrorCode = "TIMEOUT"
	// Connection was refused
	CredentialErrorCodeConnectionRefused CredentialErrorCode = "CONNECTION_REFUSED"
	// Router not found
	CredentialErrorCodeRouterNotFound CredentialErrorCode = "ROUTER_NOT_FOUND"
	// Credentials not found for router
	CredentialErrorCodeCredentialsNotFound CredentialErrorCode = "CREDENTIALS_NOT_FOUND"
	// Encryption failed
	CredentialErrorCodeEncryptionFailed CredentialErrorCode = "ENCRYPTION_FAILED"
	// Decryption failed (key may have rotated)
	CredentialErrorCodeDecryptionFailed CredentialErrorCode = "DECRYPTION_FAILED"
	// Invalid input provided
	CredentialErrorCodeInvalidInput CredentialErrorCode = "INVALID_INPUT"
)

var AllCredentialErrorCode = []CredentialErrorCode{
	CredentialErrorCodeAuthFailed,
	CredentialErrorCodeTimeout,
	CredentialErrorCodeConnectionRefused,
	CredentialErrorCodeRouterNotFound,
	CredentialErrorCodeCredentialsNotFound,
	CredentialErrorCodeEncryptionFailed,
	CredentialErrorCodeDecryptionFailed,
	CredentialErrorCodeInvalidInput,
}

func (e CredentialErrorCode) IsValid() bool {
	switch e {
	case CredentialErrorCodeAuthFailed, CredentialErrorCodeTimeout, CredentialErrorCodeConnectionRefused, CredentialErrorCodeRouterNotFound, CredentialErrorCodeCredentialsNotFound, CredentialErrorCodeEncryptionFailed, CredentialErrorCodeDecryptionFailed, CredentialErrorCodeInvalidInput:
		return true
	}
	return false
}

func (e CredentialErrorCode) String() string {
	return string(e)
}

func (e *CredentialErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CredentialErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CredentialErrorCode", str)
	}
	return nil
}

func (e CredentialErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a credential test.
type CredentialTestStatus string

const (
	// Credentials are valid and connection succeeded
	CredentialTestStatusSuccess CredentialTestStatus = "SUCCESS"
	// Authentication failed
	CredentialTestStatusAuthFailed CredentialTestStatus = "AUTH_FAILED"
	// Connection timed out
	CredentialTestStatusTimeout CredentialTestStatus = "TIMEOUT"
	// Connection was refused
	CredentialTestStatusConnectionRefused CredentialTestStatus = "CONNECTION_REFUSED"
	// Network unreachable
	CredentialTestStatusNetworkError CredentialTestStatus = "NETWORK_ERROR"
	// No credentials stored for this router
	CredentialTestStatusNoCredentials CredentialTestStatus = "NO_CREDENTIALS"
	// Unknown error occurred
	CredentialTestStatusError CredentialTestStatus = "ERROR"
)

var AllCredentialTestStatus = []CredentialTestStatus{
	CredentialTestStatusSuccess,
	CredentialTestStatusAuthFailed,
	CredentialTestStatusTimeout,
	CredentialTestStatusConnectionRefused,
	CredentialTestStatusNetworkError,
	CredentialTestStatusNoCredentials,
	CredentialTestStatusError,
}

func (e CredentialTestStatus) IsValid() bool {
	switch e {
	case CredentialTestStatusSuccess, CredentialTestStatusAuthFailed, CredentialTestStatusTimeout, CredentialTestStatusConnectionRefused, CredentialTestStatusNetworkError, CredentialTestStatusNoCredentials, CredentialTestStatusError:
		return true
	}
	return false
}

func (e CredentialTestStatus) String() string {
	return string(e)
}

func (e *CredentialTestStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CredentialTestStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CredentialTestStatus", str)
	}
	return nil
}

func (e CredentialTestStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for router disconnection
type DisconnectReason string

const (
	// Unknown reason
	DisconnectReasonUnknown DisconnectReason = "UNKNOWN"
	// User manually disconnected
	DisconnectReasonManual DisconnectReason = "MANUAL"
	// Network failure
	DisconnectReasonNetworkFailure DisconnectReason = "NETWORK_FAILURE"
	// Authentication failed
	DisconnectReasonAuthFailure DisconnectReason = "AUTH_FAILURE"
	// Connection timed out
	DisconnectReasonTimeout DisconnectReason = "TIMEOUT"
	// Circuit breaker is open
	DisconnectReasonCircuitOpen DisconnectReason = "CIRCUIT_OPEN"
	// Application shutting down
	DisconnectReasonShutdown DisconnectReason = "SHUTDOWN"
)

var AllDisconnectReason = []DisconnectReason{
	DisconnectReasonUnknown,
	DisconnectReasonManual,
	DisconnectReasonNetworkFailure,
	DisconnectReasonAuthFailure,
	DisconnectReasonTimeout,
	DisconnectReasonCircuitOpen,
	DisconnectReasonShutdown,
}

func (e DisconnectReason) IsValid() bool {
	switch e {
	case DisconnectReasonUnknown, DisconnectReasonManual, DisconnectReasonNetworkFailure, DisconnectReasonAuthFailure, DisconnectReasonTimeout, DisconnectReasonCircuitOpen, DisconnectReasonShutdown:
		return true
	}
	return false
}

func (e DisconnectReason) String() string {
	return string(e)
}

func (e *DisconnectReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DisconnectReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DisconnectReason", str)
	}
	return nil
}

func (e DisconnectReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DNS lookup status codes
type DNSLookupStatus string

const (
	// Query completed successfully
	DNSLookupStatusSuccess DNSLookupStatus = "SUCCESS"
	// Domain does not exist (NXDOMAIN)
	DNSLookupStatusNxdomain DNSLookupStatus = "NXDOMAIN"
	// DNS server failure (SERVFAIL)
	DNSLookupStatusServfail DNSLookupStatus = "SERVFAIL"
	// Query timed out
	DNSLookupStatusTimeout DNSLookupStatus = "TIMEOUT"
	// Query refused by server
	DNSLookupStatusRefused DNSLookupStatus = "REFUSED"
	// Network error occurred
	DNSLookupStatusNetworkError DNSLookupStatus = "NETWORK_ERROR"
)

var AllDNSLookupStatus = []DNSLookupStatus{
	DNSLookupStatusSuccess,
	DNSLookupStatusNxdomain,
	DNSLookupStatusServfail,
	DNSLookupStatusTimeout,
	DNSLookupStatusRefused,
	DNSLookupStatusNetworkError,
}

func (e DNSLookupStatus) IsValid() bool {
	switch e {
	case DNSLookupStatusSuccess, DNSLookupStatusNxdomain, DNSLookupStatusServfail, DNSLookupStatusTimeout, DNSLookupStatusRefused, DNSLookupStatusNetworkError:
		return true
	}
	return false
}

func (e DNSLookupStatus) String() string {
	return string(e)
}

func (e *DNSLookupStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DNSLookupStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DnsLookupStatus", str)
	}
	return nil
}

func (e DNSLookupStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DNS record types supported
type DNSRecordType string

const (
	// IPv4 address record
	DNSRecordTypeA DNSRecordType = "A"
	// IPv6 address record
	DNSRecordTypeAaaa DNSRecordType = "AAAA"
	// Mail exchange record
	DNSRecordTypeMx DNSRecordType = "MX"
	// Text record
	DNSRecordTypeTxt DNSRecordType = "TXT"
	// Canonical name record
	DNSRecordTypeCname DNSRecordType = "CNAME"
	// Name server record
	DNSRecordTypeNs DNSRecordType = "NS"
	// Pointer record (reverse DNS)
	DNSRecordTypePtr DNSRecordType = "PTR"
	// Start of authority record
	DNSRecordTypeSoa DNSRecordType = "SOA"
	// Service record
	DNSRecordTypeSrv DNSRecordType = "SRV"
)

var AllDNSRecordType = []DNSRecordType{
	DNSRecordTypeA,
	DNSRecordTypeAaaa,
	DNSRecordTypeMx,
	DNSRecordTypeTxt,
	DNSRecordTypeCname,
	DNSRecordTypeNs,
	DNSRecordTypePtr,
	DNSRecordTypeSoa,
	DNSRecordTypeSrv,
}

func (e DNSRecordType) IsValid() bool {
	switch e {
	case DNSRecordTypeA, DNSRecordTypeAaaa, DNSRecordTypeMx, DNSRecordTypeTxt, DNSRecordTypeCname, DNSRecordTypeNs, DNSRecordTypePtr, DNSRecordTypeSoa, DNSRecordTypeSrv:
		return true
	}
	return false
}

func (e DNSRecordType) String() string {
	return string(e)
}

func (e *DNSRecordType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DNSRecordType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DnsRecordType", str)
	}
	return nil
}

func (e DNSRecordType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Actions to resolve drift
type DriftAction string

const (
	// Re-apply configuration to router
	DriftActionReapply DriftAction = "REAPPLY"
	// Update configuration to match router
	DriftActionAccept DriftAction = "ACCEPT"
	// Manual review required
	DriftActionReview DriftAction = "REVIEW"
)

var AllDriftAction = []DriftAction{
	DriftActionReapply,
	DriftActionAccept,
	DriftActionReview,
}

func (e DriftAction) IsValid() bool {
	switch e {
	case DriftActionReapply, DriftActionAccept, DriftActionReview:
		return true
	}
	return false
}

func (e DriftAction) String() string {
	return string(e)
}

func (e *DriftAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DriftAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DriftAction", str)
	}
	return nil
}

func (e DriftAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Category of connection error for classification
type ErrorCategory string

const (
	// Connection or response timeout
	ErrorCategoryTimeout ErrorCategory = "TIMEOUT"
	// Connection actively refused
	ErrorCategoryRefused ErrorCategory = "REFUSED"
	// Authentication failed
	ErrorCategoryAuthFailed ErrorCategory = "AUTH_FAILED"
	// Protocol-level error
	ErrorCategoryProtocolError ErrorCategory = "PROTOCOL_ERROR"
	// Network unreachable or DNS failure
	ErrorCategoryNetworkError ErrorCategory = "NETWORK_ERROR"
	// TLS/SSL certificate or handshake error
	ErrorCategoryTLSError ErrorCategory = "TLS_ERROR"
)

var AllErrorCategory = []ErrorCategory{
	ErrorCategoryTimeout,
	ErrorCategoryRefused,
	ErrorCategoryAuthFailed,
	ErrorCategoryProtocolError,
	ErrorCategoryNetworkError,
	ErrorCategoryTLSError,
}

func (e ErrorCategory) IsValid() bool {
	switch e {
	case ErrorCategoryTimeout, ErrorCategoryRefused, ErrorCategoryAuthFailed, ErrorCategoryProtocolError, ErrorCategoryNetworkError, ErrorCategoryTLSError:
		return true
	}
	return false
}

func (e ErrorCategory) String() string {
	return string(e)
}

func (e *ErrorCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorCategory", str)
	}
	return nil
}

func (e ErrorCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a fix application
type FixApplicationStatus string

const (
	// Fix is available but not yet applied
	FixApplicationStatusAvailable FixApplicationStatus = "AVAILABLE"
	// Fix is being applied
	FixApplicationStatusApplying FixApplicationStatus = "APPLYING"
	// Fix was applied successfully
	FixApplicationStatusApplied FixApplicationStatus = "APPLIED"
	// Fix application failed
	FixApplicationStatusFailed FixApplicationStatus = "FAILED"
	// Fix was applied but issue persists
	FixApplicationStatusIssuePersists FixApplicationStatus = "ISSUE_PERSISTS"
)

var AllFixApplicationStatus = []FixApplicationStatus{
	FixApplicationStatusAvailable,
	FixApplicationStatusApplying,
	FixApplicationStatusApplied,
	FixApplicationStatusFailed,
	FixApplicationStatusIssuePersists,
}

func (e FixApplicationStatus) IsValid() bool {
	switch e {
	case FixApplicationStatusAvailable, FixApplicationStatusApplying, FixApplicationStatusApplied, FixApplicationStatusFailed, FixApplicationStatusIssuePersists:
		return true
	}
	return false
}

func (e FixApplicationStatus) String() string {
	return string(e)
}

func (e *FixApplicationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FixApplicationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FixApplicationStatus", str)
	}
	return nil
}

func (e FixApplicationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Confidence level for a fix suggestion
type FixConfidence string

const (
	// High confidence this fix will resolve the issue
	FixConfidenceHigh FixConfidence = "HIGH"
	// Medium confidence, may resolve the issue
	FixConfidenceMedium FixConfidence = "MEDIUM"
	// Low confidence, worth trying as last resort
	FixConfidenceLow FixConfidence = "LOW"
)

var AllFixConfidence = []FixConfidence{
	FixConfidenceHigh,
	FixConfidenceMedium,
	FixConfidenceLow,
}

func (e FixConfidence) IsValid() bool {
	switch e {
	case FixConfidenceHigh, FixConfidenceMedium, FixConfidenceLow:
		return true
	}
	return false
}

func (e FixConfidence) String() string {
	return string(e)
}

func (e *FixConfidence) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FixConfidence(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FixConfidence", str)
	}
	return nil
}

func (e FixConfidence) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FrameTypes string

const (
	FrameTypesAdmitAll                     FrameTypes = "ADMIT_ALL"
	FrameTypesAdmitOnlyUntaggedAndPriority FrameTypes = "ADMIT_ONLY_UNTAGGED_AND_PRIORITY"
	FrameTypesAdmitOnlyVlanTagged          FrameTypes = "ADMIT_ONLY_VLAN_TAGGED"
)

var AllFrameTypes = []FrameTypes{
	FrameTypesAdmitAll,
	FrameTypesAdmitOnlyUntaggedAndPriority,
	FrameTypesAdmitOnlyVlanTagged,
}

func (e FrameTypes) IsValid() bool {
	switch e {
	case FrameTypesAdmitAll, FrameTypesAdmitOnlyUntaggedAndPriority, FrameTypesAdmitOnlyVlanTagged:
		return true
	}
	return false
}

func (e FrameTypes) String() string {
	return string(e)
}

func (e *FrameTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FrameTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FrameTypes", str)
	}
	return nil
}

func (e FrameTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health check status
type HealthCheckStatus string

const (
	// Target is reachable (healthy)
	HealthCheckStatusHealthy HealthCheckStatus = "HEALTHY"
	// Target is unreachable (unhealthy)
	HealthCheckStatusUnhealthy HealthCheckStatus = "UNHEALTHY"
	// Health check is disabled
	HealthCheckStatusDisabled HealthCheckStatus = "DISABLED"
	// Health check is starting
	HealthCheckStatusUnknown HealthCheckStatus = "UNKNOWN"
)

var AllHealthCheckStatus = []HealthCheckStatus{
	HealthCheckStatusHealthy,
	HealthCheckStatusUnhealthy,
	HealthCheckStatusDisabled,
	HealthCheckStatusUnknown,
}

func (e HealthCheckStatus) IsValid() bool {
	switch e {
	case HealthCheckStatusHealthy, HealthCheckStatusUnhealthy, HealthCheckStatusDisabled, HealthCheckStatusUnknown:
		return true
	}
	return false
}

func (e HealthCheckStatus) String() string {
	return string(e)
}

func (e *HealthCheckStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthCheckStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthCheckStatus", str)
	}
	return nil
}

func (e HealthCheckStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a single hop in a traceroute
type HopStatus string

const (
	// Hop responded successfully
	HopStatusSuccess HopStatus = "SUCCESS"
	// Hop did not respond (timeout)
	HopStatusTimeout HopStatus = "TIMEOUT"
	// Destination unreachable at this hop
	HopStatusUnreachable HopStatus = "UNREACHABLE"
	// Access prohibited (firewall/ACL)
	HopStatusProhibited HopStatus = "PROHIBITED"
)

var AllHopStatus = []HopStatus{
	HopStatusSuccess,
	HopStatusTimeout,
	HopStatusUnreachable,
	HopStatusProhibited,
}

func (e HopStatus) IsValid() bool {
	switch e {
	case HopStatusSuccess, HopStatusTimeout, HopStatusUnreachable, HopStatusProhibited:
		return true
	}
	return false
}

func (e HopStatus) String() string {
	return string(e)
}

func (e *HopStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HopStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HopStatus", str)
	}
	return nil
}

func (e HopStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Operational status of a network interface
type InterfaceStatus string

const (
	// Interface is up and running
	InterfaceStatusUp InterfaceStatus = "UP"
	// Interface is down
	InterfaceStatusDown InterfaceStatus = "DOWN"
	// Interface is disabled
	InterfaceStatusDisabled InterfaceStatus = "DISABLED"
	// Status unknown or error
	InterfaceStatusUnknown InterfaceStatus = "UNKNOWN"
)

var AllInterfaceStatus = []InterfaceStatus{
	InterfaceStatusUp,
	InterfaceStatusDown,
	InterfaceStatusDisabled,
	InterfaceStatusUnknown,
}

func (e InterfaceStatus) IsValid() bool {
	switch e {
	case InterfaceStatusUp, InterfaceStatusDown, InterfaceStatusDisabled, InterfaceStatusUnknown:
		return true
	}
	return false
}

func (e InterfaceStatus) String() string {
	return string(e)
}

func (e *InterfaceStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfaceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InterfaceStatus", str)
	}
	return nil
}

func (e InterfaceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of network interfaces
type InterfaceType string

const (
	InterfaceTypeEthernet InterfaceType = "ETHERNET"
	InterfaceTypeVlan     InterfaceType = "VLAN"
	InterfaceTypeBridge   InterfaceType = "BRIDGE"
	InterfaceTypeWireless InterfaceType = "WIRELESS"
	InterfaceTypeTunnel   InterfaceType = "TUNNEL"
	InterfaceTypePpp      InterfaceType = "PPP"
	InterfaceTypeBonding  InterfaceType = "BONDING"
	InterfaceTypeLoopback InterfaceType = "LOOPBACK"
	InterfaceTypeVirtual  InterfaceType = "VIRTUAL"
	InterfaceTypeOther    InterfaceType = "OTHER"
)

var AllInterfaceType = []InterfaceType{
	InterfaceTypeEthernet,
	InterfaceTypeVlan,
	InterfaceTypeBridge,
	InterfaceTypeWireless,
	InterfaceTypeTunnel,
	InterfaceTypePpp,
	InterfaceTypeBonding,
	InterfaceTypeLoopback,
	InterfaceTypeVirtual,
	InterfaceTypeOther,
}

func (e InterfaceType) IsValid() bool {
	switch e {
	case InterfaceTypeEthernet, InterfaceTypeVlan, InterfaceTypeBridge, InterfaceTypeWireless, InterfaceTypeTunnel, InterfaceTypePpp, InterfaceTypeBonding, InterfaceTypeLoopback, InterfaceTypeVirtual, InterfaceTypeOther:
		return true
	}
	return false
}

func (e InterfaceType) String() string {
	return string(e)
}

func (e *InterfaceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfaceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InterfaceType", str)
	}
	return nil
}

func (e InterfaceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of IP address conflict
type IPConflictType string

const (
	// Exact IP address match on different interface
	IPConflictTypeExact IPConflictType = "EXACT"
	// IP addresses are in overlapping subnets
	IPConflictTypeSubnetOverlap IPConflictType = "SUBNET_OVERLAP"
	// IP is the broadcast address of another subnet
	IPConflictTypeBroadcast IPConflictType = "BROADCAST"
	// IP is the network address of another subnet
	IPConflictTypeNetwork IPConflictType = "NETWORK"
)

var AllIPConflictType = []IPConflictType{
	IPConflictTypeExact,
	IPConflictTypeSubnetOverlap,
	IPConflictTypeBroadcast,
	IPConflictTypeNetwork,
}

func (e IPConflictType) IsValid() bool {
	switch e {
	case IPConflictTypeExact, IPConflictTypeSubnetOverlap, IPConflictTypeBroadcast, IPConflictTypeNetwork:
		return true
	}
	return false
}

func (e IPConflictType) String() string {
	return string(e)
}

func (e *IPConflictType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPConflictType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpConflictType", str)
	}
	return nil
}

func (e IPConflictType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Job status for async traceroute execution
type JobStatus string

const (
	// Job has been created
	JobStatusStarted JobStatus = "STARTED"
	// Job is currently running
	JobStatusRunning JobStatus = "RUNNING"
	// Job completed successfully
	JobStatusComplete JobStatus = "COMPLETE"
	// Job was cancelled by user
	JobStatusCancelled JobStatus = "CANCELLED"
	// Job encountered an error
	JobStatusError JobStatus = "ERROR"
)

var AllJobStatus = []JobStatus{
	JobStatusStarted,
	JobStatusRunning,
	JobStatusComplete,
	JobStatusCancelled,
	JobStatusError,
}

func (e JobStatus) IsValid() bool {
	switch e {
	case JobStatusStarted, JobStatusRunning, JobStatusComplete, JobStatusCancelled, JobStatusError:
		return true
	}
	return false
}

func (e JobStatus) String() string {
	return string(e)
}

func (e *JobStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobStatus", str)
	}
	return nil
}

func (e JobStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Port mode for VLAN configuration
type PortMode string

const (
	// Trunk port (carries multiple VLANs with tagging)
	PortModeTrunk PortMode = "TRUNK"
	// Access port (single VLAN, untagged)
	PortModeAccess PortMode = "ACCESS"
)

var AllPortMode = []PortMode{
	PortModeTrunk,
	PortModeAccess,
}

func (e PortMode) IsValid() bool {
	switch e {
	case PortModeTrunk, PortModeAccess:
		return true
	}
	return false
}

func (e PortMode) String() string {
	return string(e)
}

func (e *PortMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PortMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PortMode", str)
	}
	return nil
}

func (e PortMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Protocol used for router communication
type Protocol string

const (
	// REST API protocol (RouterOS 7.1+)
	ProtocolRest Protocol = "REST"
	// Binary API protocol (port 8728)
	ProtocolAPI Protocol = "API"
	// TLS-encrypted binary API (port 8729)
	ProtocolAPISsl Protocol = "API_SSL"
	// SSH protocol (port 22)
	ProtocolSSH Protocol = "SSH"
	// Telnet protocol (port 23)
	ProtocolTelnet Protocol = "TELNET"
)

var AllProtocol = []Protocol{
	ProtocolRest,
	ProtocolAPI,
	ProtocolAPISsl,
	ProtocolSSH,
	ProtocolTelnet,
}

func (e Protocol) IsValid() bool {
	switch e {
	case ProtocolRest, ProtocolAPI, ProtocolAPISsl, ProtocolSSH, ProtocolTelnet:
		return true
	}
	return false
}

func (e Protocol) String() string {
	return string(e)
}

func (e *Protocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Protocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Protocol", str)
	}
	return nil
}

func (e Protocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// User preference for which protocol to use when connecting to a router.
// AUTO will try protocols in the recommended fallback order.
type ProtocolPreference string

const (
	// Automatically detect best protocol (REST -> API -> API_SSL -> SSH -> Telnet)
	ProtocolPreferenceAuto ProtocolPreference = "AUTO"
	// Force REST API protocol (RouterOS 7.1+)
	ProtocolPreferenceRest ProtocolPreference = "REST"
	// Force Binary API protocol (port 8728)
	ProtocolPreferenceAPI ProtocolPreference = "API"
	// Force TLS-encrypted binary API (port 8729)
	ProtocolPreferenceAPISsl ProtocolPreference = "API_SSL"
	// Force SSH protocol (port 22)
	ProtocolPreferenceSSH ProtocolPreference = "SSH"
	// Force Telnet protocol (port 23, insecure - use only as last resort)
	ProtocolPreferenceTelnet ProtocolPreference = "TELNET"
)

var AllProtocolPreference = []ProtocolPreference{
	ProtocolPreferenceAuto,
	ProtocolPreferenceRest,
	ProtocolPreferenceAPI,
	ProtocolPreferenceAPISsl,
	ProtocolPreferenceSSH,
	ProtocolPreferenceTelnet,
}

func (e ProtocolPreference) IsValid() bool {
	switch e {
	case ProtocolPreferenceAuto, ProtocolPreferenceRest, ProtocolPreferenceAPI, ProtocolPreferenceAPISsl, ProtocolPreferenceSSH, ProtocolPreferenceTelnet:
		return true
	}
	return false
}

func (e ProtocolPreference) String() string {
	return string(e)
}

func (e *ProtocolPreference) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProtocolPreference(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProtocolPreference", str)
	}
	return nil
}

func (e ProtocolPreference) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Categories of managed resources
type ResourceCategory string

const (
	// Network topology: WAN Links, LAN Networks, VLANs
	ResourceCategoryNetwork ResourceCategory = "NETWORK"
	// VPN connectivity: WireGuard, OpenVPN, IPsec
	ResourceCategoryVpn ResourceCategory = "VPN"
	// System infrastructure: Certificates, NTP, DDNS
	ResourceCategoryInfrastructure ResourceCategory = "INFRASTRUCTURE"
	// Application-level: Port Forwarding, Game Rules
	ResourceCategoryApplication ResourceCategory = "APPLICATION"
	// Marketplace features: Tor, AdGuard, sing-box
	ResourceCategoryFeature ResourceCategory = "FEATURE"
	// Community extensions: Third-party plugins
	ResourceCategoryPlugin ResourceCategory = "PLUGIN"
)

var AllResourceCategory = []ResourceCategory{
	ResourceCategoryNetwork,
	ResourceCategoryVpn,
	ResourceCategoryInfrastructure,
	ResourceCategoryApplication,
	ResourceCategoryFeature,
	ResourceCategoryPlugin,
}

func (e ResourceCategory) IsValid() bool {
	switch e {
	case ResourceCategoryNetwork, ResourceCategoryVpn, ResourceCategoryInfrastructure, ResourceCategoryApplication, ResourceCategoryFeature, ResourceCategoryPlugin:
		return true
	}
	return false
}

func (e ResourceCategory) String() string {
	return string(e)
}

func (e *ResourceCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceCategory", str)
	}
	return nil
}

func (e ResourceCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Impact level for affected resources
type ResourceImpact string

const (
	// Resource will be modified
	ResourceImpactModified ResourceImpact = "MODIFIED"
	// Resource will be disabled
	ResourceImpactDisabled ResourceImpact = "DISABLED"
	// Resource will be removed
	ResourceImpactRemoved ResourceImpact = "REMOVED"
	// Connections will be dropped
	ResourceImpactConnectionDrop ResourceImpact = "CONNECTION_DROP"
)

var AllResourceImpact = []ResourceImpact{
	ResourceImpactModified,
	ResourceImpactDisabled,
	ResourceImpactRemoved,
	ResourceImpactConnectionDrop,
}

func (e ResourceImpact) IsValid() bool {
	switch e {
	case ResourceImpactModified, ResourceImpactDisabled, ResourceImpactRemoved, ResourceImpactConnectionDrop:
		return true
	}
	return false
}

func (e ResourceImpact) String() string {
	return string(e)
}

func (e *ResourceImpact) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceImpact(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceImpact", str)
	}
	return nil
}

func (e ResourceImpact) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Selectable resource layers for optimized fetching
type ResourceLayer string

const (
	ResourceLayerConfiguration ResourceLayer = "CONFIGURATION"
	ResourceLayerValidation    ResourceLayer = "VALIDATION"
	ResourceLayerDeployment    ResourceLayer = "DEPLOYMENT"
	ResourceLayerRuntime       ResourceLayer = "RUNTIME"
	ResourceLayerTelemetry     ResourceLayer = "TELEMETRY"
	ResourceLayerMetadata      ResourceLayer = "METADATA"
	ResourceLayerRelationships ResourceLayer = "RELATIONSHIPS"
	ResourceLayerPlatform      ResourceLayer = "PLATFORM"
)

var AllResourceLayer = []ResourceLayer{
	ResourceLayerConfiguration,
	ResourceLayerValidation,
	ResourceLayerDeployment,
	ResourceLayerRuntime,
	ResourceLayerTelemetry,
	ResourceLayerMetadata,
	ResourceLayerRelationships,
	ResourceLayerPlatform,
}

func (e ResourceLayer) IsValid() bool {
	switch e {
	case ResourceLayerConfiguration, ResourceLayerValidation, ResourceLayerDeployment, ResourceLayerRuntime, ResourceLayerTelemetry, ResourceLayerMetadata, ResourceLayerRelationships, ResourceLayerPlatform:
		return true
	}
	return false
}

func (e ResourceLayer) String() string {
	return string(e)
}

func (e *ResourceLayer) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceLayer(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceLayer", str)
	}
	return nil
}

func (e ResourceLayer) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Resource lifecycle states for state machine
type ResourceLifecycleState string

const (
	// Initial creation, not yet validated
	ResourceLifecycleStateDraft ResourceLifecycleState = "DRAFT"
	// Backend validation in progress
	ResourceLifecycleStateValidating ResourceLifecycleState = "VALIDATING"
	// Passed validation, ready to apply
	ResourceLifecycleStateValid ResourceLifecycleState = "VALID"
	// Being applied to router
	ResourceLifecycleStateApplying ResourceLifecycleState = "APPLYING"
	// Successfully applied and running
	ResourceLifecycleStateActive ResourceLifecycleState = "ACTIVE"
	// Running but with issues
	ResourceLifecycleStateDegraded ResourceLifecycleState = "DEGRADED"
	// Failed state (validation or apply)
	ResourceLifecycleStateError ResourceLifecycleState = "ERROR"
	// Marked for removal
	ResourceLifecycleStateDeprecated ResourceLifecycleState = "DEPRECATED"
	// Final state, no longer active
	ResourceLifecycleStateArchived ResourceLifecycleState = "ARCHIVED"
)

var AllResourceLifecycleState = []ResourceLifecycleState{
	ResourceLifecycleStateDraft,
	ResourceLifecycleStateValidating,
	ResourceLifecycleStateValid,
	ResourceLifecycleStateApplying,
	ResourceLifecycleStateActive,
	ResourceLifecycleStateDegraded,
	ResourceLifecycleStateError,
	ResourceLifecycleStateDeprecated,
	ResourceLifecycleStateArchived,
}

func (e ResourceLifecycleState) IsValid() bool {
	switch e {
	case ResourceLifecycleStateDraft, ResourceLifecycleStateValidating, ResourceLifecycleStateValid, ResourceLifecycleStateApplying, ResourceLifecycleStateActive, ResourceLifecycleStateDegraded, ResourceLifecycleStateError, ResourceLifecycleStateDeprecated, ResourceLifecycleStateArchived:
		return true
	}
	return false
}

func (e ResourceLifecycleState) String() string {
	return string(e)
}

func (e *ResourceLifecycleState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceLifecycleState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceLifecycleState", str)
	}
	return nil
}

func (e ResourceLifecycleState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of relationships between resources
type ResourceRelationshipType string

const (
	// Child depends on parent
	ResourceRelationshipTypeDependsOn ResourceRelationshipType = "DEPENDS_ON"
	// Traffic routes via this resource
	ResourceRelationshipTypeRoutesVia ResourceRelationshipType = "ROUTES_VIA"
	// Parent-child hierarchy
	ResourceRelationshipTypeParentChild ResourceRelationshipType = "PARENT_CHILD"
	// Resources are in the same group
	ResourceRelationshipTypeGroup ResourceRelationshipType = "GROUP"
	// Custom relationship
	ResourceRelationshipTypeCustom ResourceRelationshipType = "CUSTOM"
)

var AllResourceRelationshipType = []ResourceRelationshipType{
	ResourceRelationshipTypeDependsOn,
	ResourceRelationshipTypeRoutesVia,
	ResourceRelationshipTypeParentChild,
	ResourceRelationshipTypeGroup,
	ResourceRelationshipTypeCustom,
}

func (e ResourceRelationshipType) IsValid() bool {
	switch e {
	case ResourceRelationshipTypeDependsOn, ResourceRelationshipTypeRoutesVia, ResourceRelationshipTypeParentChild, ResourceRelationshipTypeGroup, ResourceRelationshipTypeCustom:
		return true
	}
	return false
}

func (e ResourceRelationshipType) String() string {
	return string(e)
}

func (e *ResourceRelationshipType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceRelationshipType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceRelationshipType", str)
	}
	return nil
}

func (e ResourceRelationshipType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Rollback operation type
type RollbackOperation string

const (
	// Delete a created resource
	RollbackOperationDelete RollbackOperation = "DELETE"
	// Restore a deleted resource
	RollbackOperationRestore RollbackOperation = "RESTORE"
	// Revert an updated resource
	RollbackOperationRevert RollbackOperation = "REVERT"
)

var AllRollbackOperation = []RollbackOperation{
	RollbackOperationDelete,
	RollbackOperationRestore,
	RollbackOperationRevert,
}

func (e RollbackOperation) IsValid() bool {
	switch e {
	case RollbackOperationDelete, RollbackOperationRestore, RollbackOperationRevert:
		return true
	}
	return false
}

func (e RollbackOperation) String() string {
	return string(e)
}

func (e *RollbackOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RollbackOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RollbackOperation", str)
	}
	return nil
}

func (e RollbackOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Route scope
type RouteScope string

const (
	// Global route (forwarded between interfaces)
	RouteScopeGlobal RouteScope = "GLOBAL"
	// Link-local route (not forwarded)
	RouteScopeLink RouteScope = "LINK"
	// Host-local route
	RouteScopeHost RouteScope = "HOST"
)

var AllRouteScope = []RouteScope{
	RouteScopeGlobal,
	RouteScopeLink,
	RouteScopeHost,
}

func (e RouteScope) IsValid() bool {
	switch e {
	case RouteScopeGlobal, RouteScopeLink, RouteScopeHost:
		return true
	}
	return false
}

func (e RouteScope) String() string {
	return string(e)
}

func (e *RouteScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RouteScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RouteScope", str)
	}
	return nil
}

func (e RouteScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Route type classification
type RouteType string

const (
	// Static route (manually configured)
	RouteTypeStatic RouteType = "STATIC"
	// Connected route (directly connected network)
	RouteTypeConnected RouteType = "CONNECTED"
	// Dynamic route (learned via routing protocol)
	RouteTypeDynamic RouteType = "DYNAMIC"
	// BGP route
	RouteTypeBgp RouteType = "BGP"
	// OSPF route
	RouteTypeOspf RouteType = "OSPF"
)

var AllRouteType = []RouteType{
	RouteTypeStatic,
	RouteTypeConnected,
	RouteTypeDynamic,
	RouteTypeBgp,
	RouteTypeOspf,
}

func (e RouteType) IsValid() bool {
	switch e {
	case RouteTypeStatic, RouteTypeConnected, RouteTypeDynamic, RouteTypeBgp, RouteTypeOspf:
		return true
	}
	return false
}

func (e RouteType) String() string {
	return string(e)
}

func (e *RouteType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RouteType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RouteType", str)
	}
	return nil
}

func (e RouteType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported router platforms
type RouterPlatform string

const (
	// MikroTik RouterOS
	RouterPlatformMikrotik RouterPlatform = "MIKROTIK"
	// OpenWrt
	RouterPlatformOpenwrt RouterPlatform = "OPENWRT"
	// VyOS
	RouterPlatformVyos RouterPlatform = "VYOS"
	// Generic/Unknown
	RouterPlatformGeneric RouterPlatform = "GENERIC"
)

var AllRouterPlatform = []RouterPlatform{
	RouterPlatformMikrotik,
	RouterPlatformOpenwrt,
	RouterPlatformVyos,
	RouterPlatformGeneric,
}

func (e RouterPlatform) IsValid() bool {
	switch e {
	case RouterPlatformMikrotik, RouterPlatformOpenwrt, RouterPlatformVyos, RouterPlatformGeneric:
		return true
	}
	return false
}

func (e RouterPlatform) String() string {
	return string(e)
}

func (e *RouterPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RouterPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RouterPlatform", str)
	}
	return nil
}

func (e RouterPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Runtime health status
type RuntimeHealth string

const (
	// Resource is healthy and operating normally
	RuntimeHealthHealthy RuntimeHealth = "HEALTHY"
	// Resource is running but with warnings
	RuntimeHealthWarning RuntimeHealth = "WARNING"
	// Resource is running but degraded
	RuntimeHealthDegraded RuntimeHealth = "DEGRADED"
	// Resource has failed
	RuntimeHealthFailed RuntimeHealth = "FAILED"
	// Health status unknown
	RuntimeHealthUnknown RuntimeHealth = "UNKNOWN"
)

var AllRuntimeHealth = []RuntimeHealth{
	RuntimeHealthHealthy,
	RuntimeHealthWarning,
	RuntimeHealthDegraded,
	RuntimeHealthFailed,
	RuntimeHealthUnknown,
}

func (e RuntimeHealth) IsValid() bool {
	switch e {
	case RuntimeHealthHealthy, RuntimeHealthWarning, RuntimeHealthDegraded, RuntimeHealthFailed, RuntimeHealthUnknown:
		return true
	}
	return false
}

func (e RuntimeHealth) String() string {
	return string(e)
}

func (e *RuntimeHealth) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuntimeHealth(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuntimeHealth", str)
	}
	return nil
}

func (e RuntimeHealth) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a network scan operation
type ScanStatus string

const (
	// Scan is queued and waiting to start
	ScanStatusPending ScanStatus = "PENDING"
	// Scan is actively running
	ScanStatusRunning ScanStatus = "RUNNING"
	// Scan completed successfully
	ScanStatusCompleted ScanStatus = "COMPLETED"
	// Scan was cancelled by user
	ScanStatusCancelled ScanStatus = "CANCELLED"
	// Scan failed with an error
	ScanStatusFailed ScanStatus = "FAILED"
)

var AllScanStatus = []ScanStatus{
	ScanStatusPending,
	ScanStatusRunning,
	ScanStatusCompleted,
	ScanStatusCancelled,
	ScanStatusFailed,
}

func (e ScanStatus) IsValid() bool {
	switch e {
	case ScanStatusPending, ScanStatusRunning, ScanStatusCompleted, ScanStatusCancelled, ScanStatusFailed:
		return true
	}
	return false
}

func (e ScanStatus) String() string {
	return string(e)
}

func (e *ScanStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScanStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScanStatus", str)
	}
	return nil
}

func (e ScanStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Service operational status
type ServiceStatus string

const (
	// Service is fully operational
	ServiceStatusHealthy ServiceStatus = "HEALTHY"
	// Service is operational with degraded performance
	ServiceStatusDegraded ServiceStatus = "DEGRADED"
	// Service is not operational
	ServiceStatusUnhealthy ServiceStatus = "UNHEALTHY"
)

var AllServiceStatus = []ServiceStatus{
	ServiceStatusHealthy,
	ServiceStatusDegraded,
	ServiceStatusUnhealthy,
}

func (e ServiceStatus) IsValid() bool {
	switch e {
	case ServiceStatusHealthy, ServiceStatusDegraded, ServiceStatusUnhealthy:
		return true
	}
	return false
}

func (e ServiceStatus) String() string {
	return string(e)
}

func (e *ServiceStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceStatus", str)
	}
	return nil
}

func (e ServiceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StpPortRole string

const (
	StpPortRoleRoot       StpPortRole = "ROOT"
	StpPortRoleDesignated StpPortRole = "DESIGNATED"
	StpPortRoleAlternate  StpPortRole = "ALTERNATE"
	StpPortRoleBackup     StpPortRole = "BACKUP"
	StpPortRoleDisabled   StpPortRole = "DISABLED"
)

var AllStpPortRole = []StpPortRole{
	StpPortRoleRoot,
	StpPortRoleDesignated,
	StpPortRoleAlternate,
	StpPortRoleBackup,
	StpPortRoleDisabled,
}

func (e StpPortRole) IsValid() bool {
	switch e {
	case StpPortRoleRoot, StpPortRoleDesignated, StpPortRoleAlternate, StpPortRoleBackup, StpPortRoleDisabled:
		return true
	}
	return false
}

func (e StpPortRole) String() string {
	return string(e)
}

func (e *StpPortRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StpPortRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StpPortRole", str)
	}
	return nil
}

func (e StpPortRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StpPortState string

const (
	StpPortStateDisabled   StpPortState = "DISABLED"
	StpPortStateBlocking   StpPortState = "BLOCKING"
	StpPortStateListening  StpPortState = "LISTENING"
	StpPortStateLearning   StpPortState = "LEARNING"
	StpPortStateForwarding StpPortState = "FORWARDING"
)

var AllStpPortState = []StpPortState{
	StpPortStateDisabled,
	StpPortStateBlocking,
	StpPortStateListening,
	StpPortStateLearning,
	StpPortStateForwarding,
}

func (e StpPortState) IsValid() bool {
	switch e {
	case StpPortStateDisabled, StpPortStateBlocking, StpPortStateListening, StpPortStateLearning, StpPortStateForwarding:
		return true
	}
	return false
}

func (e StpPortState) String() string {
	return string(e)
}

func (e *StpPortState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StpPortState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StpPortState", str)
	}
	return nil
}

func (e StpPortState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StpProtocol string

const (
	StpProtocolNone StpProtocol = "NONE"
	StpProtocolStp  StpProtocol = "STP"
	StpProtocolRstp StpProtocol = "RSTP"
	StpProtocolMstp StpProtocol = "MSTP"
)

var AllStpProtocol = []StpProtocol{
	StpProtocolNone,
	StpProtocolStp,
	StpProtocolRstp,
	StpProtocolMstp,
}

func (e StpProtocol) IsValid() bool {
	switch e {
	case StpProtocolNone, StpProtocolStp, StpProtocolRstp, StpProtocolMstp:
		return true
	}
	return false
}

func (e StpProtocol) String() string {
	return string(e)
}

func (e *StpProtocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StpProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StpProtocol", str)
	}
	return nil
}

func (e StpProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Severity level for diagnostic suggestions
type SuggestionSeverity string

const (
	// Informational message, no action required
	SuggestionSeverityInfo SuggestionSeverity = "INFO"
	// Warning that may affect functionality
	SuggestionSeverityWarning SuggestionSeverity = "WARNING"
	// Error that needs to be addressed
	SuggestionSeverityError SuggestionSeverity = "ERROR"
	// Critical issue blocking connectivity
	SuggestionSeverityCritical SuggestionSeverity = "CRITICAL"
)

var AllSuggestionSeverity = []SuggestionSeverity{
	SuggestionSeverityInfo,
	SuggestionSeverityWarning,
	SuggestionSeverityError,
	SuggestionSeverityCritical,
}

func (e SuggestionSeverity) IsValid() bool {
	switch e {
	case SuggestionSeverityInfo, SuggestionSeverityWarning, SuggestionSeverityError, SuggestionSeverityCritical:
		return true
	}
	return false
}

func (e SuggestionSeverity) String() string {
	return string(e)
}

func (e *SuggestionSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SuggestionSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SuggestionSeverity", str)
	}
	return nil
}

func (e SuggestionSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of topology node
type TopologyNodeType string

const (
	// Bridge interface
	TopologyNodeTypeBridge TopologyNodeType = "BRIDGE"
	// VLAN interface
	TopologyNodeTypeVlan TopologyNodeType = "VLAN"
	// Physical port
	TopologyNodeTypePort TopologyNodeType = "PORT"
)

var AllTopologyNodeType = []TopologyNodeType{
	TopologyNodeTypeBridge,
	TopologyNodeTypeVlan,
	TopologyNodeTypePort,
}

func (e TopologyNodeType) IsValid() bool {
	switch e {
	case TopologyNodeTypeBridge, TopologyNodeTypeVlan, TopologyNodeTypePort:
		return true
	}
	return false
}

func (e TopologyNodeType) String() string {
	return string(e)
}

func (e *TopologyNodeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TopologyNodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TopologyNodeType", str)
	}
	return nil
}

func (e TopologyNodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Event type for traceroute progress updates
type TracerouteEventType string

const (
	// A new hop was discovered
	TracerouteEventTypeHopDiscovered TracerouteEventType = "HOP_DISCOVERED"
	// Traceroute completed
	TracerouteEventTypeComplete TracerouteEventType = "COMPLETE"
	// Traceroute encountered an error
	TracerouteEventTypeError TracerouteEventType = "ERROR"
	// Traceroute was cancelled
	TracerouteEventTypeCancelled TracerouteEventType = "CANCELLED"
)

var AllTracerouteEventType = []TracerouteEventType{
	TracerouteEventTypeHopDiscovered,
	TracerouteEventTypeComplete,
	TracerouteEventTypeError,
	TracerouteEventTypeCancelled,
}

func (e TracerouteEventType) IsValid() bool {
	switch e {
	case TracerouteEventTypeHopDiscovered, TracerouteEventTypeComplete, TracerouteEventTypeError, TracerouteEventTypeCancelled:
		return true
	}
	return false
}

func (e TracerouteEventType) String() string {
	return string(e)
}

func (e *TracerouteEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TracerouteEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TracerouteEventType", str)
	}
	return nil
}

func (e TracerouteEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Protocol to use for traceroute probes
type TracerouteProtocol string

const (
	// ICMP echo request (default)
	TracerouteProtocolICMP TracerouteProtocol = "ICMP"
	// UDP probes
	TracerouteProtocolUDP TracerouteProtocol = "UDP"
	// TCP SYN probes
	TracerouteProtocolTCP TracerouteProtocol = "TCP"
)

var AllTracerouteProtocol = []TracerouteProtocol{
	TracerouteProtocolICMP,
	TracerouteProtocolUDP,
	TracerouteProtocolTCP,
}

func (e TracerouteProtocol) IsValid() bool {
	switch e {
	case TracerouteProtocolICMP, TracerouteProtocolUDP, TracerouteProtocolTCP:
		return true
	}
	return false
}

func (e TracerouteProtocol) String() string {
	return string(e)
}

func (e *TracerouteProtocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TracerouteProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TracerouteProtocol", str)
	}
	return nil
}

func (e TracerouteProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Overall status of a troubleshooting session
type TroubleshootSessionStatus string

const (
	// Session created but not started
	TroubleshootSessionStatusIdle TroubleshootSessionStatus = "IDLE"
	// Detecting network configuration
	TroubleshootSessionStatusInitializing TroubleshootSessionStatus = "INITIALIZING"
	// Running diagnostic steps
	TroubleshootSessionStatusRunning TroubleshootSessionStatus = "RUNNING"
	// Waiting for user decision on fix
	TroubleshootSessionStatusAwaitingFixDecision TroubleshootSessionStatus = "AWAITING_FIX_DECISION"
	// Applying a fix
	TroubleshootSessionStatusApplyingFix TroubleshootSessionStatus = "APPLYING_FIX"
	// Verifying fix worked
	TroubleshootSessionStatusVerifyingFix TroubleshootSessionStatus = "VERIFYING_FIX"
	// Session completed
	TroubleshootSessionStatusCompleted TroubleshootSessionStatus = "COMPLETED"
	// Session was cancelled
	TroubleshootSessionStatusCancelled TroubleshootSessionStatus = "CANCELLED"
)

var AllTroubleshootSessionStatus = []TroubleshootSessionStatus{
	TroubleshootSessionStatusIdle,
	TroubleshootSessionStatusInitializing,
	TroubleshootSessionStatusRunning,
	TroubleshootSessionStatusAwaitingFixDecision,
	TroubleshootSessionStatusApplyingFix,
	TroubleshootSessionStatusVerifyingFix,
	TroubleshootSessionStatusCompleted,
	TroubleshootSessionStatusCancelled,
}

func (e TroubleshootSessionStatus) IsValid() bool {
	switch e {
	case TroubleshootSessionStatusIdle, TroubleshootSessionStatusInitializing, TroubleshootSessionStatusRunning, TroubleshootSessionStatusAwaitingFixDecision, TroubleshootSessionStatusApplyingFix, TroubleshootSessionStatusVerifyingFix, TroubleshootSessionStatusCompleted, TroubleshootSessionStatusCancelled:
		return true
	}
	return false
}

func (e TroubleshootSessionStatus) String() string {
	return string(e)
}

func (e *TroubleshootSessionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TroubleshootSessionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TroubleshootSessionStatus", str)
	}
	return nil
}

func (e TroubleshootSessionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a diagnostic step
type TroubleshootStepStatus string

const (
	// Step not yet started
	TroubleshootStepStatusPending TroubleshootStepStatus = "PENDING"
	// Step currently executing
	TroubleshootStepStatusRunning TroubleshootStepStatus = "RUNNING"
	// Step completed successfully
	TroubleshootStepStatusPassed TroubleshootStepStatus = "PASSED"
	// Step failed
	TroubleshootStepStatusFailed TroubleshootStepStatus = "FAILED"
	// Step skipped
	TroubleshootStepStatusSkipped TroubleshootStepStatus = "SKIPPED"
)

var AllTroubleshootStepStatus = []TroubleshootStepStatus{
	TroubleshootStepStatusPending,
	TroubleshootStepStatusRunning,
	TroubleshootStepStatusPassed,
	TroubleshootStepStatusFailed,
	TroubleshootStepStatusSkipped,
}

func (e TroubleshootStepStatus) IsValid() bool {
	switch e {
	case TroubleshootStepStatusPending, TroubleshootStepStatusRunning, TroubleshootStepStatusPassed, TroubleshootStepStatusFailed, TroubleshootStepStatusSkipped:
		return true
	}
	return false
}

func (e TroubleshootStepStatus) String() string {
	return string(e)
}

func (e *TroubleshootStepStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TroubleshootStepStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TroubleshootStepStatus", str)
	}
	return nil
}

func (e TroubleshootStepStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Diagnostic step identifier for internet troubleshooting
type TroubleshootStepType string

const (
	// Check WAN interface status
	TroubleshootStepTypeWan TroubleshootStepType = "WAN"
	// Ping default gateway
	TroubleshootStepTypeGateway TroubleshootStepType = "GATEWAY"
	// Ping external internet server
	TroubleshootStepTypeInternet TroubleshootStepType = "INTERNET"
	// Test DNS resolution
	TroubleshootStepTypeDNS TroubleshootStepType = "DNS"
	// Verify NAT/masquerade rules
	TroubleshootStepTypeNat TroubleshootStepType = "NAT"
)

var AllTroubleshootStepType = []TroubleshootStepType{
	TroubleshootStepTypeWan,
	TroubleshootStepTypeGateway,
	TroubleshootStepTypeInternet,
	TroubleshootStepTypeDNS,
	TroubleshootStepTypeNat,
}

func (e TroubleshootStepType) IsValid() bool {
	switch e {
	case TroubleshootStepTypeWan, TroubleshootStepTypeGateway, TroubleshootStepTypeInternet, TroubleshootStepTypeDNS, TroubleshootStepTypeNat:
		return true
	}
	return false
}

func (e TroubleshootStepType) String() string {
	return string(e)
}

func (e *TroubleshootStepType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TroubleshootStepType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TroubleshootStepType", str)
	}
	return nil
}

func (e TroubleshootStepType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Priority level for upgrade recommendations
type UpgradePriority string

const (
	// Security-related, should upgrade immediately
	UpgradePriorityCritical UpgradePriority = "CRITICAL"
	// Highly recommended for stability/features
	UpgradePriorityHigh UpgradePriority = "HIGH"
	// Recommended but not urgent
	UpgradePriorityMedium UpgradePriority = "MEDIUM"
	// Nice to have, optional
	UpgradePriorityLow UpgradePriority = "LOW"
)

var AllUpgradePriority = []UpgradePriority{
	UpgradePriorityCritical,
	UpgradePriorityHigh,
	UpgradePriorityMedium,
	UpgradePriorityLow,
}

func (e UpgradePriority) IsValid() bool {
	switch e {
	case UpgradePriorityCritical, UpgradePriorityHigh, UpgradePriorityMedium, UpgradePriorityLow:
		return true
	}
	return false
}

func (e UpgradePriority) String() string {
	return string(e)
}

func (e *UpgradePriority) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpgradePriority(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpgradePriority", str)
	}
	return nil
}

func (e UpgradePriority) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Predefined validation formats for common data types
type ValidateFormat string

const (
	ValidateFormatEmail    ValidateFormat = "EMAIL"
	ValidateFormatURL      ValidateFormat = "URL"
	ValidateFormatUUID     ValidateFormat = "UUID"
	ValidateFormatIPV4     ValidateFormat = "IPV4"
	ValidateFormatIPV6     ValidateFormat = "IPV6"
	ValidateFormatMac      ValidateFormat = "MAC"
	ValidateFormatCidr     ValidateFormat = "CIDR"
	ValidateFormatHostname ValidateFormat = "HOSTNAME"
	ValidateFormatFqdn     ValidateFormat = "FQDN"
)

var AllValidateFormat = []ValidateFormat{
	ValidateFormatEmail,
	ValidateFormatURL,
	ValidateFormatUUID,
	ValidateFormatIPV4,
	ValidateFormatIPV6,
	ValidateFormatMac,
	ValidateFormatCidr,
	ValidateFormatHostname,
	ValidateFormatFqdn,
}

func (e ValidateFormat) IsValid() bool {
	switch e {
	case ValidateFormatEmail, ValidateFormatURL, ValidateFormatUUID, ValidateFormatIPV4, ValidateFormatIPV6, ValidateFormatMac, ValidateFormatCidr, ValidateFormatHostname, ValidateFormatFqdn:
		return true
	}
	return false
}

func (e ValidateFormat) String() string {
	return string(e)
}

func (e *ValidateFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidateFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidateFormat", str)
	}
	return nil
}

func (e ValidateFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation issue severity
type ValidationSeverity string

const (
	// Blocks apply, must be fixed
	ValidationSeverityError ValidationSeverity = "ERROR"
	// Does not block, but recommended to address
	ValidationSeverityWarning ValidationSeverity = "WARNING"
	// Informational notice
	ValidationSeverityInfo ValidationSeverity = "INFO"
)

var AllValidationSeverity = []ValidationSeverity{
	ValidationSeverityError,
	ValidationSeverityWarning,
	ValidationSeverityInfo,
}

func (e ValidationSeverity) IsValid() bool {
	switch e {
	case ValidationSeverityError, ValidationSeverityWarning, ValidationSeverityInfo:
		return true
	}
	return false
}

func (e ValidationSeverity) String() string {
	return string(e)
}

func (e *ValidationSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidationSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidationSeverity", str)
	}
	return nil
}

func (e ValidationSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation pipeline stages
type ValidationStage string

const (
	// Schema validation (Zod/GraphQL)
	ValidationStageSchema ValidationStage = "SCHEMA"
	// Semantic validation (business rules)
	ValidationStageSemantic ValidationStage = "SEMANTIC"
	// Dependency validation (required resources exist)
	ValidationStageDependency ValidationStage = "DEPENDENCY"
	// Conflict detection (port/IP/route conflicts)
	ValidationStageConflict ValidationStage = "CONFLICT"
	// Platform validation (capability checks)
	ValidationStagePlatform ValidationStage = "PLATFORM"
	// Quota validation (resource limits)
	ValidationStageQuota ValidationStage = "QUOTA"
	// Pre-flight simulation
	ValidationStageSimulation ValidationStage = "SIMULATION"
	// All stages complete
	ValidationStageComplete ValidationStage = "COMPLETE"
)

var AllValidationStage = []ValidationStage{
	ValidationStageSchema,
	ValidationStageSemantic,
	ValidationStageDependency,
	ValidationStageConflict,
	ValidationStagePlatform,
	ValidationStageQuota,
	ValidationStageSimulation,
	ValidationStageComplete,
}

func (e ValidationStage) IsValid() bool {
	switch e {
	case ValidationStageSchema, ValidationStageSemantic, ValidationStageDependency, ValidationStageConflict, ValidationStagePlatform, ValidationStageQuota, ValidationStageSimulation, ValidationStageComplete:
		return true
	}
	return false
}

func (e ValidationStage) String() string {
	return string(e)
}

func (e *ValidationStage) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidationStage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidationStage", str)
	}
	return nil
}

func (e ValidationStage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// WAN connection type classification
type WANConnectionType string

const (
	// DHCP client (dynamic IP)
	WANConnectionTypeDhcp WANConnectionType = "DHCP"
	// PPPoE dial-up connection
	WANConnectionTypePppoe WANConnectionType = "PPPOE"
	// Static IP configuration
	WANConnectionTypeStatic WANConnectionType = "STATIC"
	// LTE/cellular connection
	WANConnectionTypeLte WANConnectionType = "LTE"
	// Not configured
	WANConnectionTypeNone WANConnectionType = "NONE"
)

var AllWANConnectionType = []WANConnectionType{
	WANConnectionTypeDhcp,
	WANConnectionTypePppoe,
	WANConnectionTypeStatic,
	WANConnectionTypeLte,
	WANConnectionTypeNone,
}

func (e WANConnectionType) IsValid() bool {
	switch e {
	case WANConnectionTypeDhcp, WANConnectionTypePppoe, WANConnectionTypeStatic, WANConnectionTypeLte, WANConnectionTypeNone:
		return true
	}
	return false
}

func (e WANConnectionType) String() string {
	return string(e)
}

func (e *WANConnectionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WANConnectionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WANConnectionType", str)
	}
	return nil
}

func (e WANConnectionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// WAN event types for history tracking
type WANEventType string

const (
	// Connection established
	WANEventTypeConnected WANEventType = "CONNECTED"
	// Connection lost
	WANEventTypeDisconnected WANEventType = "DISCONNECTED"
	// Authentication failed
	WANEventTypeAuthFailed WANEventType = "AUTH_FAILED"
	// IP address changed
	WANEventTypeIPChanged WANEventType = "IP_CHANGED"
	// Gateway changed
	WANEventTypeGatewayChanged WANEventType = "GATEWAY_CHANGED"
	// Health check failed
	WANEventTypeHealthFailed WANEventType = "HEALTH_FAILED"
	// Health check recovered
	WANEventTypeHealthRecovered WANEventType = "HEALTH_RECOVERED"
)

var AllWANEventType = []WANEventType{
	WANEventTypeConnected,
	WANEventTypeDisconnected,
	WANEventTypeAuthFailed,
	WANEventTypeIPChanged,
	WANEventTypeGatewayChanged,
	WANEventTypeHealthFailed,
	WANEventTypeHealthRecovered,
}

func (e WANEventType) IsValid() bool {
	switch e {
	case WANEventTypeConnected, WANEventTypeDisconnected, WANEventTypeAuthFailed, WANEventTypeIPChanged, WANEventTypeGatewayChanged, WANEventTypeHealthFailed, WANEventTypeHealthRecovered:
		return true
	}
	return false
}

func (e WANEventType) String() string {
	return string(e)
}

func (e *WANEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WANEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WANEventType", str)
	}
	return nil
}

func (e WANEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// WAN connection status
type WANStatus string

const (
	// Connected and online
	WANStatusConnected WANStatus = "CONNECTED"
	// Connecting/authenticating
	WANStatusConnecting WANStatus = "CONNECTING"
	// Disconnected
	WANStatusDisconnected WANStatus = "DISCONNECTED"
	// Connection failed
	WANStatusError WANStatus = "ERROR"
	// Disabled
	WANStatusDisabled WANStatus = "DISABLED"
)

var AllWANStatus = []WANStatus{
	WANStatusConnected,
	WANStatusConnecting,
	WANStatusDisconnected,
	WANStatusError,
	WANStatusDisabled,
}

func (e WANStatus) IsValid() bool {
	switch e {
	case WANStatusConnected, WANStatusConnecting, WANStatusDisconnected, WANStatusError, WANStatusDisabled:
		return true
	}
	return false
}

func (e WANStatus) String() string {
	return string(e)
}

func (e *WANStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WANStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WANStatus", str)
	}
	return nil
}

func (e WANStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
