// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

// Connection interface for paginated results (Relay pagination)
type Connection interface {
	IsConnection()
}

// Edge interface for connection edges
type Edge interface {
	IsEdge()
}

// Relay Node interface for global object identification
type Node interface {
	IsNode()
}

// Universal State v2 Resource Interface.
// Every managed resource implements this interface with 8 layers:
// 1. configuration - User's desired config (mutable by user)
// 2. validation - Pre-flight check results (computed by backend)
// 3. deployment - What's on router (after Apply-Confirm)
// 4. runtime - Live operational state (polled/streamed)
// 5. telemetry - Time-series metrics (historical)
// 6. metadata - Lifecycle info, tags, ownership
// 7. relationships - Dependencies (embedded + explicit)
// 8. platform - Capabilities and field mappings
type Resource interface {
	IsResource()
}

type AddBridgePortInput struct {
	InterfaceID      string                         `json:"interfaceId"`
	Pvid             graphql.Omittable[*int]        `json:"pvid,omitempty"`
	FrameTypes       graphql.Omittable[*FrameTypes] `json:"frameTypes,omitempty"`
	IngressFiltering graphql.Omittable[*bool]       `json:"ingressFiltering,omitempty"`
}

type AddChangeSetItemPayload struct {
	// The updated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// The added item ID
	ItemID *string `json:"itemId,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for manually adding a new router with full credentials and protocol preference.
// This is the primary input type for the addRouter mutation.
type AddRouterInput struct {
	// Router hostname or IP address.
	// Can be an IPv4 address (e.g., '192.168.88.1'), IPv6 address, or hostname (e.g., 'router.local').
	// Hostnames will trigger DNS resolution with caching.
	Host string `json:"host"`
	// Connection port. If not specified, defaults to protocol-specific port:
	// - REST: 443 (or 80 for HTTP)
	// - API: 8728
	// - API_SSL: 8729
	// - SSH: 22
	// - Telnet: 23
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Username for authentication.
	// For MikroTik routers, this is typically 'admin' or a custom user.
	Username string `json:"username"`
	// Password for authentication.
	// This value is encrypted before storage and never logged.
	Password string `json:"password"`
	// Protocol preference for connection.
	// Defaults to AUTO which tries protocols in recommended order.
	ProtocolPreference graphql.Omittable[*ProtocolPreference] `json:"protocolPreference,omitempty"`
	// User-friendly display name for the router.
	// If not provided, a name will be generated from the host.
	Name graphql.Omittable[*string] `json:"name,omitempty"`
}

// Payload returned from the addRouter mutation.
// Contains either the created router or validation/connection errors.
type AddRouterPayload struct {
	// The newly created router (null if errors occurred)
	Router *Router `json:"router,omitempty"`
	// Connection test result from initial connection attempt
	ConnectionResult *ConnectionTestResult `json:"connectionResult,omitempty"`
	// Field-level validation errors for retry
	ValidationErrors []*ValidationError `json:"validationErrors,omitempty"`
	// General errors that occurred during creation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Aggregated view of an address list with entry statistics.
// Address lists group IP addresses for use in firewall rules.
type AddressList struct {
	// List name (unique identifier)
	Name string `json:"name"`
	// Total number of entries in this list
	EntryCount int `json:"entryCount"`
	// Number of dynamic entries (added by firewall actions)
	DynamicCount int `json:"dynamicCount"`
	// Number of firewall rules referencing this list
	ReferencingRulesCount int `json:"referencingRulesCount"`
	// Paginated entries in this list
	Entries *AddressListEntryConnection `json:"entries"`
	// Firewall rules that reference this list
	ReferencingRules []*FirewallRule `json:"referencingRules"`
}

// Single entry in an address list.
// Represents an IP address, CIDR subnet, or IP range that belongs to a named list.
type AddressListEntry struct {
	// MikroTik internal ID
	ID string `json:"id"`
	// Name of the address list this entry belongs to
	List string `json:"list"`
	// IP address, CIDR subnet, or IP range
	Address string `json:"address"`
	// Optional description
	Comment *string `json:"comment,omitempty"`
	// Optional timeout after which entry is removed
	Timeout *string `json:"timeout,omitempty"`
	// When this entry was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Whether this entry was added dynamically by a firewall action
	Dynamic bool `json:"dynamic"`
	// Whether this entry is disabled
	Disabled bool `json:"disabled"`
}

func (AddressListEntry) IsNode() {}

// Connection type for paginated address list entries.
// Follows Relay pagination specification.
type AddressListEntryConnection struct {
	Edges      []*AddressListEntryEdge `json:"edges"`
	PageInfo   *PageInfo               `json:"pageInfo"`
	TotalCount *int                    `json:"totalCount,omitempty"`
}

func (AddressListEntryConnection) IsConnection() {}

// Edge type for address list entry connections.
type AddressListEntryEdge struct {
	Cursor string            `json:"cursor"`
	Node   *AddressListEntry `json:"node"`
}

func (AddressListEntryEdge) IsEdge() {}

// Resource affected by a configuration change
type AffectedResource struct {
	// Resource type (ip-address, dhcp-server, firewall-rule, etc.)
	Type string `json:"type"`
	// Resource ID
	ID string `json:"id"`
	// Resource name or description
	Name string `json:"name"`
	// How the resource will be affected (modified, disabled, removed)
	Impact ResourceImpact `json:"impact"`
}

// Individual alert instance triggered when rule conditions are met
type Alert struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Alert rule that triggered this alert
	Rule *AlertRule `json:"rule"`
	// Event type that triggered this alert
	EventType string `json:"eventType"`
	// Alert severity level
	Severity AlertSeverity `json:"severity"`
	// Alert title/summary
	Title string `json:"title"`
	// Detailed alert message
	Message string `json:"message"`
	// Event data and context information
	Data map[string]interface{} `json:"data,omitempty"`
	// Device ID that triggered this alert
	DeviceID *string `json:"deviceId,omitempty"`
	// When alert was triggered
	TriggeredAt time.Time `json:"triggeredAt"`
	// When alert was acknowledged
	AcknowledgedAt *time.Time `json:"acknowledgedAt,omitempty"`
	// User who acknowledged the alert
	AcknowledgedBy *string `json:"acknowledgedBy,omitempty"`
	// Delivery status per channel
	DeliveryStatus map[string]interface{} `json:"deliveryStatus,omitempty"`
	// Escalation tracking for this alert (NAS-18.9)
	Escalation *AlertEscalation `json:"escalation,omitempty"`
	// Number of alerts suppressed by throttling (if this alert is part of a throttle group)
	SuppressedCount *int `json:"suppressedCount,omitempty"`
	// Reason for suppression (e.g., "throttled", "storm_detected")
	SuppressReason *string `json:"suppressReason,omitempty"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (Alert) IsNode() {}

// Template variable input
type AlertAlertTemplateVariableInput struct {
	// Variable name
	Name string `json:"name"`
	// Display label
	Label string `json:"label"`
	// Variable type
	Type AlertTemplateVariableType `json:"type"`
	// Whether required
	Required bool `json:"required"`
	// Default value
	DefaultValue graphql.Omittable[*string] `json:"defaultValue,omitempty"`
	// Description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Options for enum types
	Options graphql.Omittable[[]string] `json:"options,omitempty"`
}

// Condition for event matching in alert rules
type AlertCondition struct {
	// Field name to evaluate
	Field string `json:"field"`
	// Comparison operator
	Operator ConditionOperator `json:"operator"`
	// Value to compare against
	Value string `json:"value"`
}

// Alert condition input
type AlertConditionInput struct {
	// Field name to evaluate
	Field string `json:"field"`
	// Comparison operator
	Operator ConditionOperator `json:"operator"`
	// Value to compare against
	Value string `json:"value"`
}

// Paginated alert connection
type AlertConnection struct {
	// Alert edges
	Edges []*AlertEdge `json:"edges"`
	// Pagination information
	PageInfo *PageInfo `json:"pageInfo"`
	// Total count of alerts
	TotalCount int `json:"totalCount"`
}

func (AlertConnection) IsConnection() {}

// Alert edge for pagination
type AlertEdge struct {
	// Alert node
	Node *Alert `json:"node"`
	// Pagination cursor
	Cursor string `json:"cursor"`
}

func (AlertEdge) IsEdge() {}

// Alert escalation tracking record (NAS-18.9)
type AlertEscalation struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Alert being tracked for escalation
	AlertID string `json:"alertId"`
	// Alert rule with escalation configuration
	RuleID string `json:"ruleId"`
	// Current escalation level (0 = initial)
	CurrentLevel int `json:"currentLevel"`
	// Maximum escalation level
	MaxLevel int `json:"maxLevel"`
	// Escalation status
	Status EscalationStatus `json:"status"`
	// When next escalation level should trigger
	NextEscalationAt *time.Time `json:"nextEscalationAt,omitempty"`
	// When escalation was resolved
	ResolvedAt *time.Time `json:"resolvedAt,omitempty"`
	// Reason for resolution
	ResolvedBy *string `json:"resolvedBy,omitempty"`
	// Record creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (AlertEscalation) IsNode() {}

// Alert event for real-time subscriptions
type AlertEvent struct {
	// The alert that changed
	Alert *Alert `json:"alert"`
	// Type of action that occurred
	Action AlertAction `json:"action"`
}

// Alert mutation payload
type AlertPayload struct {
	// Modified alert
	Alert *Alert `json:"alert,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Alert rule defines conditions that trigger notifications when met
type AlertRule struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Human-readable alert rule name
	Name string `json:"name"`
	// Optional description of what this rule monitors
	Description *string `json:"description,omitempty"`
	// Event type to match (e.g., 'router.offline', 'interface.down', 'cpu.high')
	EventType string `json:"eventType"`
	// Array of conditions for event matching
	Conditions []*AlertCondition `json:"conditions"`
	// Alert severity level
	Severity AlertSeverity `json:"severity"`
	// Notification channels to use
	Channels []string `json:"channels"`
	// Throttle configuration to prevent alert spam
	Throttle *ThrottleConfig `json:"throttle,omitempty"`
	// Quiet hours configuration for non-critical alerts
	QuietHours *QuietHoursConfig `json:"quietHours,omitempty"`
	// Escalation configuration for unacknowledged alerts (NAS-18.9)
	Escalation *EscalationConfig `json:"escalation,omitempty"`
	// Optional device ID filter - rule only applies to this device
	DeviceID *string `json:"deviceId,omitempty"`
	// Whether this alert rule is enabled
	Enabled bool `json:"enabled"`
	// Record creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// Alerts triggered by this rule
	Alerts []*Alert `json:"alerts"`
}

func (AlertRule) IsNode() {}

// Variable input for alert rule templates
type AlertRuleAlertTemplateVariableInput struct {
	// Variable name
	Name string `json:"name"`
	// Display label
	Label string `json:"label"`
	// Variable type
	Type AlertRuleTemplateVariableType `json:"type"`
	// Whether required
	Required bool `json:"required"`
	// Default value
	DefaultValue graphql.Omittable[*string] `json:"defaultValue,omitempty"`
	// Minimum value
	Min graphql.Omittable[*int] `json:"min,omitempty"`
	// Maximum value
	Max graphql.Omittable[*int] `json:"max,omitempty"`
	// Unit label
	Unit graphql.Omittable[*string] `json:"unit,omitempty"`
	// Description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

// Alert rule mutation payload
type AlertRulePayload struct {
	// Created/updated alert rule
	AlertRule *AlertRule `json:"alertRule,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Alert rule template for quick rule creation
// Pre-configured templates with variables for common alert scenarios
type AlertRuleTemplate struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Template name
	Name string `json:"name"`
	// Template description
	Description string `json:"description"`
	// Template category
	Category AlertRuleTemplateCategory `json:"category"`
	// Alert severity level
	Severity AlertSeverity `json:"severity"`
	// Event type this template monitors
	EventType string `json:"eventType"`
	// Pre-configured conditions
	Conditions []*AlertCondition `json:"conditions"`
	// Throttle configuration
	Throttle *ThrottleConfig `json:"throttle,omitempty"`
	// Default notification channels
	Channels []string `json:"channels"`
	// Template variables for customization
	Variables []*AlertRuleTemplateVariable `json:"variables"`
	// Whether this is a built-in template
	IsBuiltIn bool `json:"isBuiltIn"`
	// Template version
	Version string `json:"version"`
	// Record creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (AlertRuleTemplate) IsNode() {}

// Alert rule template mutation payload
type AlertRuleTemplatePayload struct {
	// Created/updated template
	Template *AlertRuleTemplate `json:"template,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Preview result for alert rule template
type AlertRuleTemplatePreview struct {
	// The template being previewed
	Template *AlertRuleTemplate `json:"template"`
	// Resolved conditions with variable substitution
	ResolvedConditions []*AlertCondition `json:"resolvedConditions"`
	// Validation information
	ValidationInfo *TemplateValidationInfo `json:"validationInfo"`
}

// Variable definition for alert rule templates
type AlertRuleTemplateVariable struct {
	// Variable name (used for substitution)
	Name string `json:"name"`
	// Display label
	Label string `json:"label"`
	// Variable type
	Type AlertRuleTemplateVariableType `json:"type"`
	// Whether this variable is required
	Required bool `json:"required"`
	// Default value
	DefaultValue *string `json:"defaultValue,omitempty"`
	// Minimum value (for INTEGER, DURATION, PERCENTAGE)
	Min *int `json:"min,omitempty"`
	// Maximum value (for INTEGER, DURATION, PERCENTAGE)
	Max *int `json:"max,omitempty"`
	// Unit label (e.g., "seconds", "percent", "MB")
	Unit *string `json:"unit,omitempty"`
	// Variable description
	Description *string `json:"description,omitempty"`
}

// Alert notification template
// Templates define message format for different event types and channels
type AlertTemplate struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Template name
	Name string `json:"name"`
	// Template description
	Description string `json:"description"`
	// Event type this template applies to
	EventType string `json:"eventType"`
	// Notification channel
	Channel NotificationChannel `json:"channel"`
	// Subject/title template
	SubjectTemplate *string `json:"subjectTemplate,omitempty"`
	// Body template with Go template syntax
	BodyTemplate string `json:"bodyTemplate"`
	// Template variables
	Variables []*AlertTemplateVariable `json:"variables"`
	// Whether this is a built-in template
	IsBuiltIn bool `json:"isBuiltIn"`
	// Whether this is a system default template
	IsDefault bool `json:"isDefault"`
	// Tags for categorization
	Tags []string `json:"tags"`
	// Channel-specific metadata
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	// Record creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (AlertTemplate) IsNode() {}

// Alert template mutation payload
type AlertTemplatePayload struct {
	// Created/updated template
	Template *AlertTemplate `json:"template,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Template variable definition
type AlertTemplateVariable struct {
	// Variable name (used in template as {{.Name}})
	Name string `json:"name"`
	// Display label
	Label string `json:"label"`
	// Variable type
	Type AlertTemplateVariableType `json:"type"`
	// Whether this variable is required
	Required bool `json:"required"`
	// Default value
	DefaultValue *string `json:"defaultValue,omitempty"`
	// Variable description
	Description *string `json:"description,omitempty"`
	// Options for enum-type variables
	Options []string `json:"options,omitempty"`
}

// Input for applying an alert template
type ApplyAlertTemplateInput struct {
	// Template ID to apply
	TemplateID string `json:"templateId"`
	// Variables for template substitution
	Variables map[string]interface{} `json:"variables"`
	// Alert rule configuration
	RuleConfig *CreateAlertRuleInput `json:"ruleConfig"`
}

type ApplyChangeSetPayload struct {
	// Change set ID
	ChangeSetID string `json:"changeSetId"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of applying a fix
type ApplyFixPayload struct {
	// Whether fix was applied successfully
	Success bool `json:"success"`
	// User-friendly message
	Message string `json:"message"`
	// Fix application status
	Status FixApplicationStatus `json:"status"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

type ApplyResourcePayload struct {
	// The applied resource
	Resource Resource `json:"resource,omitempty"`
	// Operation ID for progress tracking
	OperationID string `json:"operationId"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

type ArchiveResourcePayload struct {
	// Whether archive was successful
	Success bool `json:"success"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Authentication test status
type AuthStatus struct {
	// Whether authentication was tested
	Tested bool `json:"tested"`
	// Whether authentication succeeded
	Success bool `json:"success"`
	// Error message (if authentication failed)
	Error *string `json:"error,omitempty"`
	// Error code mapped to ErrorCodes (A5xx)
	ErrorCode *string `json:"errorCode,omitempty"`
}

// A bandwidth data point
type BandwidthDataPoint struct {
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
	// Bytes in during this period
	BytesIn Size `json:"bytesIn"`
	// Bytes out during this period
	BytesOut Size `json:"bytesOut"`
	// Period duration in seconds
	PeriodSeconds int `json:"periodSeconds"`
}

// Input for batch interface operations
type BatchInterfaceInput struct {
	// Interface IDs to operate on
	InterfaceIds []string `json:"interfaceIds"`
	// Action to perform
	Action BatchInterfaceAction `json:"action"`
	// Optional input for UPDATE action
	Input graphql.Omittable[*UpdateInterfaceInput] `json:"input,omitempty"`
}

// Payload returned by batchInterfaceOperation mutation
type BatchInterfacePayload struct {
	// Interfaces that were successfully updated
	Succeeded []*Interface `json:"succeeded"`
	// Interfaces that failed with reasons
	Failed []*InterfaceOperationError `json:"failed"`
	// General errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

type Bridge struct {
	ID                   string           `json:"id"`
	Name                 string           `json:"name"`
	Comment              *string          `json:"comment,omitempty"`
	Disabled             bool             `json:"disabled"`
	Running              bool             `json:"running"`
	MacAddress           *MAC             `json:"macAddress,omitempty"`
	Mtu                  *int             `json:"mtu,omitempty"`
	Protocol             StpProtocol      `json:"protocol"`
	Priority             *int             `json:"priority,omitempty"`
	VlanFiltering        bool             `json:"vlanFiltering"`
	Pvid                 *int             `json:"pvid,omitempty"`
	Ports                []*BridgePort    `json:"ports"`
	Vlans                []*BridgeVlan    `json:"vlans"`
	IPAddresses          []*IPAddress     `json:"ipAddresses"`
	StpStatus            *BridgeStpStatus `json:"stpStatus,omitempty"`
	DependentDhcpServers []*DhcpServer    `json:"dependentDhcpServers"`
	DependentRoutes      []*Route         `json:"dependentRoutes"`
}

func (Bridge) IsNode() {}

type BridgeMutationResult struct {
	Success bool             `json:"success"`
	Bridge  *Bridge          `json:"bridge,omitempty"`
	Errors  []*MutationError `json:"errors,omitempty"`
	// Previous state for undo functionality
	PreviousState map[string]interface{} `json:"previousState,omitempty"`
	// Unique operation ID for undo within 10-second window
	OperationID *string `json:"operationId,omitempty"`
}

type BridgePort struct {
	ID               string       `json:"id"`
	Bridge           *Bridge      `json:"bridge"`
	Interface        *Interface   `json:"interface"`
	Pvid             int          `json:"pvid"`
	FrameTypes       FrameTypes   `json:"frameTypes"`
	IngressFiltering bool         `json:"ingressFiltering"`
	TaggedVlans      []int        `json:"taggedVlans"`
	UntaggedVlans    []int        `json:"untaggedVlans"`
	Role             StpPortRole  `json:"role"`
	State            StpPortState `json:"state"`
	PathCost         int          `json:"pathCost"`
	Edge             bool         `json:"edge"`
}

func (BridgePort) IsNode() {}

type BridgePortMutationResult struct {
	Success       bool                   `json:"success"`
	Port          *BridgePort            `json:"port,omitempty"`
	Errors        []*MutationError       `json:"errors,omitempty"`
	PreviousState map[string]interface{} `json:"previousState,omitempty"`
	OperationID   *string                `json:"operationId,omitempty"`
}

// VLAN configuration for a bridge port (trunk/access port setup)
type BridgePortVlanConfig struct {
	// Bridge port ID
	PortID string `json:"portId"`
	// Port VLAN ID (PVID) for untagged traffic
	Pvid int `json:"pvid"`
	// Frame types allowed on this port
	FrameTypes BridgePortFrameTypes `json:"frameTypes"`
	// Tagged VLANs allowed on this port (trunk mode)
	TaggedVlans []int `json:"taggedVlans"`
	// Untagged VLANs on this port (typically just PVID)
	UntaggedVlans []int `json:"untaggedVlans"`
	// Port mode (trunk or access)
	Mode PortMode `json:"mode"`
}

// Input for configuring bridge port VLAN settings
type BridgePortVlanInput struct {
	// Port VLAN ID (PVID) for untagged traffic
	Pvid int `json:"pvid"`
	// Frame types allowed on this port
	FrameTypes BridgePortFrameTypes `json:"frameTypes"`
	// Tagged VLANs (for trunk ports)
	TaggedVlans graphql.Omittable[[]int] `json:"taggedVlans,omitempty"`
	// Port mode (trunk or access)
	Mode PortMode `json:"mode"`
}

// Bridge resource (part of LANNetwork)
type BridgeResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Bridge name
	Name string `json:"name"`
	// Ports in this bridge
	Ports []string `json:"ports"`
	// Protocol mode (rstp, stp, none)
	ProtocolMode *string `json:"protocolMode,omitempty"`
}

func (BridgeResource) IsResource() {}

func (BridgeResource) IsNode() {}

type BridgeStpStatus struct {
	RootBridge          bool       `json:"rootBridge"`
	RootBridgeID        *string    `json:"rootBridgeId,omitempty"`
	RootPort            *string    `json:"rootPort,omitempty"`
	RootPathCost        int        `json:"rootPathCost"`
	TopologyChangeCount int        `json:"topologyChangeCount"`
	LastTopologyChange  *time.Time `json:"lastTopologyChange,omitempty"`
}

type BridgeVlan struct {
	UUID          string        `json:"uuid"`
	Bridge        *Bridge       `json:"bridge"`
	VlanID        int           `json:"vlanId"`
	TaggedPorts   []*BridgePort `json:"taggedPorts"`
	UntaggedPorts []*BridgePort `json:"untaggedPorts"`
}

type BridgeVlanMutationResult struct {
	Success bool             `json:"success"`
	Vlan    *BridgeVlan      `json:"vlan,omitempty"`
	Errors  []*MutationError `json:"errors,omitempty"`
}

// Input for bulk address import.
// Used with bulkCreateAddressListEntries mutation.
type BulkAddressInput struct {
	// IP address, CIDR notation, or IP range
	Address string `json:"address"`
	// Optional description
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
	// Optional timeout
	Timeout graphql.Omittable[*string] `json:"timeout,omitempty"`
}

// Bulk alert mutation payload
type BulkAlertPayload struct {
	// Number of alerts acknowledged
	AcknowledgedCount int `json:"acknowledgedCount"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Details of a single failed entry in bulk import.
type BulkCreateError struct {
	// Index in the input array
	Index int `json:"index"`
	// The address that failed
	Address string `json:"address"`
	// Error message
	Message string `json:"message"`
}

// Result of bulk address list entry creation.
// Includes success count, failure count, and error details.
type BulkCreateResult struct {
	// Number of entries successfully created
	SuccessCount int `json:"successCount"`
	// Number of entries that failed
	FailedCount int `json:"failedCount"`
	// Details of failed entries
	Errors []*BulkCreateError `json:"errors"`
}

// CPU utilization metrics
type CPUMetrics struct {
	// Overall CPU usage percentage (0-100)
	Usage float64 `json:"usage"`
	// Number of CPU cores
	Cores int `json:"cores"`
	// Per-core usage percentages (one per core)
	PerCore []float64 `json:"perCore"`
	// CPU frequency in MHz (optional)
	Frequency *float64 `json:"frequency,omitempty"`
}

type CancelChangeSetPayload struct {
	// The cancelled change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Whether cancel was successful
	Success bool `json:"success"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

type CancelScanPayload struct {
	// The cancelled scan task
	Task *ScanTask `json:"task,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Single capability with its support level and guidance
type CapabilityEntry struct {
	// Capability category
	Capability Capability `json:"capability"`
	// Support level
	Level CapabilityLevel `json:"level"`
	// Human-readable description of support
	Description *string `json:"description,omitempty"`
	// Actionable message if feature unavailable
	Guidance *string `json:"guidance,omitempty"`
}

// An entry in the change log
type ChangeLogEntry struct {
	// Change timestamp
	Timestamp time.Time `json:"timestamp"`
	// User who made the change
	User string `json:"user"`
	// Type of change
	ChangeType ChangeType `json:"changeType"`
	// Changed fields
	ChangedFields []string `json:"changedFields"`
	// Brief description of the change
	Summary *string `json:"summary,omitempty"`
}

// A change set representing an atomic multi-resource operation
type ChangeSet struct {
	// Unique identifier (ULID)
	ID string `json:"id"`
	// Human-readable name
	Name string `json:"name"`
	// Optional description
	Description *string `json:"description,omitempty"`
	// Router ID this change set applies to
	RouterID string `json:"routerId"`
	// Items in this change set
	Items []*ChangeSetItem `json:"items"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Validation result
	Validation *ChangeSetValidationResult `json:"validation,omitempty"`
	// Rollback plan
	RollbackPlan []*RollbackStep `json:"rollbackPlan"`
	// Error information (if failed)
	Error *ChangeSetError `json:"error,omitempty"`
	// Created timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Apply started timestamp
	ApplyStartedAt *time.Time `json:"applyStartedAt,omitempty"`
	// Completed timestamp
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	// User who created the change set
	CreatedBy *string `json:"createdBy,omitempty"`
	// Source wizard/feature
	Source *string `json:"source,omitempty"`
	// Version for optimistic concurrency
	Version int `json:"version"`
}

// Conflict between change set items
type ChangeSetConflict struct {
	// First conflicting item ID
	ItemID1 string `json:"itemId1"`
	// Second conflicting item ID or resource UUID
	ItemID2OrResourceUUID string `json:"itemId2OrResourceUuid"`
	// Whether conflict is with existing resource
	IsExternalConflict bool `json:"isExternalConflict"`
	// Description of the conflict
	Description string `json:"description"`
	// Suggested resolution
	Resolution *string `json:"resolution,omitempty"`
}

// Detailed error for failed change sets
type ChangeSetError struct {
	// Error message
	Message string `json:"message"`
	// Item ID that caused the failure
	FailedItemID string `json:"failedItemId"`
	// Error code
	Code *string `json:"code,omitempty"`
	// Items applied before failure
	PartiallyAppliedItemIds []string `json:"partiallyAppliedItemIds"`
	// Items that failed rollback
	FailedRollbackItemIds []string `json:"failedRollbackItemIds"`
	// Whether manual intervention is required
	RequiresManualIntervention bool `json:"requiresManualIntervention"`
}

// Individual item within a change set
type ChangeSetItem struct {
	// Unique identifier for this item
	ID string `json:"id"`
	// Resource type identifier
	ResourceType string `json:"resourceType"`
	// Resource category
	ResourceCategory ResourceCategory `json:"resourceCategory"`
	// Existing resource UUID (null for create operations)
	ResourceUUID *string `json:"resourceUuid,omitempty"`
	// User-friendly name
	Name string `json:"name"`
	// Optional description
	Description *string `json:"description,omitempty"`
	// Operation to perform
	Operation ChangeOperation `json:"operation"`
	// New/updated configuration
	Configuration map[string]interface{} `json:"configuration"`
	// Previous state (for rollback)
	PreviousState map[string]interface{} `json:"previousState,omitempty"`
	// Item IDs this depends on
	Dependencies []string `json:"dependencies"`
	// Current status
	Status ChangeSetItemStatus `json:"status"`
	// Error message if failed
	Error *string `json:"error,omitempty"`
	// Apply started timestamp
	ApplyStartedAt *time.Time `json:"applyStartedAt,omitempty"`
	// Apply completed timestamp
	ApplyCompletedAt *time.Time `json:"applyCompletedAt,omitempty"`
	// Order in which this item will be applied
	ApplyOrder int `json:"applyOrder"`
}

// Input for adding an item to a change set
type ChangeSetItemInput struct {
	// Resource type identifier
	ResourceType string `json:"resourceType"`
	// Resource category
	ResourceCategory ResourceCategory `json:"resourceCategory"`
	// Existing resource UUID (for update/delete)
	ResourceUUID graphql.Omittable[*string] `json:"resourceUuid,omitempty"`
	// User-friendly name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Operation to perform
	Operation ChangeOperation `json:"operation"`
	// Configuration
	Configuration map[string]interface{} `json:"configuration"`
	// Previous state (for rollback on update/delete)
	PreviousState graphql.Omittable[map[string]interface{}] `json:"previousState,omitempty"`
	// Item IDs this depends on
	Dependencies graphql.Omittable[[]string] `json:"dependencies,omitempty"`
}

// Progress event for real-time updates during apply
type ChangeSetProgressEvent struct {
	// Change set ID
	ChangeSetID string `json:"changeSetId"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Currently processing item
	CurrentItem *CurrentItemInfo `json:"currentItem,omitempty"`
	// Number of items applied
	AppliedCount int `json:"appliedCount"`
	// Total number of items
	TotalCount int `json:"totalCount"`
	// Progress percentage (0-100)
	ProgressPercent float64 `json:"progressPercent"`
	// Estimated time remaining in milliseconds
	EstimatedRemainingMs *int `json:"estimatedRemainingMs,omitempty"`
	// Error if failed
	Error *ChangeSetError `json:"error,omitempty"`
	// Timestamp of this event
	Timestamp time.Time `json:"timestamp"`
}

// Change set status change event
type ChangeSetStatusEvent struct {
	// Change set ID
	ChangeSetID string `json:"changeSetId"`
	// Previous status
	PreviousStatus ChangeSetStatus `json:"previousStatus"`
	// New status
	NewStatus ChangeSetStatus `json:"newStatus"`
	// Error if failed
	Error *ChangeSetError `json:"error,omitempty"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// Summary of a change set for list displays
type ChangeSetSummary struct {
	// Change set ID
	ID string `json:"id"`
	// Name
	Name string `json:"name"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Operation counts
	OperationCounts *OperationCounts `json:"operationCounts"`
	// Total items
	TotalItems int `json:"totalItems"`
	// Created timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Has validation errors
	HasErrors bool `json:"hasErrors"`
	// Has validation warnings
	HasWarnings bool `json:"hasWarnings"`
}

// Validation error for a change set item
type ChangeSetValidationError struct {
	// Item ID with validation error
	ItemID string `json:"itemId"`
	// Field path within the item configuration
	Field string `json:"field"`
	// Error message
	Message string `json:"message"`
	// Severity level
	Severity ValidationSeverity `json:"severity"`
	// Error code
	Code *string `json:"code,omitempty"`
}

// Validation result for a change set
type ChangeSetValidationResult struct {
	// Whether the change set can be applied
	CanApply bool `json:"canApply"`
	// Validation errors (blocking)
	Errors []*ChangeSetValidationError `json:"errors"`
	// Validation warnings (non-blocking)
	Warnings []*ChangeSetValidationError `json:"warnings"`
	// Detected conflicts
	Conflicts []*ChangeSetConflict `json:"conflicts"`
	// Missing dependencies
	MissingDependencies []*MissingDependency `json:"missingDependencies"`
	// Circular dependencies (if any)
	CircularDependencies [][]string `json:"circularDependencies,omitempty"`
}

// Payload for channel configuration mutations
type ChannelConfigPayload struct {
	// The created/updated configuration
	Config *NotificationChannelConfig `json:"config,omitempty"`
	// Validation or mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Event emitted when circuit breaker state changes
type CircuitBreakerEvent struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Previous state
	PreviousState CircuitBreakerState `json:"previousState"`
	// New state
	NewState CircuitBreakerState `json:"newState"`
	// Consecutive failures that triggered the change
	ConsecutiveFailures int `json:"consecutiveFailures"`
	// When the state changed
	Timestamp time.Time `json:"timestamp"`
}

// Circuit breaker status for a router
type CircuitBreakerStatus struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Current circuit breaker state
	State CircuitBreakerState `json:"state"`
	// Number of consecutive failures
	FailureCount int `json:"failureCount"`
	// Failure threshold before circuit opens
	FailureThreshold int `json:"failureThreshold"`
	// Seconds until auto-retry (when circuit is open)
	CooldownRemainingSeconds *int `json:"cooldownRemainingSeconds,omitempty"`
	// When the last failure occurred
	LastFailureAt *time.Time `json:"lastFailureAt,omitempty"`
	// When the last success occurred
	LastSuccessAt *time.Time `json:"lastSuccessAt,omitempty"`
}

// A composite resource with all related sub-resources
type CompositeResource struct {
	// The root resource
	Root Resource `json:"root"`
	// All child/related resources
	Children []Resource `json:"children"`
	// Flattened relationship graph
	Relationships []*ResourceRelationshipEdge `json:"relationships"`
}

// Preview of RouterOS configuration commands
type ConfigPreview struct {
	// RouterOS commands to be executed
	Commands []string `json:"commands"`
	// Warnings about the configuration changes
	Warnings []string `json:"warnings,omitempty"`
	// Resources that will be affected
	AffectedResources []*AffectedResource `json:"affectedResources,omitempty"`
}

// Progress information for configuration apply operations
type ConfigProgress struct {
	// Unique operation identifier
	OperationID string `json:"operationId"`
	// Current status of the operation
	Status ConfigApplyStatus `json:"status"`
	// Completion percentage (0-100)
	Percentage int `json:"percentage"`
	// Human-readable progress message
	Message string `json:"message"`
	// Current step number
	CurrentStep *int `json:"currentStep,omitempty"`
	// Total number of steps
	TotalSteps *int `json:"totalSteps,omitempty"`
	// Timestamp of this progress update
	Timestamp time.Time `json:"timestamp"`
}

type ConnectRouterPayload struct {
	// The router that was connected
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during connection
	Errors []*MutationError `json:"errors,omitempty"`
}

// Record of a single protocol connection attempt
type ConnectionAttempt struct {
	// Protocol that was attempted
	Protocol Protocol `json:"protocol"`
	// When the attempt started
	StartedAt time.Time `json:"startedAt"`
	// When the attempt ended
	EndedAt time.Time `json:"endedAt"`
	// Whether the attempt succeeded
	Success bool `json:"success"`
	// Error code if failed
	ErrorCode *string `json:"errorCode,omitempty"`
	// Error message if failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Error category for classification
	ErrorCategory *ErrorCategory `json:"errorCategory,omitempty"`
}

// Detailed connection status for a router
type ConnectionDetails struct {
	// Current connection state
	State ConnectionStatus `json:"state"`
	// Protocol currently in use
	Protocol *Protocol `json:"protocol,omitempty"`
	// User's preferred protocol (if set)
	PreferredProtocol *Protocol `json:"preferredProtocol,omitempty"`
	// When the connection was established
	ConnectedAt *time.Time `json:"connectedAt,omitempty"`
	// Connection uptime duration
	Uptime *Duration `json:"uptime,omitempty"`
	// When the last disconnection occurred
	DisconnectedAt *time.Time `json:"disconnectedAt,omitempty"`
	// Most recent error message
	LastError *string `json:"lastError,omitempty"`
	// When the last error occurred
	LastErrorTime *time.Time `json:"lastErrorTime,omitempty"`
	// Reason for disconnection
	DisconnectReason *DisconnectReason `json:"disconnectReason,omitempty"`
	// Number of reconnection attempts made
	ReconnectAttempts int `json:"reconnectAttempts"`
	// When the next reconnection attempt will be made
	NextReconnectAt *time.Time `json:"nextReconnectAt,omitempty"`
	// Current circuit breaker state
	CircuitBreakerState CircuitBreakerState `json:"circuitBreakerState"`
	// Router version (if connected)
	Version *string `json:"version,omitempty"`
	// When the last health check was performed
	LastHealthCheck *time.Time `json:"lastHealthCheck,omitempty"`
	// Consecutive passed health checks
	HealthChecksPassed int `json:"healthChecksPassed"`
	// Consecutive failed health checks
	HealthChecksFailed int `json:"healthChecksFailed"`
	// Security warning if using insecure protocol (e.g., Telnet)
	SecurityWarning *string `json:"securityWarning,omitempty"`
	// Recommendation for upgrading to a more secure protocol
	UpgradeRecommendation *string `json:"upgradeRecommendation,omitempty"`
	// Whether the current protocol is considered legacy/insecure
	IsLegacyProtocol bool `json:"isLegacyProtocol"`
}

// Detailed error information for connection failures.
// Used to provide actionable feedback to the user.
type ConnectionError struct {
	// Error code for programmatic handling
	Code ConnectionErrorCode `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Protocol that failed (if specific to a protocol)
	Protocol *Protocol `json:"protocol,omitempty"`
	// Whether the error is likely transient and retryable
	Retryable bool `json:"retryable"`
	// Suggested user action to resolve the error
	SuggestedAction *string `json:"suggestedAction,omitempty"`
	// Timeout in milliseconds (if timeout error)
	TimeoutMs *int `json:"timeoutMs,omitempty"`
}

// Connection manager statistics
type ConnectionStats struct {
	// Total number of connections
	TotalConnections int `json:"totalConnections"`
	// Number of connected routers
	Connected int `json:"connected"`
	// Number of connecting routers
	Connecting int `json:"connecting"`
	// Number of disconnected routers
	Disconnected int `json:"disconnected"`
	// Number of reconnecting routers
	Reconnecting int `json:"reconnecting"`
	// Number of routers in error state
	Error int `json:"error"`
}

// Result of a connection test attempt, including protocol detection results.
type ConnectionTestResult struct {
	// Whether the connection was successful
	Success bool `json:"success"`
	// Protocol that was successfully used
	ProtocolUsed *Protocol `json:"protocolUsed,omitempty"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// RouterOS version detected (if connection succeeded)
	RouterVersion *string `json:"routerVersion,omitempty"`
	// Router model detected (if connection succeeded)
	RouterModel *string `json:"routerModel,omitempty"`
	// Router board name (if connection succeeded)
	BoardName *string `json:"boardName,omitempty"`
	// Uptime of the router (if connection succeeded)
	Uptime *Duration `json:"uptime,omitempty"`
	// List of protocols that were attempted
	ProtocolsAttempted []Protocol `json:"protocolsAttempted"`
	// Whether the router supports containers
	SupportsContainers *bool `json:"supportsContainers,omitempty"`
	// Architecture of the router (arm, arm64, x86, etc.)
	Architecture *string `json:"architecture,omitempty"`
	// Error details if connection failed
	Error *ConnectionError `json:"error,omitempty"`
}

// Container-specific capability information
type ContainerInfo struct {
	// Whether container package is installed
	PackageInstalled bool `json:"packageInstalled"`
	// Whether container feature is enabled in system settings
	Enabled bool `json:"enabled"`
	// Whether a container registry is configured
	RegistryConfigured bool `json:"registryConfigured"`
	// Available storage for container images in bytes
	StorageAvailable Size `json:"storageAvailable"`
	// Whether network namespace is supported
	SupportsNetworkNamespace bool `json:"supportsNetworkNamespace"`
	// Maximum number of containers supported
	MaxContainers *int `json:"maxContainers,omitempty"`
}

// Input for creating a new address list entry.
// List will be created if it doesn't exist.
type CreateAddressListEntryInput struct {
	// Target list name (will create if doesn't exist)
	List string `json:"list"`
	// IP address, CIDR notation (e.g., 192.168.1.0/24), or IP range (e.g., 192.168.1.1-192.168.1.100)
	Address string `json:"address"`
	// Optional description
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
	// Optional timeout (e.g., "1d", "12h", "30m")
	Timeout graphql.Omittable[*string] `json:"timeout,omitempty"`
}

// Input for creating an alert rule
type CreateAlertRuleInput struct {
	// Human-readable alert rule name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Event type to match
	EventType string `json:"eventType"`
	// Array of conditions
	Conditions graphql.Omittable[[]*AlertConditionInput] `json:"conditions,omitempty"`
	// Alert severity level
	Severity AlertSeverity `json:"severity"`
	// Notification channels
	Channels []string `json:"channels"`
	// Throttle configuration
	Throttle graphql.Omittable[*ThrottleConfigInput] `json:"throttle,omitempty"`
	// Quiet hours configuration
	QuietHours graphql.Omittable[*QuietHoursConfigInput] `json:"quietHours,omitempty"`
	// Escalation configuration (NAS-18.9)
	Escalation graphql.Omittable[*EscalationConfigInput] `json:"escalation,omitempty"`
	// Optional device ID filter
	DeviceID graphql.Omittable[*string] `json:"deviceId,omitempty"`
	// Whether rule is enabled (default: true)
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

type CreateBridgeInput struct {
	Name          string                          `json:"name"`
	Comment       graphql.Omittable[*string]      `json:"comment,omitempty"`
	Protocol      graphql.Omittable[*StpProtocol] `json:"protocol,omitempty"`
	Priority      graphql.Omittable[*int]         `json:"priority,omitempty"`
	VlanFiltering graphql.Omittable[*bool]        `json:"vlanFiltering,omitempty"`
	Pvid          graphql.Omittable[*int]         `json:"pvid,omitempty"`
	Mtu           graphql.Omittable[*int]         `json:"mtu,omitempty"`
}

type CreateBridgeVlanInput struct {
	VlanID          int                         `json:"vlanId"`
	TaggedPortIds   graphql.Omittable[[]string] `json:"taggedPortIds,omitempty"`
	UntaggedPortIds graphql.Omittable[[]string] `json:"untaggedPortIds,omitempty"`
}

// Input for creating a new change set
type CreateChangeSetInput struct {
	// Router to apply changes to
	RouterID string `json:"routerId"`
	// Human-readable name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Source wizard/feature
	Source graphql.Omittable[*string] `json:"source,omitempty"`
}

type CreateChangeSetPayload struct {
	// The created change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for creating a NAT rule.
type CreateNatRuleInput struct {
	// NAT chain (srcnat or dstnat)
	Chain NatChain `json:"chain"`
	// NAT action
	Action NatAction `json:"action"`
	// Source address or CIDR
	SrcAddress graphql.Omittable[*string] `json:"srcAddress,omitempty"`
	// Destination address or CIDR
	DstAddress graphql.Omittable[*string] `json:"dstAddress,omitempty"`
	// Source port or port range
	SrcPort graphql.Omittable[*string] `json:"srcPort,omitempty"`
	// Destination port (1-65535)
	DstPort graphql.Omittable[*string] `json:"dstPort,omitempty"`
	// Protocol (TCP, UDP)
	Protocol graphql.Omittable[*TransportProtocol] `json:"protocol,omitempty"`
	// Target address for NAT
	ToAddresses graphql.Omittable[*string] `json:"toAddresses,omitempty"`
	// Target port(s) for NAT
	ToPorts graphql.Omittable[*string] `json:"toPorts,omitempty"`
	// Incoming interface
	InInterface graphql.Omittable[*string] `json:"inInterface,omitempty"`
	// Outgoing interface
	OutInterface graphql.Omittable[*string] `json:"outInterface,omitempty"`
	// Optional comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
	// Whether rule is disabled
	Disabled graphql.Omittable[*bool] `json:"disabled,omitempty"`
}

// Input for creating a new notification channel configuration
type CreateNotificationChannelConfigInput struct {
	// Type of notification channel
	ChannelType ChannelType `json:"channelType"`
	// Human-readable name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Whether this should be the default configuration
	IsDefault graphql.Omittable[*bool] `json:"isDefault,omitempty"`
	// Full configuration including sensitive fields
	// For Pushover: {"userKey": "...", "apiToken": "...", "device": "...", "baseURL": "..."}
	// For Email: {"host": "...", "port": 587, "from": "...", "username": "...", "password": "...", "tlsMode": "..."}
	Config map[string]interface{} `json:"config"`
}

// Input for creating a new port mirror configuration
type CreatePortMirrorInput struct {
	// Descriptive name for the mirror configuration
	Name string `json:"name"`
	// Source interface IDs to mirror (must be bridge members)
	SourceInterfaceIds []string `json:"sourceInterfaceIds"`
	// Destination interface ID for mirrored traffic
	DestinationInterfaceID string `json:"destinationInterfaceId"`
	// Direction of traffic to mirror (default: BOTH)
	Direction graphql.Omittable[*MirrorDirection] `json:"direction,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Input for creating a new resource
type CreateResourceInput struct {
	// Router to create resource on
	RouterID string `json:"routerId"`
	// Resource type (e.g., 'vpn.wireguard.client')
	Type string `json:"type"`
	// Resource category
	Category ResourceCategory `json:"category"`
	// Initial configuration
	Configuration map[string]interface{} `json:"configuration"`
	// User-defined relationships
	Relationships graphql.Omittable[*ResourceRelationshipsInput] `json:"relationships,omitempty"`
	// Initial tags
	Tags graphql.Omittable[[]string] `json:"tags,omitempty"`
	// Resource description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

type CreateResourcePayload struct {
	// The created resource
	Resource Resource `json:"resource,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for creating a new router connection
type CreateRouterInput struct {
	// User-friendly display name
	Name string `json:"name"`
	// Router hostname or IP address
	Host string `json:"host"`
	// Connection port (default: 8728 for MikroTik API)
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Username for authentication
	Username string `json:"username"`
	// Password for authentication
	Password string `json:"password"`
	// Router platform type
	Platform graphql.Omittable[*RouterPlatform] `json:"platform,omitempty"`
}

type CreateRouterPayload struct {
	// The created router
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during creation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for creating a webhook
type CreateWebhookInput struct {
	// Human-readable webhook name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Webhook URL endpoint
	URL string `json:"url"`
	// HTTP method (default: POST)
	Method graphql.Omittable[*string] `json:"method,omitempty"`
	// Authentication type (default: NONE)
	AuthType graphql.Omittable[*WebhookAuthType] `json:"authType,omitempty"`
	// Username for Basic auth
	Username graphql.Omittable[*string] `json:"username,omitempty"`
	// Password for Basic auth
	Password graphql.Omittable[*string] `json:"password,omitempty"`
	// Bearer token for Bearer auth
	BearerToken graphql.Omittable[*string] `json:"bearerToken,omitempty"`
	// Custom HTTP headers (as JSON object)
	Headers graphql.Omittable[map[string]interface{}] `json:"headers,omitempty"`
	// Template type for webhook payload (default: GENERIC)
	Template graphql.Omittable[*WebhookTemplate] `json:"template,omitempty"`
	// Custom template body (required if template is CUSTOM)
	CustomTemplate graphql.Omittable[*string] `json:"customTemplate,omitempty"`
	// Signing secret for HMAC signature (optional)
	SigningSecret graphql.Omittable[*string] `json:"signingSecret,omitempty"`
	// Timeout in seconds (default: 10)
	TimeoutSeconds graphql.Omittable[*int] `json:"timeoutSeconds,omitempty"`
	// Whether to retry failed deliveries (default: true)
	RetryEnabled graphql.Omittable[*bool] `json:"retryEnabled,omitempty"`
	// Maximum retry attempts (default: 3)
	MaxRetries graphql.Omittable[*int] `json:"maxRetries,omitempty"`
	// Whether webhook is enabled (default: true)
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

// Result of testing a single router's credentials.
type CredentialTestResult struct {
	// Router ID that was tested
	RouterID string `json:"routerId"`
	// Router name for display
	RouterName string `json:"routerName"`
	// Whether the test was successful
	Success bool `json:"success"`
	// Connection status
	Status CredentialTestStatus `json:"status"`
	// Response time in milliseconds (if successful)
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if test failed
	Error *string `json:"error,omitempty"`
}

// Result of updating router credentials.
type CredentialUpdatePayload struct {
	// Whether the update was successful
	Success bool `json:"success"`
	// Human-readable message about the operation
	Message string `json:"message"`
	// Updated credential info (without password)
	Credentials *RouterCredentials `json:"credentials,omitempty"`
	// Error code if update failed
	ErrorCode *CredentialErrorCode `json:"errorCode,omitempty"`
	// Errors that occurred during update
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating router credentials.
// Both username and password must be provided.
type CredentialsInput struct {
	// Username for router authentication
	Username string `json:"username"`
	// Password for router authentication
	Password string `json:"password"`
}

// Current item information in progress event
type CurrentItemInfo struct {
	ID        string              `json:"id"`
	Name      string              `json:"name"`
	Operation ChangeOperation     `json:"operation"`
	Status    ChangeSetItemStatus `json:"status"`
}

// DHCP Server resource
type DHCPServerResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Server name
	Name string `json:"name"`
	// Interface serving DHCP
	Interface string `json:"interface"`
	// Address pool name
	AddressPool string `json:"addressPool"`
	// Lease time
	LeaseTime Duration `json:"leaseTime"`
	// Number of active leases
	ActiveLeases *int `json:"activeLeases,omitempty"`
}

func (DHCPServerResource) IsResource() {}

func (DHCPServerResource) IsNode() {}

// Daily statistics
type DailyStats struct {
	// Date (UTC)
	Date time.Time `json:"date"`
	// Total bytes in
	TotalBytesIn Size `json:"totalBytesIn"`
	// Total bytes out
	TotalBytesOut Size `json:"totalBytesOut"`
	// Uptime percentage (0-100)
	UptimePercent float64 `json:"uptimePercent"`
	// Error count
	ErrorCount int `json:"errorCount"`
	// Peak throughput in (bytes/sec)
	PeakThroughputIn Size `json:"peakThroughputIn"`
	// Peak throughput out (bytes/sec)
	PeakThroughputOut Size `json:"peakThroughputOut"`
}

type DeleteChangeSetPayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Delete operation payload
type DeletePayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// ID of deleted item
	DeletedID *string `json:"deletedId,omitempty"`
	// Errors encountered during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

type DeleteResourcePayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// ID of deleted resource
	DeletedID *string `json:"deletedId,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of a delete operation
type DeleteResult struct {
	// Whether the deletion succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// Errors that occurred during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

type DeleteRouterPayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// ID of the deleted router
	DeletedRouterID *string `json:"deletedRouterId,omitempty"`
	// Errors that occurred during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

// Status of a required dependency
type DependencyStatus struct {
	// Dependency resource UUID
	ResourceUUID string `json:"resourceUuid"`
	// Dependency resource type
	ResourceType string `json:"resourceType"`
	// Whether the dependency is active
	IsActive bool `json:"isActive"`
	// Current state of the dependency
	State ResourceLifecycleState `json:"state"`
	// Why this dependency is required
	Reason string `json:"reason"`
}

// Layer 3: What's actually on router after Apply-Confirm.
// Includes router-generated fields like IDs and computed values.
type DeploymentState struct {
	// Router-generated resource ID (e.g., '*1A' in MikroTik)
	RouterResourceID *string `json:"routerResourceId,omitempty"`
	// When the resource was applied
	AppliedAt time.Time `json:"appliedAt"`
	// User who applied the resource
	AppliedBy *string `json:"appliedBy,omitempty"`
	// Version number on router
	RouterVersion *int `json:"routerVersion,omitempty"`
	// Router-generated fields (public key, computed values, etc.)
	GeneratedFields map[string]interface{} `json:"generatedFields,omitempty"`
	// Whether deployment matches configuration (no drift)
	IsInSync bool `json:"isInSync"`
	// Detected drift from configuration
	Drift *DriftInfo `json:"drift,omitempty"`
	// Apply operation ID for audit trail
	ApplyOperationID *string `json:"applyOperationId,omitempty"`
}

type DeprecateResourcePayload struct {
	// The deprecated resource
	Resource Resource `json:"resource,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Device (router) for querying resource metrics
type Device struct {
	// Device identifier
	ID string `json:"id"`
	// Current resource utilization metrics
	ResourceMetrics *ResourceMetrics `json:"resourceMetrics"`
}

// DHCP client configuration for dynamic WAN IP
type DhcpClient struct {
	// Unique identifier
	ID string `json:"id"`
	// Interface name
	Interface string `json:"interface"`
	// Whether DHCP client is disabled
	Disabled bool `json:"disabled"`
	// Add default route from DHCP
	AddDefaultRoute bool `json:"addDefaultRoute"`
	// Use DNS servers from DHCP
	UsePeerDNS bool `json:"usePeerDNS"`
	// Use NTP servers from DHCP
	UsePeerNtp bool `json:"usePeerNTP"`
	// Current DHCP status
	Status string `json:"status"`
	// Assigned IP address
	Address *IPv4 `json:"address,omitempty"`
	// DHCP server address
	DhcpServer *IPv4 `json:"dhcpServer,omitempty"`
	// Gateway from DHCP
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Lease expiry time
	ExpiresAfter *Duration `json:"expiresAfter,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (DhcpClient) IsNode() {}

// Input for creating/updating DHCP client
type DhcpClientInput struct {
	// Interface to enable DHCP client on
	Interface string `json:"interface"`
	// Add default route (default: true)
	AddDefaultRoute graphql.Omittable[*bool] `json:"addDefaultRoute,omitempty"`
	// Use peer DNS (default: true)
	UsePeerDNS graphql.Omittable[*bool] `json:"usePeerDNS,omitempty"`
	// Use peer NTP (default: true)
	UsePeerNtp graphql.Omittable[*bool] `json:"usePeerNTP,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// DHCP server (minimal type for dependencies)
type DhcpServer struct {
	// DHCP server ID
	ID string `json:"id"`
	// DHCP server name
	Name string `json:"name"`
	// Interface the DHCP server is bound to
	Interface *Interface `json:"interface"`
	// Whether the DHCP server is disabled
	Disabled bool `json:"disabled"`
}

// Comprehensive diagnostic report for a router
type DiagnosticReport struct {
	// Router ID being diagnosed
	RouterID string `json:"routerId"`
	// When the diagnostic was run
	Timestamp time.Time `json:"timestamp"`
	// Whether the router is reachable on the network
	NetworkReachable bool `json:"networkReachable"`
	// Status of each checked port
	PortStatus []*PortStatus `json:"portStatus"`
	// TLS certificate status (if TLS ports were checked)
	TLSStatus *TLSStatus `json:"tlsStatus,omitempty"`
	// Authentication test status
	AuthStatus *AuthStatus `json:"authStatus"`
	// Actionable suggestions based on diagnostic results
	Suggestions []*DiagnosticSuggestion `json:"suggestions"`
	// Raw text report for clipboard/export
	RawReport string `json:"rawReport"`
}

// Actionable diagnostic suggestion
type DiagnosticSuggestion struct {
	// Severity level of the issue
	Severity SuggestionSeverity `json:"severity"`
	// Short title describing the issue
	Title string `json:"title"`
	// Detailed description of the issue
	Description string `json:"description"`
	// Recommended action to resolve the issue
	Action string `json:"action"`
	// Link to relevant documentation
	DocsURL *string `json:"docsUrl,omitempty"`
}

// Email digest configuration (NAS-18.11)
type DigestConfig struct {
	// Whether digest mode is enabled
	Enabled bool `json:"enabled"`
	// Digest interval in minutes (e.g., 60 for hourly, 1440 for daily)
	IntervalMinutes int `json:"intervalMinutes"`
	// Time of day for daily delivery in HH:MM format (optional, for daily digests)
	Time *string `json:"time,omitempty"`
	// Whether critical alerts bypass digest mode and send immediately
	BypassCritical bool `json:"bypassCritical"`
	// Whether to send digest even when no alerts occurred during the period
	SendEmptyDigest bool `json:"sendEmptyDigest"`
}

// Email digest configuration input (NAS-18.11)
type DigestConfigInput struct {
	// Whether digest mode is enabled
	Enabled bool `json:"enabled"`
	// Digest interval in minutes (e.g., 60 for hourly, 1440 for daily)
	IntervalMinutes int `json:"intervalMinutes"`
	// Time of day for daily delivery in HH:MM format (optional, for daily digests)
	Time graphql.Omittable[*string] `json:"time,omitempty"`
	// Whether critical alerts bypass digest mode and send immediately (default: true)
	BypassCritical graphql.Omittable[*bool] `json:"bypassCritical,omitempty"`
	// Whether to send digest even when no alerts occurred during the period (default: false)
	SendEmptyDigest graphql.Omittable[*bool] `json:"sendEmptyDigest,omitempty"`
}

// Digest summary (NAS-18.11)
type DigestSummary struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Channel ID this digest was sent to
	ChannelID string `json:"channelId"`
	// When the digest was delivered
	DeliveredAt time.Time `json:"deliveredAt"`
	// Number of alerts included in the digest
	AlertCount int `json:"alertCount"`
	// Time period covered by the digest (e.g., "Last hour", "Last 24 hours")
	Period string `json:"period"`
}

type DisconnectRouterPayload struct {
	// The router that was disconnected
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during disconnection
	Errors []*MutationError `json:"errors,omitempty"`
}

// A device discovered during a network scan.
// Only confirmed MikroTik devices are returned (confidence >= 40).
type DiscoveredDevice struct {
	// IP address of the discovered device
	IP string `json:"ip"`
	// Hostname (if reverse DNS resolves)
	Hostname *string `json:"hostname,omitempty"`
	// Open ports found on the device
	Ports []int `json:"ports"`
	// Device type classification
	DeviceType string `json:"deviceType"`
	// Device vendor (always 'MikroTik' for returned results)
	Vendor *string `json:"vendor,omitempty"`
	// RouterOS-specific information (version, board, architecture)
	RouterOSInfo *RouterOSInfo `json:"routerOSInfo,omitempty"`
	// Confidence score for RouterOS detection (40-100)
	Confidence int `json:"confidence"`
	// Detected services (mikrotik-api, mikrotik-winbox, mikrotik-rest, etc.)
	Services []string `json:"services"`
}

// Complete benchmark result comparing all configured DNS servers
type DNSBenchmarkResult struct {
	// Test hostname used for benchmarking
	TestHostname string `json:"testHostname"`
	// Results for each tested server, sorted by response time
	ServerResults []*DNSBenchmarkServerResult `json:"serverResults"`
	// Fastest server
	FastestServer *DNSBenchmarkServerResult `json:"fastestServer,omitempty"`
	// When the benchmark was executed
	Timestamp time.Time `json:"timestamp"`
	// Total benchmark execution time in milliseconds
	TotalTimeMs int `json:"totalTimeMs"`
}

// Benchmark result for a single DNS server
type DNSBenchmarkServerResult struct {
	// DNS server IP address
	Server string `json:"server"`
	// Response time in milliseconds (-1 if unreachable)
	ResponseTimeMs int `json:"responseTimeMs"`
	// Server status (Fastest, Good, Slow, Unreachable)
	Status DNSServerStatus `json:"status"`
	// Whether the server responded successfully
	Success bool `json:"success"`
	// Error message (if server failed)
	Error *string `json:"error,omitempty"`
}

// DNS cache statistics for monitoring cache usage
type DNSCacheStats struct {
	// Total number of entries in the DNS cache
	TotalEntries int `json:"totalEntries"`
	// Cache size used in bytes
	CacheUsedBytes Size `json:"cacheUsedBytes"`
	// Maximum cache size in bytes
	CacheMaxBytes Size `json:"cacheMaxBytes"`
	// Cache usage percentage (0-100)
	CacheUsagePercent float64 `json:"cacheUsagePercent"`
	// Cache hit rate percentage (0-100)
	HitRatePercent *float64 `json:"hitRatePercent,omitempty"`
	// Most queried domains (top 10)
	TopDomains []*DNSTopDomain `json:"topDomains"`
	// When the statistics were collected
	Timestamp time.Time `json:"timestamp"`
}

// Input for DNS lookup operation
type DNSLookupInput struct {
	// Device/router ID to run lookup from
	DeviceID string `json:"deviceId"`
	// Hostname or IP address to look up
	Hostname string `json:"hostname"`
	// DNS record type to query
	RecordType DNSRecordType `json:"recordType"`
	// DNS server to use (defaults to router's configured DNS)
	Server graphql.Omittable[*string] `json:"server,omitempty"`
	// Query timeout in seconds (default: 5)
	Timeout graphql.Omittable[*int] `json:"timeout,omitempty"`
}

// Result of a DNS lookup operation
type DNSLookupResult struct {
	// Hostname that was queried
	Hostname string `json:"hostname"`
	// Record type that was queried
	RecordType DNSRecordType `json:"recordType"`
	// Query status
	Status DNSLookupStatus `json:"status"`
	// Resolved records
	Records []*DNSRecord `json:"records"`
	// DNS server used
	Server string `json:"server"`
	// Query time in milliseconds
	QueryTime int `json:"queryTime"`
	// Whether response was authoritative
	Authoritative bool `json:"authoritative"`
	// Error message (if query failed)
	Error *string `json:"error,omitempty"`
	// When the query was executed
	Timestamp time.Time `json:"timestamp"`
}

// Single DNS record
type DNSRecord struct {
	// Record name (query hostname)
	Name string `json:"name"`
	// Record type
	Type DNSRecordType `json:"type"`
	// Time to live in seconds
	TTL int `json:"ttl"`
	// Record data (IP, hostname, text, etc.)
	Data string `json:"data"`
	// Priority (for MX/SRV records)
	Priority *int `json:"priority,omitempty"`
	// Weight (for SRV records)
	Weight *int `json:"weight,omitempty"`
	// Port (for SRV records)
	Port *int `json:"port,omitempty"`
}

// DNS server configuration
type DNSServer struct {
	// Server IP address
	Address string `json:"address"`
	// Whether this is the primary DNS server
	IsPrimary bool `json:"isPrimary"`
	// Whether this is the secondary DNS server
	IsSecondary bool `json:"isSecondary"`
}

// Collection of DNS servers
type DNSServers struct {
	// All configured DNS servers
	Servers []*DNSServer `json:"servers"`
	// Primary DNS server address
	Primary string `json:"primary"`
	// Secondary DNS server address (if configured)
	Secondary *string `json:"secondary,omitempty"`
}

// A frequently queried domain in the DNS cache
type DNSTopDomain struct {
	// Domain name
	Domain string `json:"domain"`
	// Number of queries for this domain
	QueryCount int `json:"queryCount"`
	// Last query time
	LastQueried *time.Time `json:"lastQueried,omitempty"`
}

// A field that has drifted from configuration
type DriftField struct {
	// Field path
	Path string `json:"path"`
	// Expected value (from configuration)
	Expected map[string]interface{} `json:"expected,omitempty"`
	// Actual value (from router)
	Actual map[string]interface{} `json:"actual,omitempty"`
}

// Information about configuration drift
type DriftInfo struct {
	// When drift was detected
	DetectedAt time.Time `json:"detectedAt"`
	// Fields that have drifted
	DriftedFields []*DriftField `json:"driftedFields"`
	// Suggested action to resolve drift
	SuggestedAction DriftAction `json:"suggestedAction"`
}

// Email notification configuration
type EmailConfig struct {
	// Whether email notifications are enabled
	Enabled bool `json:"enabled"`
	// SMTP server hostname
	Host *string `json:"host,omitempty"`
	// SMTP server port
	Port *int `json:"port,omitempty"`
	// SMTP username for authentication
	Username *string `json:"username,omitempty"`
	// Email sender address
	FromAddress *string `json:"fromAddress,omitempty"`
	// Email sender display name
	FromName *string `json:"fromName,omitempty"`
	// Array of recipient email addresses
	ToAddresses []string `json:"toAddresses"`
	// Whether to use TLS/SSL
	UseTLS *bool `json:"useTLS,omitempty"`
	// Skip TLS certificate verification (use with caution)
	SkipVerify *bool `json:"skipVerify,omitempty"`
}

// Email notification configuration input
type EmailConfigInput struct {
	// Whether email notifications are enabled
	Enabled bool `json:"enabled"`
	// SMTP server hostname
	Host graphql.Omittable[*string] `json:"host,omitempty"`
	// SMTP server port
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// SMTP username for authentication
	Username graphql.Omittable[*string] `json:"username,omitempty"`
	// SMTP password for authentication
	Password graphql.Omittable[*string] `json:"password,omitempty"`
	// Email sender address
	FromAddress graphql.Omittable[*string] `json:"fromAddress,omitempty"`
	// Email sender display name
	FromName graphql.Omittable[*string] `json:"fromName,omitempty"`
	// Array of recipient email addresses
	ToAddresses []string `json:"toAddresses"`
	// Whether to use TLS/SSL
	UseTLS graphql.Omittable[*bool] `json:"useTLS,omitempty"`
	// Skip TLS certificate verification (use with caution)
	SkipVerify graphql.Omittable[*bool] `json:"skipVerify,omitempty"`
}

// Rich error extensions for detailed error diagnostics.
// Included in GraphQL error responses under the 'extensions' key.
type ErrorExtensions struct {
	// Error code for programmatic handling (e.g., 'V400', 'R200')
	Code string `json:"code"`
	// Error category (validation, protocol, network, auth, resource, internal)
	Category string `json:"category"`
	// Field path that caused the error (e.g., 'input.listenPort')
	Field *string `json:"field,omitempty"`
	// The invalid value (redacted in production for sensitive fields)
	Value map[string]interface{} `json:"value,omitempty"`
	// User-friendly suggestion for fixing the error
	SuggestedFix *string `json:"suggestedFix,omitempty"`
	// Link to relevant documentation
	DocsURL *string `json:"docsUrl,omitempty"`
	// Request correlation ID for support and debugging
	RequestID string `json:"requestId"`
	// Whether the error is recoverable (can be retried)
	Recoverable bool `json:"recoverable"`
	// Additional troubleshooting steps for complex errors
	TroubleshootingSteps []string `json:"troubleshootingSteps,omitempty"`
}

// Escalation configuration for unacknowledged alerts (NAS-18.9)
type EscalationConfig struct {
	// Whether escalation is enabled
	Enabled bool `json:"enabled"`
	// Whether alert must be acknowledged to stop escalation
	RequireAck bool `json:"requireAck"`
	// Delay in seconds before first escalation
	EscalationDelay int `json:"escalationDelay"`
	// Maximum number of escalation levels
	MaxEscalations int `json:"maxEscalations"`
	// Additional notification channels to add during escalation
	AdditionalChannels []string `json:"additionalChannels"`
	// Per-level delay intervals in seconds
	RepeatIntervals []int `json:"repeatIntervals"`
}

// Escalation configuration input (NAS-18.9)
type EscalationConfigInput struct {
	// Whether escalation is enabled (default: false)
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
	// Whether alert must be acknowledged to stop escalation (default: true)
	RequireAck graphql.Omittable[*bool] `json:"requireAck,omitempty"`
	// Delay in seconds before first escalation (default: 900 = 15min)
	EscalationDelay graphql.Omittable[*int] `json:"escalationDelay,omitempty"`
	// Maximum number of escalation levels (default: 3)
	MaxEscalations graphql.Omittable[*int] `json:"maxEscalations,omitempty"`
	// Additional notification channels to add during escalation
	AdditionalChannels graphql.Omittable[[]string] `json:"additionalChannels,omitempty"`
	// Per-level delay intervals in seconds (default: [900, 1800, 3600])
	RepeatIntervals graphql.Omittable[[]int] `json:"repeatIntervals,omitempty"`
}

// Options for exporting router configuration.
type ExportConfigInput struct {
	// Router ID to export configuration from
	RouterID string `json:"routerId"`
	// Whether to include credentials (requires encryptionKey if true)
	IncludeCredentials graphql.Omittable[*bool] `json:"includeCredentials,omitempty"`
	// User-provided encryption key for credential export (required if includeCredentials is true)
	EncryptionKey graphql.Omittable[*string] `json:"encryptionKey,omitempty"`
}

// Result of exporting router configuration.
type ExportConfigPayload struct {
	// Whether the export was successful
	Success bool `json:"success"`
	// Exported configuration data (JSON format)
	Config map[string]interface{} `json:"config,omitempty"`
	// Security warning message about credential handling
	SecurityWarning *string `json:"securityWarning,omitempty"`
	// Errors that occurred during export
	Errors []*MutationError `json:"errors,omitempty"`
}

// Information about a feature in the compatibility matrix
type FeatureCompatibilityInfo struct {
	// Feature identifier
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	Name string `json:"name"`
	// Minimum RouterOS version required
	MinVersion string `json:"minVersion"`
	// Maximum RouterOS version supported (if any)
	MaxVersion *string `json:"maxVersion,omitempty"`
	// Minimum version for CHR (if different)
	MinVersionChr *string `json:"minVersionCHR,omitempty"`
	// Required packages
	RequiredPackages []string `json:"requiredPackages"`
	// Feature dependencies
	DependsOn []string `json:"dependsOn"`
	// URL to MikroTik documentation
	UpgradeURL *string `json:"upgradeUrl,omitempty"`
}

// Input for checking feature compatibility
type FeatureCompatibilityInput struct {
	// Feature identifier to check
	FeatureID string `json:"featureId"`
	// Whether to check for CHR-specific requirements
	IsChr graphql.Omittable[*bool] `json:"isCHR,omitempty"`
}

// Feature deployment state
type FeatureDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Container ID (if containerized)
	ContainerID *string `json:"containerId,omitempty"`
	// Container image used
	ContainerImage *string `json:"containerImage,omitempty"`
	// Assigned ports
	AssignedPorts []Port `json:"assignedPorts,omitempty"`
	// Assigned IP address
	AssignedIP *IPv4 `json:"assignedIP,omitempty"`
}

// Marketplace Feature resource (Tor, AdGuard, sing-box, etc.)
type FeatureResource struct {
	ID                string                 `json:"id"`
	ScopedID          string                 `json:"scopedId"`
	Type              string                 `json:"type"`
	Category          ResourceCategory       `json:"category"`
	Configuration     map[string]interface{} `json:"configuration,omitempty"`
	Validation        *ValidationResult      `json:"validation,omitempty"`
	Deployment        *DeploymentState       `json:"deployment,omitempty"`
	Runtime           *RuntimeState          `json:"runtime,omitempty"`
	Telemetry         *TelemetryData         `json:"telemetry,omitempty"`
	Metadata          *ResourceMetadata      `json:"metadata"`
	Relationships     *ResourceRelationships `json:"relationships,omitempty"`
	Platform          *PlatformInfo          `json:"platform,omitempty"`
	FeatureDeployment *FeatureDeployment     `json:"featureDeployment,omitempty"`
	FeatureRuntime    *FeatureRuntime        `json:"featureRuntime,omitempty"`
	// Feature identifier
	FeatureID string `json:"featureId"`
	// Feature name
	Name string `json:"name"`
	// Feature version
	Version string `json:"version"`
	// Virtual interface assigned
	VirtualInterface *string `json:"virtualInterface,omitempty"`
}

func (FeatureResource) IsResource() {}

func (FeatureResource) IsNode() {}

// Feature runtime state
type FeatureRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Container status
	ContainerStatus *string `json:"containerStatus,omitempty"`
	// Memory usage
	MemoryUsage *Size `json:"memoryUsage,omitempty"`
	// CPU usage percentage
	CPUUsagePercent *float64 `json:"cpuUsagePercent,omitempty"`
	// Devices routed through this feature
	RoutedDevices *int `json:"routedDevices,omitempty"`
}

// Feature support information based on RouterOS version
type FeatureSupport struct {
	// Feature identifier (e.g., 'rest_api', 'container', 'wireguard')
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	Name string `json:"name"`
	// Whether the feature is supported on this router
	Supported bool `json:"supported"`
	// Capability level (none, basic, advanced, full)
	Level CapabilityLevel `json:"level"`
	// Reason why the feature is not supported (if applicable)
	Reason *string `json:"reason,omitempty"`
	// Minimum RouterOS version required for this feature
	RequiredVersion *string `json:"requiredVersion,omitempty"`
	// URL to MikroTik documentation for upgrade guidance
	UpgradeURL *string `json:"upgradeUrl,omitempty"`
	// Required packages that need to be installed
	RequiredPackages []string `json:"requiredPackages,omitempty"`
	// Missing packages (if any)
	MissingPackages []string `json:"missingPackages,omitempty"`
}

// Firewall rule placeholder type.
// TODO: Expand with full filter/NAT/mangle rule types in future stories.
type FirewallRule struct {
	// Rule ID
	ID string `json:"id"`
	// Rule type (filter, nat, mangle)
	Type string `json:"type"`
	// Rule chain (input, forward, output, prerouting, postrouting, etc.)
	Chain string `json:"chain"`
	// Rule action (accept, drop, reject, etc.)
	Action string `json:"action"`
	// Source address list reference
	SrcAddressList *string `json:"srcAddressList,omitempty"`
	// Destination address list reference
	DstAddressList *string `json:"dstAddressList,omitempty"`
	// Optional comment
	Comment *string `json:"comment,omitempty"`
	// Whether rule is disabled
	Disabled bool `json:"disabled"`
}

func (FirewallRule) IsNode() {}

// Firewall rule reference type (lightweight for dependency tracking).
// For full firewall rule management, see FirewallRule type in firewall.graphql.
type FirewallRuleReference struct {
	// Firewall rule ID
	ID string `json:"id"`
	// Rule chain
	Chain string `json:"chain"`
	// Rule action
	Action string `json:"action"`
	// Input interface filter
	InInterface *string `json:"inInterface,omitempty"`
	// Output interface filter
	OutInterface *string `json:"outInterface,omitempty"`
	// Whether the rule is disabled
	Disabled bool `json:"disabled"`
}

// Firewall Rule resource
type FirewallRuleResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Rule chain (input, forward, output)
	Chain string `json:"chain"`
	// Rule action (accept, drop, reject)
	Action string `json:"action"`
	// Source address/network
	SrcAddress *string `json:"srcAddress,omitempty"`
	// Destination address/network
	DstAddress *string `json:"dstAddress,omitempty"`
	// Source port(s)
	SrcPort *string `json:"srcPort,omitempty"`
	// Destination port(s)
	DstPort *string `json:"dstPort,omitempty"`
	// Protocol (tcp, udp, icmp, etc.)
	Protocol *string `json:"protocol,omitempty"`
	// Rule comment
	Comment *string `json:"comment,omitempty"`
	// Whether rule is enabled
	Enabled bool `json:"enabled"`
	// Hit counter
	HitCount *int `json:"hitCount,omitempty"`
}

func (FirewallRuleResource) IsResource() {}

func (FirewallRuleResource) IsNode() {}

// Firewall template with pre-configured rule sets.
// Templates allow quick application of common firewall configurations.
type FirewallTemplate struct {
	// Unique template identifier
	ID string `json:"id"`
	// Human-readable template name
	Name string `json:"name"`
	// Detailed description of what this template does
	Description string `json:"description"`
	// Category for organization
	Category TemplateCategory `json:"category"`
	// Complexity level indicator
	Complexity TemplateComplexity `json:"complexity"`
	// Total number of rules in this template
	RuleCount int `json:"ruleCount"`
	// Variables that can be customized before applying
	Variables []*FirewallTemplateVariable `json:"variables"`
	// Rules that will be created
	Rules []*TemplateRule `json:"rules"`
	// Whether this is a built-in template
	IsBuiltIn bool `json:"isBuiltIn"`
	// Template version for compatibility tracking
	Version string `json:"version"`
	// When this template was created (null for built-in)
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	// When this template was last modified (null for built-in)
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// Result of template application.
type FirewallTemplateResult struct {
	// Whether application succeeded
	Success bool `json:"success"`
	// Number of rules successfully applied
	AppliedRulesCount int `json:"appliedRulesCount"`
	// Rollback ID for undo (valid for 5 minutes)
	RollbackID string `json:"rollbackId"`
	// Errors encountered during application
	Errors []string `json:"errors,omitempty"`
}

// Variable definition for template customization.
// Variables allow parameterization of templates for different network configurations.
type FirewallTemplateVariable struct {
	// Variable name (used in rule properties)
	Name string `json:"name"`
	// Human-readable label for UI
	Label string `json:"label"`
	// Variable type for validation
	Type VariableType `json:"type"`
	// Default value if not specified
	DefaultValue *string `json:"defaultValue,omitempty"`
	// Whether this variable is required
	Required bool `json:"required"`
	// Description to help users understand the variable
	Description *string `json:"description,omitempty"`
	// Available options (populated from router for INTERFACE type)
	Options []string `json:"options,omitempty"`
}

// Input for defining a template variable.
type FirewallTemplateVariableInput struct {
	// Variable name
	Name string `json:"name"`
	// Label for UI
	Label string `json:"label"`
	// Variable type
	Type VariableType `json:"type"`
	// Default value
	DefaultValue graphql.Omittable[*string] `json:"defaultValue,omitempty"`
	// Whether required
	Required bool `json:"required"`
	// Description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

// Result of flushing the DNS cache
type FlushDNSCacheResult struct {
	// Whether the cache was flushed successfully
	Success bool `json:"success"`
	// Number of entries removed from the cache
	EntriesRemoved int `json:"entriesRemoved"`
	// Cache statistics before flushing
	BeforeStats *DNSCacheStats `json:"beforeStats"`
	// Cache statistics after flushing
	AfterStats *DNSCacheStats `json:"afterStats"`
	// User-friendly message
	Message string `json:"message"`
	// When the flush was executed
	Timestamp time.Time `json:"timestamp"`
}

// Result of checking gateway reachability
type GatewayReachabilityResult struct {
	// Whether the gateway is reachable
	Reachable bool `json:"reachable"`
	// Ping latency in milliseconds (null if unreachable)
	Latency *int `json:"latency,omitempty"`
	// Interface through which gateway is reachable (null if unreachable)
	Interface *string `json:"interface,omitempty"`
	// Human-readable message about reachability
	Message string `json:"message"`
}

// Hardware information detected from router
type HardwareInfo struct {
	// CPU architecture (arm, arm64, x86_64, etc.)
	Architecture string `json:"architecture"`
	// Router model name
	Model *string `json:"model,omitempty"`
	// Board name
	BoardName *string `json:"boardName,omitempty"`
	// Total RAM in bytes
	TotalMemory Size `json:"totalMemory"`
	// Available storage in bytes
	AvailableStorage Size `json:"availableStorage"`
	// Number of CPU cores
	CPUCount int `json:"cpuCount"`
	// Whether wireless hardware is present
	HasWirelessChip bool `json:"hasWirelessChip"`
	// Whether LTE/cellular hardware is present
	HasLTEModule bool `json:"hasLTEModule"`
}

// Health check result for a router
type HealthCheckResult struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Whether the router is healthy
	Healthy bool `json:"healthy"`
	// When the check was performed
	CheckedAt time.Time `json:"checkedAt"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if unhealthy
	Error *string `json:"error,omitempty"`
}

// Overall system health status
type HealthStatus struct {
	// Service status
	Status ServiceStatus `json:"status"`
	// Service version
	Version string `json:"version"`
	// Server uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Connected router count
	ConnectedRouters int `json:"connectedRouters"`
	// Last health check timestamp
	CheckedAt time.Time `json:"checkedAt"`
}

// A single probe result within a hop
type HopProbe struct {
	// Probe number (1-3 typically)
	ProbeNumber int `json:"probeNumber"`
	// Latency in milliseconds (null for timeout)
	LatencyMs *float64 `json:"latencyMs,omitempty"`
	// Whether the probe succeeded
	Success bool `json:"success"`
	// ICMP error code if probe failed
	ICMPCode *string `json:"icmpCode,omitempty"`
}

// Hourly statistics
type HourlyStats struct {
	// Hour start timestamp
	Hour time.Time `json:"hour"`
	// Total bytes in
	TotalBytesIn Size `json:"totalBytesIn"`
	// Total bytes out
	TotalBytesOut Size `json:"totalBytesOut"`
	// Uptime percentage (0-100)
	UptimePercent float64 `json:"uptimePercent"`
	// Error count
	ErrorCount int `json:"errorCount"`
}

// ISP contact information
type ISPInfo struct {
	// ISP name
	Name string `json:"name"`
	// ISP support phone number
	Phone *string `json:"phone,omitempty"`
	// ISP support website URL
	URL *string `json:"url,omitempty"`
}

// Analysis of template application impact.
// Provides estimates and warnings before applying.
type ImpactAnalysis struct {
	// Number of new rules that will be created
	NewRulesCount int `json:"newRulesCount"`
	// Chains that will be affected
	AffectedChains []string `json:"affectedChains"`
	// Estimated time to apply (seconds)
	EstimatedApplyTime int `json:"estimatedApplyTime"`
	// Warnings about potential issues
	Warnings []string `json:"warnings"`
}

// Integer range for filtering
type IntRange struct {
	// Minimum value (inclusive)
	Min graphql.Omittable[*int] `json:"min,omitempty"`
	// Maximum value (inclusive)
	Max graphql.Omittable[*int] `json:"max,omitempty"`
}

// A network interface on a router
type Interface struct {
	// Unique interface identifier
	ID string `json:"id"`
	// Interface name (e.g., ether1, wlan1)
	Name string `json:"name"`
	// Interface type
	Type InterfaceType `json:"type"`
	// Whether the interface is enabled
	Enabled bool `json:"enabled"`
	// Whether the interface is running (link up)
	Running bool `json:"running"`
	// MAC address
	MacAddress *MAC `json:"macAddress,omitempty"`
	// MTU setting
	Mtu *int `json:"mtu,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// TX bytes
	TxBytes *Size `json:"txBytes,omitempty"`
	// RX bytes
	RxBytes *Size `json:"rxBytes,omitempty"`
	// IP address assigned to this interface
	IP *IPv4 `json:"ip,omitempty"`
	// Operational status of the interface
	Status InterfaceStatus `json:"status"`
	// Current transmit rate in bytes per second
	TxRate *Size `json:"txRate,omitempty"`
	// Current receive rate in bytes per second
	RxRate *Size `json:"rxRate,omitempty"`
	// Link speed (e.g., 1Gbps, 100Mbps)
	LinkSpeed *string `json:"linkSpeed,omitempty"`
	// Last time this interface was seen/queried
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// Connected device information from LLDP
	LinkPartner *string `json:"linkPartner,omitempty"`
	// Services using this interface (bridge, VPN, etc.)
	UsedBy []string `json:"usedBy,omitempty"`
}

func (Interface) IsNode() {}

type InterfaceConnection struct {
	Edges      []*InterfaceEdge `json:"edges"`
	PageInfo   *PageInfo        `json:"pageInfo"`
	TotalCount *int             `json:"totalCount,omitempty"`
}

func (InterfaceConnection) IsConnection() {}

type InterfaceEdge struct {
	Node   *Interface `json:"node"`
	Cursor string     `json:"cursor"`
}

func (InterfaceEdge) IsEdge() {}

// Error information for a single interface operation in a batch
type InterfaceOperationError struct {
	// Interface ID that failed
	InterfaceID string `json:"interfaceId"`
	// Interface name
	InterfaceName string `json:"interfaceName"`
	// Error message describing why the operation failed
	Error string `json:"error"`
}

// Interface traffic statistics
type InterfaceStats struct {
	// Total bytes transmitted
	TxBytes Size `json:"txBytes"`
	// Total bytes received
	RxBytes Size `json:"rxBytes"`
	// Total packets transmitted
	TxPackets Size `json:"txPackets"`
	// Total packets received
	RxPackets Size `json:"rxPackets"`
	// Transmission errors
	TxErrors int `json:"txErrors"`
	// Receive errors
	RxErrors int `json:"rxErrors"`
	// Transmission drops
	TxDrops int `json:"txDrops"`
	// Receive drops
	RxDrops int `json:"rxDrops"`
}

// Historical interface statistics with time-series data
type InterfaceStatsHistory struct {
	// Interface ID
	InterfaceID string `json:"interfaceId"`
	// Time-series data points
	DataPoints []*StatsDataPoint `json:"dataPoints"`
	// Aggregation interval (e.g., 5m, 1h)
	Interval Duration `json:"interval"`
	// Start of the time range
	StartTime time.Time `json:"startTime"`
	// End of the time range
	EndTime time.Time `json:"endTime"`
}

// Event emitted when an interface status changes
type InterfaceStatusEvent struct {
	// Interface ID
	InterfaceID string `json:"interfaceId"`
	// Interface name
	InterfaceName string `json:"interfaceName"`
	// New status
	Status InterfaceStatus `json:"status"`
	// Previous status
	PreviousStatus InterfaceStatus `json:"previousStatus"`
	// Event timestamp
	Timestamp time.Time `json:"timestamp"`
}

type InterfaceTrafficEvent struct {
	// Interface ID
	InterfaceID string `json:"interfaceId"`
	// Interface name
	InterfaceName string `json:"interfaceName"`
	// TX rate in bytes per second
	TxRate Size `json:"txRate"`
	// RX rate in bytes per second
	RxRate Size `json:"rxRate"`
	// Total TX bytes
	TxTotal Size `json:"txTotal"`
	// Total RX bytes
	RxTotal Size `json:"rxTotal"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// An IP address assigned to an interface
type IPAddress struct {
	// Unique IP address identifier
	ID string `json:"id"`
	// IP address with CIDR notation (e.g., 192.168.10.1/24)
	Address string `json:"address"`
	// Network address (calculated from address and netmask)
	Network *string `json:"network,omitempty"`
	// Broadcast address (calculated from address and netmask)
	Broadcast *string `json:"broadcast,omitempty"`
	// Interface this IP is assigned to
	Interface *Interface `json:"interface"`
	// Whether this IP is disabled
	Disabled bool `json:"disabled"`
	// Whether this IP was dynamically assigned (via DHCP client)
	Dynamic bool `json:"dynamic"`
	// Whether this IP is invalid (conflicting or error state)
	Invalid bool `json:"invalid"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (IPAddress) IsNode() {}

// Event emitted when an IP address changes
type IPAddressChangeEvent struct {
	// Type of change (CREATED, UPDATED, DELETED)
	ChangeType ChangeType `json:"changeType"`
	// The IP address that changed
	IPAddress *IPAddress `json:"ipAddress,omitempty"`
	// IP address ID (for deletions)
	IPAddressID string `json:"ipAddressId"`
	// Timestamp of the change
	Timestamp time.Time `json:"timestamp"`
}

// Result of an IP address deletion with dependency checking
type IPAddressDeleteResult struct {
	// Whether the deletion succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// Impact analysis for this IP address deletion
	ImpactAnalysis *IPAddressImpactAnalysis `json:"impactAnalysis,omitempty"`
	// Errors that occurred during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

// Dependencies for an IP address
type IPAddressDependencies struct {
	// IP address ID
	IPAddressID string `json:"ipAddressId"`
	// DHCP servers using this IP as gateway
	DhcpServers []*DhcpServer `json:"dhcpServers"`
	// Static routes using this IP
	Routes []*Route `json:"routes"`
	// NAT rules referencing this IP
	NatRules []*NatRuleReference `json:"natRules"`
	// Firewall rules referencing this IP
	FirewallRules []*FirewallRuleReference `json:"firewallRules"`
	// Whether the IP has any dependencies
	HasDependencies bool `json:"hasDependencies"`
}

// Analysis of the impact of deleting an IP address
type IPAddressImpactAnalysis struct {
	// Whether this IP is used as a gateway by DHCP servers
	UsedByDhcpServers []*DhcpServer `json:"usedByDhcpServers"`
	// Whether this IP is referenced in firewall rules
	UsedInFirewallRules []*FirewallRuleReference `json:"usedInFirewallRules"`
	// Whether this IP is used in NAT rules
	UsedInNatRules []*NatRuleReference `json:"usedInNatRules"`
	// Number of active connections using this IP
	ActiveConnections int `json:"activeConnections"`
	// Severity of the deletion
	Severity ConfirmationSeverity `json:"severity"`
	// Human-readable impact message
	Message string `json:"message"`
	// List of consequences of deleting this IP
	Consequences []string `json:"consequences"`
	// Whether the IP can be safely deleted
	CanDelete bool `json:"canDelete"`
}

// Input for creating or updating an IP address
type IPAddressInput struct {
	// IP address with CIDR notation (e.g., 192.168.10.1/24)
	Address string `json:"address"`
	// Interface ID to assign this IP to
	InterfaceID string `json:"interfaceId"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
	// Whether this IP is disabled
	Disabled graphql.Omittable[*bool] `json:"disabled,omitempty"`
}

// Result of an IP address mutation (create, update)
type IPAddressMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The created or updated IP address (if successful)
	IPAddress *IPAddress `json:"ipAddress,omitempty"`
	// Configuration preview (RouterOS commands)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Errors that occurred during the operation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Details about an IP address conflict
type IPConflict struct {
	// Conflicting IP address ID
	ID string `json:"id"`
	// Conflicting IP address
	Address string `json:"address"`
	// Interface where conflict exists
	Interface *Interface `json:"interface"`
	// Type of conflict
	ConflictType IPConflictType `json:"conflictType"`
	// Explanation of the conflict
	Explanation string `json:"explanation"`
}

// Result of checking IP address conflicts
type IPConflictResult struct {
	// Whether the IP conflicts with existing assignments
	HasConflict bool `json:"hasConflict"`
	// List of conflicting IP addresses
	Conflicts []*IPConflict `json:"conflicts"`
	// Human-readable message
	Message string `json:"message"`
}

// IPsec profile for GRE tunnel encryption
type IpsecProfile struct {
	// IPsec profile ID
	ID string `json:"id"`
	// Profile name
	Name string `json:"name"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

// Single knock port in sequence.
type KnockPort struct {
	// Port number (1-65535)
	Port int `json:"port"`
	// Protocol for this knock port
	Protocol KnockProtocol `json:"protocol"`
	// Position in sequence (1-based)
	Order int `json:"order"`
}

// Input for knock port.
type KnockPortInput struct {
	// Port number
	Port int `json:"port"`
	// Protocol
	Protocol KnockProtocol `json:"protocol"`
	// Order in sequence
	Order int `json:"order"`
}

// LAN Network composite resource - groups bridge, DHCP, firewall, routing
type LANNetwork struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration,omitempty"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	Config        *LANNetworkConfig      `json:"config"`
	LanDeployment *LANNetworkDeployment  `json:"lanDeployment,omitempty"`
	LanRuntime    *LANNetworkRuntime     `json:"lanRuntime,omitempty"`
	// Bridge interface
	Bridge *BridgeResource `json:"bridge,omitempty"`
	// DHCP server configuration
	DhcpServer *DHCPServerResource `json:"dhcpServer,omitempty"`
	// Firewall rules for this LAN
	FirewallRules []*FirewallRuleResource `json:"firewallRules"`
	// Static routes
	Routes []*RouteResource `json:"routes"`
}

func (LANNetwork) IsResource() {}

func (LANNetwork) IsNode() {}

// LAN Network configuration
type LANNetworkConfig struct {
	// Network name
	Name string `json:"name"`
	// IP address for the LAN
	IPAddress IPv4 `json:"ipAddress"`
	// Subnet mask in CIDR notation
	SubnetMask int `json:"subnetMask"`
	// Interfaces to include in bridge
	Interfaces []string `json:"interfaces"`
	// Enable DHCP server
	DhcpEnabled bool `json:"dhcpEnabled"`
	// DHCP pool start
	DhcpPoolStart *IPv4 `json:"dhcpPoolStart,omitempty"`
	// DHCP pool end
	DhcpPoolEnd *IPv4 `json:"dhcpPoolEnd,omitempty"`
	// DHCP lease time
	DhcpLeaseTime *Duration `json:"dhcpLeaseTime,omitempty"`
	// DNS servers for DHCP
	DNSServers []IPv4 `json:"dnsServers,omitempty"`
	// Enable NAT masquerading
	EnableNat bool `json:"enableNat"`
	// VLAN ID (optional)
	VlanID *int `json:"vlanId,omitempty"`
}

// LAN Network deployment state
type LANNetworkDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Bridge interface ID on router
	BridgeID *string `json:"bridgeId,omitempty"`
	// DHCP server ID on router
	DhcpServerID *string `json:"dhcpServerId,omitempty"`
	// IP address ID on router
	IPAddressID *string `json:"ipAddressId,omitempty"`
}

// LAN Network runtime state
type LANNetworkRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Number of active clients
	ActiveClients int `json:"activeClients"`
	// Active DHCP leases
	DhcpLeases int `json:"dhcpLeases"`
	// Total traffic in
	TotalBytesIn Size `json:"totalBytesIn"`
	// Total traffic out
	TotalBytesOut Size `json:"totalBytesOut"`
}

// LTE/cellular modem configuration
type LteModem struct {
	// Unique identifier
	ID string `json:"id"`
	// LTE interface name
	Name string `json:"name"`
	// APN (Access Point Name)
	Apn string `json:"apn"`
	// Signal strength (RSSI in dBm)
	SignalStrength *int `json:"signalStrength,omitempty"`
	// Connection status
	Running bool `json:"running"`
	// Operator name
	Operator *string `json:"operator,omitempty"`
	// Network type (LTE, 3G, etc.)
	NetworkType *string `json:"networkType,omitempty"`
	// PIN code configured
	PinConfigured bool `json:"pinConfigured"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (LteModem) IsNode() {}

// Input for configuring LTE modem
type LteModemInput struct {
	// LTE interface name
	Name string `json:"name"`
	// APN (Access Point Name)
	Apn string `json:"apn"`
	// PIN code (optional, for SIM card)
	Pin graphql.Omittable[*string] `json:"pin,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Memory utilization metrics
type MemoryMetrics struct {
	// Used memory in bytes
	Used float64 `json:"used"`
	// Total memory in bytes
	Total float64 `json:"total"`
	// Memory usage percentage (0-100)
	Percentage float64 `json:"percentage"`
}

// Missing dependency information
type MissingDependency struct {
	// Item ID with missing dependency
	ItemID string `json:"itemId"`
	// Missing resource type
	MissingResourceType string `json:"missingResourceType"`
	// Missing resource ID
	MissingResourceID string `json:"missingResourceId"`
}

// MTU guidance for tunnel configuration
type MtuGuidance struct {
	// Tunnel type this guidance applies to
	TunnelType TunnelType `json:"tunnelType"`
	// Protocol overhead in bytes
	Overhead int `json:"overhead"`
	// Recommended MTU based on base MTU (typically 1500)
	RecommendedMtu int `json:"recommendedMtu"`
	// Human-readable explanation of the overhead
	Explanation string `json:"explanation"`
}

type Mutation struct {
}

// Standard error type for mutations
type MutationError struct {
	// Error code for programmatic handling
	Code string `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Field that caused the error (if applicable)
	Field *string `json:"field,omitempty"`
}

// NAT rule configuration for network address translation.
// Handles both source NAT (masquerade) and destination NAT (port forwarding).
type NatRule struct {
	// MikroTik internal ID
	ID string `json:"id"`
	// NAT chain (srcnat or dstnat)
	Chain NatChain `json:"chain"`
	// NAT action
	Action NatAction `json:"action"`
	// Source address or CIDR
	SrcAddress *string `json:"srcAddress,omitempty"`
	// Destination address or CIDR
	DstAddress *string `json:"dstAddress,omitempty"`
	// Source port or port range
	SrcPort *string `json:"srcPort,omitempty"`
	// Destination port or port range
	DstPort *string `json:"dstPort,omitempty"`
	// Protocol (TCP, UDP)
	Protocol *TransportProtocol `json:"protocol,omitempty"`
	// Target address for NAT
	ToAddresses *string `json:"toAddresses,omitempty"`
	// Target port(s) for NAT
	ToPorts *string `json:"toPorts,omitempty"`
	// Incoming interface
	InInterface *string `json:"inInterface,omitempty"`
	// Outgoing interface
	OutInterface *string `json:"outInterface,omitempty"`
	// Optional comment
	Comment *string `json:"comment,omitempty"`
	// Whether rule is disabled
	Disabled bool `json:"disabled"`
	// Bytes processed by this rule
	Bytes int `json:"bytes"`
	// Packets processed by this rule
	Packets int `json:"packets"`
	// Rule position in chain
	Position int `json:"position"`
}

func (NatRule) IsNode() {}

// NAT rule reference type (lightweight for dependency tracking).
// For full NAT rule management, see NatRule type in firewall.graphql.
type NatRuleReference struct {
	// NAT rule ID
	ID string `json:"id"`
	// Rule chain (srcnat, dstnat)
	Chain string `json:"chain"`
	// Action (masquerade, dst-nat, src-nat)
	Action string `json:"action"`
	// Source address
	SrcAddress *string `json:"srcAddress,omitempty"`
	// Destination address
	DstAddress *string `json:"dstAddress,omitempty"`
	// To address (for dst-nat)
	ToAddress *string `json:"toAddress,omitempty"`
	// Whether the rule is disabled
	Disabled bool `json:"disabled"`
}

// Network configuration detection result
type NetworkConfigDetection struct {
	// Detected WAN interface name
	WanInterface string `json:"wanInterface"`
	// Detected default gateway IP
	Gateway *string `json:"gateway,omitempty"`
	// Detected ISP information
	IspInfo *ISPInfo `json:"ispInfo,omitempty"`
}

// Notification channel configuration with encrypted credentials
type NotificationChannelConfig struct {
	// Unique configuration ID
	ID string `json:"id"`
	// Type of notification channel
	ChannelType ChannelType `json:"channelType"`
	// Human-readable name for this configuration
	Name string `json:"name"`
	// Optional description
	Description *string `json:"description,omitempty"`
	// Whether this configuration is enabled
	Enabled bool `json:"enabled"`
	// Whether this is the default configuration for this channel type
	IsDefault bool `json:"isDefault"`
	// Masked configuration (sensitive fields redacted)
	// For Pushover: {"device": "iphone", "baseURL": "...", "userKey": "******", "apiToken": "******"}
	// For Email: {"host": "smtp.gmail.com", "port": 587, "from": "...", "password": "******"}
	ConfigMasked map[string]interface{} `json:"configMasked"`
	// When this configuration was created
	CreatedAt time.Time `json:"createdAt"`
	// When this configuration was last updated
	UpdatedAt time.Time `json:"updatedAt"`
	// User ID who created this configuration
	CreatedBy *string `json:"createdBy,omitempty"`
	// User ID who last updated this configuration
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Notification delivery log entry
type NotificationLog struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Alert that triggered this notification
	AlertID string `json:"alertId"`
	// Notification channel type (email, telegram, pushover, webhook)
	Channel string `json:"channel"`
	// Webhook ID (if channel is webhook)
	WebhookID *string `json:"webhookId,omitempty"`
	// Delivery status
	Status NotificationStatus `json:"status"`
	// HTTP status code (for webhooks)
	StatusCode *int `json:"statusCode,omitempty"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if delivery failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Number of retry attempts
	RetryCount int `json:"retryCount"`
	// Request payload sent
	RequestPayload map[string]interface{} `json:"requestPayload,omitempty"`
	// Response body received
	ResponseBody *string `json:"responseBody,omitempty"`
	// When delivery was attempted
	AttemptedAt time.Time `json:"attemptedAt"`
	// When delivery was completed (success or final failure)
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

func (NotificationLog) IsNode() {}

// Notification template preview result
// Simplified preview output for template customization
type NotificationTemplatePreview struct {
	// Rendered subject line (empty if channel doesn't use subjects)
	Subject *string `json:"subject,omitempty"`
	// Rendered body content
	Body string `json:"body"`
	// Validation errors (empty array if valid)
	Errors []string `json:"errors"`
}

// Operation counts by type
type OperationCounts struct {
	Create int `json:"create"`
	Update int `json:"update"`
	Delete int `json:"delete"`
}

// Information about pagination in a connection
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// Cursor for the first edge
	StartCursor *string `json:"startCursor,omitempty"`
	// Cursor for the last edge
	EndCursor *string `json:"endCursor,omitempty"`
}

// Standard pagination input arguments
type PaginationInput struct {
	// Number of items to fetch
	First graphql.Omittable[*int] `json:"first,omitempty"`
	// Cursor to fetch items after
	After graphql.Omittable[*string] `json:"after,omitempty"`
	// Number of items to fetch from the end
	Last graphql.Omittable[*int] `json:"last,omitempty"`
	// Cursor to fetch items before
	Before graphql.Omittable[*string] `json:"before,omitempty"`
}

// Platform capabilities for a resource type
type PlatformCapabilities struct {
	// Whether this resource type is supported
	IsSupported bool `json:"isSupported"`
	// Capability level
	Level CapabilityLevel `json:"level"`
	// Minimum platform version required
	MinVersion *string `json:"minVersion,omitempty"`
	// Required packages
	RequiredPackages []string `json:"requiredPackages,omitempty"`
	// Capability-specific details
	Details map[string]interface{} `json:"details,omitempty"`
}

// A platform-specific feature
type PlatformFeature struct {
	// Feature identifier
	ID string `json:"id"`
	// Feature name
	Name string `json:"name"`
	// Whether feature is enabled
	Enabled bool `json:"enabled"`
	// Feature description
	Description *string `json:"description,omitempty"`
}

// Layer 8: Platform-specific capabilities and field mappings.
// From platform adapter (MikroTik, OpenWrt, VyOS).
type PlatformInfo struct {
	// Current platform
	Current RouterPlatform `json:"current"`
	// Platform-specific capabilities for this resource type
	Capabilities *PlatformCapabilities `json:"capabilities"`
	// Field mappings between GraphQL and platform-native names
	FieldMappings map[string]interface{} `json:"fieldMappings,omitempty"`
	// Platform-specific limitations or constraints
	Limitations []*PlatformLimitation `json:"limitations,omitempty"`
	// Platform-specific features available
	Features []*PlatformFeature `json:"features,omitempty"`
}

// A platform-specific limitation
type PlatformLimitation struct {
	// Limitation identifier
	Code string `json:"code"`
	// Human-readable description
	Description string `json:"description"`
	// Affected fields
	AffectedFields []string `json:"affectedFields,omitempty"`
	// Workaround if available
	Workaround *string `json:"workaround,omitempty"`
}

// Port forward configuration (high-level view).
// Represents both the NAT rule and corresponding filter rule.
type PortForward struct {
	// Unique identifier
	ID string `json:"id"`
	// Optional name/description
	Name *string `json:"name,omitempty"`
	// Protocol (TCP, UDP)
	Protocol TransportProtocol `json:"protocol"`
	// External port
	ExternalPort int `json:"externalPort"`
	// Internal target IP
	InternalIP string `json:"internalIP"`
	// Internal target port
	InternalPort int `json:"internalPort"`
	// Current status
	Status PortForwardStatus `json:"status"`
	// ID of the associated NAT rule
	NatRuleID string `json:"natRuleId"`
	// ID of the associated filter rule (if created)
	FilterRuleID *string `json:"filterRuleId,omitempty"`
}

func (PortForward) IsNode() {}

// Input for creating a port forward (simplified wizard).
// Creates both NAT and filter rules automatically.
type PortForwardInput struct {
	// Protocol (TCP, UDP)
	Protocol TransportProtocol `json:"protocol"`
	// External port (1-65535)
	ExternalPort int `json:"externalPort"`
	// Internal target IP address
	InternalIP string `json:"internalIP"`
	// Internal target port (defaults to external port if not specified)
	InternalPort graphql.Omittable[*int] `json:"internalPort,omitempty"`
	// Optional name/description for this port forward
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// WAN interface name (optional, auto-detected if not specified)
	WanInterface graphql.Omittable[*string] `json:"wanInterface,omitempty"`
}

// Port knock attempt log entry.
type PortKnockAttempt struct {
	// Attempt ID
	ID string `json:"id"`
	// Sequence ID
	SequenceID string `json:"sequenceId"`
	// Sequence name
	SequenceName string `json:"sequenceName"`
	// Source IP address
	SourceIP string `json:"sourceIP"`
	// Attempt timestamp
	Timestamp time.Time `json:"timestamp"`
	// Attempt status
	Status KnockStatus `json:"status"`
	// Ports hit in order
	PortsHit []int `json:"portsHit"`
	// Protected service port
	ProtectedPort int `json:"protectedPort"`
	// Progress indicator (e.g., "2/4")
	Progress string `json:"progress"`
}

func (PortKnockAttempt) IsNode() {}

// Connection type for paginated knock attempts.
type PortKnockAttemptConnection struct {
	Edges      []*PortKnockAttemptEdge `json:"edges"`
	PageInfo   *PageInfo               `json:"pageInfo"`
	TotalCount *int                    `json:"totalCount,omitempty"`
}

func (PortKnockAttemptConnection) IsConnection() {}

// Edge type for knock attempt connections.
type PortKnockAttemptEdge struct {
	Cursor string            `json:"cursor"`
	Node   *PortKnockAttempt `json:"node"`
}

func (PortKnockAttemptEdge) IsEdge() {}

// Filters for knock attempt log.
type PortKnockLogFilters struct {
	// Filter by status
	Status graphql.Omittable[*KnockStatus] `json:"status,omitempty"`
	// Filter by source IP
	SourceIP graphql.Omittable[*string] `json:"sourceIP,omitempty"`
	// Filter by sequence ID
	SequenceID graphql.Omittable[*string] `json:"sequenceId,omitempty"`
	// Start date
	StartDate graphql.Omittable[*time.Time] `json:"startDate,omitempty"`
	// End date
	EndDate graphql.Omittable[*time.Time] `json:"endDate,omitempty"`
}

// Port knocking sequence configuration.
// Implements stage-based address list progression for hiding services.
type PortKnockSequence struct {
	// Unique sequence identifier
	ID string `json:"id"`
	// Sequence name (alphanumeric, underscores, hyphens)
	Name string `json:"name"`
	// Ordered list of knock ports (2-8 ports)
	KnockPorts []*KnockPort `json:"knockPorts"`
	// Protected service port
	ProtectedPort int `json:"protectedPort"`
	// Protected service protocol
	ProtectedProtocol TransportProtocol `json:"protectedProtocol"`
	// Access timeout after successful knock
	AccessTimeout string `json:"accessTimeout"`
	// Max time between knocks
	KnockTimeout string `json:"knockTimeout"`
	// Whether sequence is enabled
	Enabled bool `json:"enabled"`
	// Router ID
	RouterID string `json:"routerId"`
	// When sequence was created
	CreatedAt time.Time `json:"createdAt"`
	// When sequence was last updated
	UpdatedAt time.Time `json:"updatedAt"`
	// Successful knocks in last 24h
	RecentAccessCount int `json:"recentAccessCount"`
	// Generated firewall rule IDs
	GeneratedRuleIds []string `json:"generatedRuleIds"`
}

func (PortKnockSequence) IsNode() {}

// Input for creating/updating port knock sequence.
type PortKnockSequenceInput struct {
	// Sequence name
	Name string `json:"name"`
	// Ordered knock ports (2-8)
	KnockPorts []*KnockPortInput `json:"knockPorts"`
	// Protected service port
	ProtectedPort int `json:"protectedPort"`
	// Protected service protocol
	ProtectedProtocol TransportProtocol `json:"protectedProtocol"`
	// Access timeout (e.g., "5m", "1h")
	AccessTimeout string `json:"accessTimeout"`
	// Knock timeout (e.g., "15s", "30s")
	KnockTimeout string `json:"knockTimeout"`
	// Whether enabled
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

// A port mirror configuration for traffic monitoring and analysis
type PortMirror struct {
	// Unique port mirror identifier
	ID string `json:"id"`
	// Descriptive name for the mirror configuration
	Name string `json:"name"`
	// Source interfaces being mirrored
	SourceInterfaces []*Interface `json:"sourceInterfaces"`
	// Destination interface where mirrored traffic is sent
	DestinationInterface *Interface `json:"destinationInterface"`
	// Direction of traffic to mirror
	Direction MirrorDirection `json:"direction"`
	// Whether the mirror is enabled
	Enabled bool `json:"enabled"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// Statistics for the destination interface
	Statistics *PortMirrorStats `json:"statistics,omitempty"`
}

func (PortMirror) IsNode() {}

// Result of a port mirror mutation (create, update)
type PortMirrorMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The created or updated port mirror (if successful)
	PortMirror *PortMirror `json:"portMirror,omitempty"`
	// Configuration preview (RouterOS commands)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Errors that occurred during the operation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Statistics for a port mirror destination interface
type PortMirrorStats struct {
	// Total mirrored packets
	MirroredPackets Size `json:"mirroredPackets"`
	// Total mirrored bytes
	MirroredBytes Size `json:"mirroredBytes"`
	// Destination interface current load
	DestinationLoad float64 `json:"destinationLoad"`
	// Whether the destination is saturated (dropping packets)
	IsSaturated bool `json:"isSaturated"`
}

// Status of a single port check
type PortStatus struct {
	// Port number checked
	Port int `json:"port"`
	// Service name (API, API-SSL, SSH, Telnet, HTTP, HTTPS)
	Service string `json:"service"`
	// Whether the port is open and accepting connections
	Open bool `json:"open"`
	// Response time in milliseconds (if port is open)
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message (if port is closed)
	Error *string `json:"error,omitempty"`
}

// PPPoE client configuration for dial-up WAN
type PppoeClient struct {
	// Unique identifier
	ID string `json:"id"`
	// PPPoE interface name
	Name string `json:"name"`
	// Underlying interface (ethernet/bridge)
	Interface string `json:"interface"`
	// Whether PPPoE is disabled
	Disabled bool `json:"disabled"`
	// Username for authentication
	Username string `json:"username"`
	// Service name (optional)
	ServiceName *string `json:"serviceName,omitempty"`
	// Add default route
	AddDefaultRoute bool `json:"addDefaultRoute"`
	// Use peer DNS
	UsePeerDNS bool `json:"usePeerDNS"`
	// Current connection status
	Running bool `json:"running"`
	// MTU setting
	Mtu *int `json:"mtu,omitempty"`
	// MRU setting
	Mru *int `json:"mru,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (PppoeClient) IsNode() {}

// Input for creating/updating PPPoE client
type PppoeClientInput struct {
	// PPPoE interface name
	Name string `json:"name"`
	// Physical interface (ether1, bridge, etc.)
	Interface string `json:"interface"`
	// Username for ISP authentication
	Username string `json:"username"`
	// Password for ISP authentication
	Password string `json:"password"`
	// Service name (optional, ISP-specific)
	ServiceName graphql.Omittable[*string] `json:"serviceName,omitempty"`
	// Add default route (default: true)
	AddDefaultRoute graphql.Omittable[*bool] `json:"addDefaultRoute,omitempty"`
	// Use peer DNS (default: true)
	UsePeerDNS graphql.Omittable[*bool] `json:"usePeerDNS,omitempty"`
	// MTU (default: auto)
	Mtu graphql.Omittable[*int] `json:"mtu,omitempty"`
	// MRU (default: auto)
	Mru graphql.Omittable[*int] `json:"mru,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Input for previewing a notification template
// Simpler input for template customization workflow
type PreviewNotificationTemplateInput struct {
	// Event type for sample data generation
	EventType string `json:"eventType"`
	// Notification channel
	Channel NotificationChannel `json:"channel"`
	// Subject template (optional, not all channels use subjects)
	SubjectTemplate graphql.Omittable[*string] `json:"subjectTemplate,omitempty"`
	// Body template with Go template syntax
	BodyTemplate string `json:"bodyTemplate"`
}

// Pushover API usage statistics
type PushoverUsage struct {
	// Number of messages used this month
	Used int `json:"used"`
	// Number of messages remaining this month
	Remaining int `json:"remaining"`
	// Monthly message limit
	Limit int `json:"limit"`
	// When the usage counter resets
	ResetAt time.Time `json:"resetAt"`
}

type Query struct {
}

// Quiet hours configuration
type QuietHoursConfig struct {
	// Start time in HH:MM format
	StartTime string `json:"startTime"`
	// End time in HH:MM format
	EndTime string `json:"endTime"`
	// Timezone (IANA timezone database name)
	Timezone string `json:"timezone"`
	// Whether critical alerts bypass quiet hours
	BypassCritical bool `json:"bypassCritical"`
	// Days of week when quiet hours apply (0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday). Empty array means all days.
	DaysOfWeek []int `json:"daysOfWeek"`
}

// Quiet hours configuration input
type QuietHoursConfigInput struct {
	// Start time in HH:MM format
	StartTime string `json:"startTime"`
	// End time in HH:MM format
	EndTime string `json:"endTime"`
	// Timezone (default: UTC)
	Timezone graphql.Omittable[*string] `json:"timezone,omitempty"`
	// Whether critical alerts bypass quiet hours (default: true)
	BypassCritical graphql.Omittable[*bool] `json:"bypassCritical,omitempty"`
	// Days of week when quiet hours apply (0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday). Empty array means all days.
	DaysOfWeek graphql.Omittable[[]int] `json:"daysOfWeek,omitempty"`
}

type ReconnectRouterPayload struct {
	// The router being reconnected
	Router *Router `json:"router,omitempty"`
	// Updated connection details
	ConnectionDetails *ConnectionDetails `json:"connectionDetails,omitempty"`
	// Whether reconnection was initiated
	Initiated bool `json:"initiated"`
	// Rate limit wait time if rate limited
	WaitTimeMs *int `json:"waitTimeMs,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Payload for refreshCapabilities mutation
type RefreshCapabilitiesPayload struct {
	// Updated capabilities after refresh
	Capabilities *RouterCapabilities `json:"capabilities,omitempty"`
	// Errors during refresh
	Errors []*MutationError `json:"errors,omitempty"`
}

type RemoveChangeSetItemPayload struct {
	// The updated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Conflict with another resource
type ResourceConflict struct {
	// Type of conflict
	Type ConflictType `json:"type"`
	// The conflicting resource
	ConflictingResource Resource `json:"conflictingResource,omitempty"`
	// Conflicting resource UUID (if resource is not loaded)
	ConflictingResourceUUID string `json:"conflictingResourceUuid"`
	// Description of the conflict
	Description string `json:"description"`
	// Suggested resolution
	Resolution *string `json:"resolution,omitempty"`
}

type ResourceConnection struct {
	Edges      []*ResourceEdge `json:"edges"`
	PageInfo   *PageInfo       `json:"pageInfo"`
	TotalCount *int            `json:"totalCount,omitempty"`
}

func (ResourceConnection) IsConnection() {}

type ResourceEdge struct {
	Cursor string   `json:"cursor"`
	Node   Resource `json:"node"`
}

func (ResourceEdge) IsEdge() {}

// Layer 6: Resource lifecycle info, tags, ownership.
// System-managed with some user-editable fields.
type ResourceMetadata struct {
	// Resource creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// User who created the resource
	CreatedBy string `json:"createdBy"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// User who last updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
	// Current lifecycle state
	State ResourceLifecycleState `json:"state"`
	// Optimistic locking version
	Version int `json:"version"`
	// User-defined tags for organization
	Tags []string `json:"tags"`
	// Resource description
	Description *string `json:"description,omitempty"`
	// Whether resource is marked as favorite
	IsFavorite bool `json:"isFavorite"`
	// Whether resource is pinned
	IsPinned bool `json:"isPinned"`
	// Custom user notes
	Notes *string `json:"notes,omitempty"`
	// Audit trail of recent changes
	RecentChanges []*ChangeLogEntry `json:"recentChanges,omitempty"`
}

// Real-time resource utilization metrics for a device
type ResourceMetrics struct {
	// CPU utilization metrics
	CPU *CPUMetrics `json:"cpu"`
	// Memory utilization metrics
	Memory *MemoryMetrics `json:"memory"`
	// Storage utilization metrics
	Storage *StorageMetrics `json:"storage"`
	// Temperature in Celsius (null if not supported)
	Temperature *float64 `json:"temperature,omitempty"`
	// Timestamp when metrics were collected
	Timestamp time.Time `json:"timestamp"`
}

// Reference to another resource
type ResourceReference struct {
	// Resource UUID
	UUID string `json:"uuid"`
	// Resource scoped ID
	ID string `json:"id"`
	// Resource type
	Type string `json:"type"`
	// Resource category
	Category ResourceCategory `json:"category"`
	// Current lifecycle state
	State ResourceLifecycleState `json:"state"`
}

// Edge in the resource relationship graph
type ResourceRelationshipEdge struct {
	// Source resource ID
	From string `json:"from"`
	// Target resource ID
	To string `json:"to"`
	// Relationship type
	Type ResourceRelationshipType `json:"type"`
}

// Layer 7: Dependencies and relationships between resources.
// Combines user-defined relationships and system-discovered dependencies.
type ResourceRelationships struct {
	// Resources this resource depends on
	DependsOn []*ResourceReference `json:"dependsOn"`
	// Resources that depend on this resource
	Dependents []*ResourceReference `json:"dependents"`
	// Resource this routes traffic via
	RoutesVia *ResourceReference `json:"routesVia,omitempty"`
	// Resources that route traffic via this resource
	RoutedBy []*ResourceReference `json:"routedBy"`
	// Parent resource (for hierarchical resources)
	Parent *ResourceReference `json:"parent,omitempty"`
	// Child resources (for hierarchical resources)
	Children []*ResourceReference `json:"children"`
	// Custom relationships
	Custom map[string]interface{} `json:"custom,omitempty"`
}

// Input for resource relationships
type ResourceRelationshipsInput struct {
	// Resources this resource depends on (IDs)
	DependsOn graphql.Omittable[[]string] `json:"dependsOn,omitempty"`
	// Resources that route traffic via this resource (ID)
	RoutesVia graphql.Omittable[*string] `json:"routesVia,omitempty"`
	// Parent resource ID (for hierarchical resources)
	Parent graphql.Omittable[*string] `json:"parent,omitempty"`
	// Custom relationship data
	Custom graphql.Omittable[map[string]interface{}] `json:"custom,omitempty"`
}

// Runtime update event for a resource
type ResourceRuntimeEvent struct {
	// Resource ID (ULID)
	ID string `json:"id"`
	// Resource type
	Type string `json:"type"`
	// Updated runtime state
	Runtime *RuntimeState `json:"runtime"`
	// Timestamp of update
	Timestamp time.Time `json:"timestamp"`
}

// Lifecycle state change event
type ResourceStateEvent struct {
	// Resource ID (ULID)
	ID string `json:"id"`
	// Resource type
	Type string `json:"type"`
	// Previous state
	PreviousState ResourceLifecycleState `json:"previousState"`
	// New state
	NewState ResourceLifecycleState `json:"newState"`
	// Error message if state is ERROR
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Timestamp of change
	Timestamp time.Time `json:"timestamp"`
}

// Event emitted when a router resource is updated
type ResourceUpdatedEvent struct {
	// Unique resource identifier
	ResourceID string `json:"resourceId"`
	// Type of resource (interface, firewall-rule, dhcp-lease, etc.)
	ResourceType string `json:"resourceType"`
	// Router this resource belongs to
	RouterID string `json:"routerId"`
	// New version number after update
	Version int `json:"version"`
	// Fields that were changed
	ChangedFields []string `json:"changedFields"`
	// Type of change (create, update, delete)
	ChangeType ChangeType `json:"changeType"`
	// Timestamp of the update
	Timestamp time.Time `json:"timestamp"`
}

type RollbackChangeSetPayload struct {
	// The rolled back change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Whether rollback was successful
	Success bool `json:"success"`
	// Items that failed to rollback
	FailedItems []string `json:"failedItems,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Rollback step for recovery
type RollbackStep struct {
	// Item ID being rolled back
	ItemID string `json:"itemId"`
	// Rollback operation
	Operation RollbackOperation `json:"operation"`
	// State to restore
	RestoreState map[string]interface{} `json:"restoreState,omitempty"`
	// Resource UUID on router
	ResourceUUID *string `json:"resourceUuid,omitempty"`
	// Whether rollback succeeded
	Success bool `json:"success"`
	// Error message if failed
	Error *string `json:"error,omitempty"`
	// Order in rollback sequence
	RollbackOrder int `json:"rollbackOrder"`
}

// Route type for static and dynamic routing
type Route struct {
	// Route ID
	ID string `json:"id"`
	// Destination network in CIDR notation
	Destination CIDR `json:"destination"`
	// Gateway address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Interface used for this route
	Interface *string `json:"interface,omitempty"`
	// Route distance/metric (1-255)
	Distance int `json:"distance"`
	// Routing mark for policy routing
	RoutingMark *string `json:"routingMark,omitempty"`
	// Routing table name (main, vpn, etc.)
	RoutingTable *string `json:"routingTable,omitempty"`
	// Route type (static, connected, dynamic, BGP, OSPF)
	Type RouteType `json:"type"`
	// Route scope
	Scope RouteScope `json:"scope"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// Whether the route is active
	Active bool `json:"active"`
	// Whether the route is disabled
	Disabled *bool `json:"disabled,omitempty"`
}

func (Route) IsNode() {}

// Result of a route deletion with impact analysis
type RouteDeleteResult struct {
	// Whether the deletion succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// Impact analysis for this route deletion
	ImpactAnalysis *RouteImpactAnalysis `json:"impactAnalysis"`
}

// Analysis of the impact of deleting a route
type RouteImpactAnalysis struct {
	// Whether this is the default route (0.0.0.0/0)
	IsDefaultRoute bool `json:"isDefaultRoute"`
	// Description of affected traffic
	AffectedTraffic string `json:"affectedTraffic"`
	// Severity of the deletion (CRITICAL for default route, STANDARD for others)
	Severity ConfirmationSeverity `json:"severity"`
	// Human-readable message about the impact
	Message string `json:"message"`
	// List of consequences of deleting this route
	Consequences []string `json:"consequences"`
}

// Input for creating or updating a route
type RouteInput struct {
	// Destination network in CIDR notation
	Destination CIDR `json:"destination"`
	// Gateway address (optional if interface is provided)
	Gateway graphql.Omittable[*IPv4] `json:"gateway,omitempty"`
	// Interface used for this route (optional if gateway is provided)
	Interface graphql.Omittable[*string] `json:"interface,omitempty"`
	// Route distance/metric (1-255, default: 1)
	Distance graphql.Omittable[*int] `json:"distance,omitempty"`
	// Routing mark for policy routing
	RoutingMark graphql.Omittable[*string] `json:"routingMark,omitempty"`
	// Routing table name (default: main)
	RoutingTable graphql.Omittable[*string] `json:"routingTable,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// A candidate route that matches the destination
type RouteLookupCandidate struct {
	// The route object
	Route *Route `json:"route"`
	// Prefix length (24 for /24, 8 for /8)
	PrefixLength int `json:"prefixLength"`
	// Administrative distance
	Distance int `json:"distance"`
	// Whether this route was selected
	Selected bool `json:"selected"`
	// Reason for selection or non-selection
	SelectionReason *string `json:"selectionReason,omitempty"`
}

// Result of a route lookup operation
type RouteLookupResult struct {
	// Destination IP that was looked up
	Destination string `json:"destination"`
	// The selected route (null if no route found)
	MatchedRoute *Route `json:"matchedRoute,omitempty"`
	// Gateway IP for the selected route
	Gateway *string `json:"gateway,omitempty"`
	// Outgoing interface for the selected route
	Interface *string `json:"interface,omitempty"`
	// Administrative distance of selected route
	Distance *int `json:"distance,omitempty"`
	// Route type (STATIC, CONNECTED, DYNAMIC, BGP, OSPF)
	RouteType RouteType `json:"routeType"`
	// Whether this is the default route (0.0.0.0/0)
	IsDefaultRoute bool `json:"isDefaultRoute"`
	// All candidate routes that match destination
	CandidateRoutes []*RouteLookupCandidate `json:"candidateRoutes"`
	// Human-readable explanation of route selection
	Explanation string `json:"explanation"`
	// VPN tunnel info if route goes through VPN
	VpnTunnel *VPNTunnelInfo `json:"vpnTunnel,omitempty"`
}

// Result of a route mutation (create, update)
type RouteMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// The created or updated route (if successful)
	Route *Route `json:"route,omitempty"`
}

// Route resource
type RouteResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Destination network
	DstAddress CIDR `json:"dstAddress"`
	// Gateway address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Outgoing interface
	Interface *string `json:"interface,omitempty"`
	// Route distance/metric
	Distance *int `json:"distance,omitempty"`
	// Whether route is active
	Active bool `json:"active"`
}

func (RouteResource) IsResource() {}

func (RouteResource) IsNode() {}

// A managed router device
type Router struct {
	// Unique router identifier
	ID string `json:"id"`
	// User-friendly display name
	Name string `json:"name"`
	// Router hostname or IP address
	Host string `json:"host"`
	// Connection port
	Port int `json:"port"`
	// Current connection status
	Status ConnectionStatus `json:"status"`
	// Router platform type
	Platform RouterPlatform `json:"platform"`
	// RouterOS version (if connected)
	Version *string `json:"version,omitempty"`
	// Router model
	Model *string `json:"model,omitempty"`
	// System uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Last successful connection time
	LastConnected *time.Time `json:"lastConnected,omitempty"`
	// When the router was added to NasNet
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// Detected router capabilities (requires connection)
	Capabilities *RouterCapabilities `json:"capabilities,omitempty"`
}

func (Router) IsNode() {}

// Event emitted when a new router is added.
type RouterAddedEvent struct {
	// The newly added router
	Router *Router `json:"router"`
	// Protocol used for initial connection
	ProtocolUsed Protocol `json:"protocolUsed"`
	// User who added the router (if authenticated)
	AddedBy *string `json:"addedBy,omitempty"`
	// Timestamp of addition
	Timestamp time.Time `json:"timestamp"`
}

// Complete router capabilities detected from system inspection
type RouterCapabilities struct {
	// Hardware information
	Hardware *HardwareInfo `json:"hardware"`
	// Software information
	Software *SoftwareInfo `json:"software"`
	// Container-specific capabilities
	Container *ContainerInfo `json:"container"`
	// Capability entries with support levels
	Capabilities []*CapabilityEntry `json:"capabilities"`
	// VIF requirements check
	VifRequirements *VIFRequirements `json:"vifRequirements"`
	// Features supported by this router's version and configuration
	SupportedFeatures []*FeatureSupport `json:"supportedFeatures"`
	// Features not supported by this router (with upgrade guidance)
	UnsupportedFeatures []*FeatureSupport `json:"unsupportedFeatures"`
	// Parsed RouterOS version with comparison helpers
	RouterOSVersion *RouterOSVersion `json:"routerOSVersion"`
	// When capabilities were detected
	DetectedAt time.Time `json:"detectedAt"`
	// When cache expires (24h TTL)
	ExpiresAt time.Time `json:"expiresAt"`
	// Whether cache is stale and refresh is in progress
	IsRefreshing bool `json:"isRefreshing"`
}

type RouterConnection struct {
	Edges      []*RouterEdge `json:"edges"`
	PageInfo   *PageInfo     `json:"pageInfo"`
	TotalCount *int          `json:"totalCount,omitempty"`
}

func (RouterConnection) IsConnection() {}

// Router credential information (non-sensitive).
// Password is never included - only metadata about credentials.
type RouterCredentials struct {
	// Router ID these credentials belong to
	RouterID string `json:"routerId"`
	// Username for router authentication
	Username string `json:"username"`
	// Whether a password is stored
	HasPassword bool `json:"hasPassword"`
	// Encryption algorithm used (always 'AES-256-GCM')
	EncryptionStatus string `json:"encryptionStatus"`
	// Encryption key version (for rotation tracking)
	KeyVersion int `json:"keyVersion"`
	// When credentials were last updated
	LastUpdated time.Time `json:"lastUpdated"`
	// When credentials were first created
	CreatedAt time.Time `json:"createdAt"`
}

type RouterEdge struct {
	Node   *Router `json:"node"`
	Cursor string  `json:"cursor"`
}

func (RouterEdge) IsEdge() {}

// Information about a discovered RouterOS device
type RouterOSInfo struct {
	// RouterOS version string (e.g., '7.12', '6.49.8')
	Version *string `json:"version,omitempty"`
	// Router board name (e.g., 'hAP ac', 'CCR2004-1G-12S+2XS')
	BoardName *string `json:"boardName,omitempty"`
	// CPU architecture (e.g., 'arm', 'x86', 'mips')
	Architecture *string `json:"architecture,omitempty"`
	// Platform identifier
	Platform *string `json:"platform,omitempty"`
}

// Parsed RouterOS version with semantic versioning
type RouterOSVersion struct {
	// Full version string (e.g., '7.13.2')
	Raw string `json:"raw"`
	// Major version number
	Major int `json:"major"`
	// Minor version number
	Minor int `json:"minor"`
	// Patch version number
	Patch int `json:"patch"`
	// Version channel (stable, beta, rc, long-term)
	Channel *string `json:"channel,omitempty"`
	// Whether this is a Cloud Hosted Router (CHR)
	IsChr bool `json:"isCHR"`
	// Check if this version supports a specific feature
	SupportsFeature bool `json:"supportsFeature"`
	// Check if version is at least the given version (e.g., '7.1')
	IsAtLeast bool `json:"isAtLeast"`
}

type RouterStatusEvent struct {
	// The router whose status changed
	Router *Router `json:"router"`
	// Previous status
	PreviousStatus ConnectionStatus `json:"previousStatus"`
	// New status
	NewStatus ConnectionStatus `json:"newStatus"`
	// Timestamp of the change
	Timestamp time.Time `json:"timestamp"`
}

// Result of running a diagnostic step
type RunTroubleshootStepPayload struct {
	// Updated step with result
	Step *TroubleshootStep `json:"step"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Resource-specific runtime metrics
type RuntimeMetrics struct {
	// Bytes received
	BytesIn *Size `json:"bytesIn,omitempty"`
	// Bytes transmitted
	BytesOut *Size `json:"bytesOut,omitempty"`
	// Packets received
	PacketsIn *int `json:"packetsIn,omitempty"`
	// Packets transmitted
	PacketsOut *int `json:"packetsOut,omitempty"`
	// Error count
	Errors *int `json:"errors,omitempty"`
	// Drops count
	Drops *int `json:"drops,omitempty"`
	// Current throughput in (bytes/sec)
	ThroughputIn *Size `json:"throughputIn,omitempty"`
	// Current throughput out (bytes/sec)
	ThroughputOut *Size `json:"throughputOut,omitempty"`
	// Resource-specific custom metrics
	Custom map[string]interface{} `json:"custom,omitempty"`
}

// Layer 4: Live operational state polled/streamed from router.
// Updated via polling (5-60s interval) or WebSocket push.
type RuntimeState struct {
	// Whether the resource is currently running/active
	IsRunning bool `json:"isRunning"`
	// Health status of the resource
	Health RuntimeHealth `json:"health"`
	// Error message if resource is unhealthy
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Resource-specific runtime metrics
	Metrics *RuntimeMetrics `json:"metrics,omitempty"`
	// Last time runtime was updated
	LastUpdated time.Time `json:"lastUpdated"`
	// Time since last successful operation
	LastSuccessfulOperation *time.Time `json:"lastSuccessfulOperation,omitempty"`
	// Current peers/connections (for VPN, etc.)
	ActiveConnections *int `json:"activeConnections,omitempty"`
	// Resource uptime
	Uptime *Duration `json:"uptime,omitempty"`
}

// Input for saving custom alert rule template
type SaveAlertRuleTemplateInput struct {
	// Template name
	Name string `json:"name"`
	// Template description
	Description string `json:"description"`
	// Template category
	Category AlertRuleTemplateCategory `json:"category"`
	// Alert severity
	Severity AlertSeverity `json:"severity"`
	// Event type
	EventType string `json:"eventType"`
	// Alert conditions
	Conditions []*AlertConditionInput `json:"conditions"`
	// Throttle configuration
	Throttle graphql.Omittable[*ThrottleConfigInput] `json:"throttle,omitempty"`
	// Notification channels
	Channels []string `json:"channels"`
	// Template variables
	Variables graphql.Omittable[[]*AlertRuleAlertTemplateVariableInput] `json:"variables,omitempty"`
}

// Input for saving a custom alert template
type SaveAlertTemplateInput struct {
	// Template name
	Name string `json:"name"`
	// Template description
	Description string `json:"description"`
	// Event type
	EventType string `json:"eventType"`
	// Notification channel
	Channel NotificationChannel `json:"channel"`
	// Subject template
	SubjectTemplate graphql.Omittable[*string] `json:"subjectTemplate,omitempty"`
	// Body template
	BodyTemplate string `json:"bodyTemplate"`
	// Template variables
	Variables []*AlertAlertTemplateVariableInput `json:"variables"`
	// Tags
	Tags graphql.Omittable[[]string] `json:"tags,omitempty"`
	// Metadata
	Metadata graphql.Omittable[map[string]interface{}] `json:"metadata,omitempty"`
}

// Input for saving a custom template.
type SaveTemplateInput struct {
	// Template name
	Name string `json:"name"`
	// Template description
	Description string `json:"description"`
	// Category
	Category TemplateCategory `json:"category"`
	// Variable definitions
	Variables []*FirewallTemplateVariableInput `json:"variables"`
	// Rule definitions
	Rules []*TemplateRuleInput `json:"rules"`
}

// Input for starting a network scan
type ScanNetworkInput struct {
	// Target subnet in CIDR notation (e.g., '192.168.88.0/24') or IP range (e.g., '192.168.1.1-192.168.1.100')
	Subnet string `json:"subnet"`
}

type ScanNetworkPayload struct {
	// The created scan task
	Task *ScanTask `json:"task,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Real-time progress event for scan subscriptions
type ScanProgressEvent struct {
	// Task ID this event belongs to
	TaskID string `json:"taskId"`
	// Current progress percentage (0-100)
	Progress int `json:"progress"`
	// Number of MikroTik devices found so far
	DevicesFound int `json:"devicesFound"`
	// IP address currently being scanned
	CurrentIP *string `json:"currentIP,omitempty"`
	// Current scan status
	Status ScanStatus `json:"status"`
	// Timestamp of this progress update
	Timestamp time.Time `json:"timestamp"`
}

// A network scan task that tracks scan progress and results.
// Scans are asynchronous - start with mutation, poll/subscribe for progress.
type ScanTask struct {
	// Unique task identifier
	ID string `json:"id"`
	// Target subnet (CIDR notation, IP range, or gateway scan indicator)
	Subnet string `json:"subnet"`
	// Current scan status
	Status ScanStatus `json:"status"`
	// Scan progress percentage (0-100)
	Progress int `json:"progress"`
	// Discovered devices (populated as scan progresses)
	Results []*DiscoveredDevice `json:"results"`
	// When the scan was started
	StartTime time.Time `json:"startTime"`
	// When the scan completed (null if still running)
	EndTime *time.Time `json:"endTime,omitempty"`
	// Error message if scan failed
	Error *string `json:"error,omitempty"`
	// Total IPs to scan (for progress calculation)
	TotalIPs *int `json:"totalIPs,omitempty"`
	// Number of IPs scanned so far
	ScannedIPs *int `json:"scannedIPs,omitempty"`
}

type SetPreferredProtocolPayload struct {
	// The updated router
	Router *Router `json:"router,omitempty"`
	// Updated connection details
	ConnectionDetails *ConnectionDetails `json:"connectionDetails,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Software information detected from router
type SoftwareInfo struct {
	// RouterOS version string
	Version string `json:"version"`
	// Parsed major version number
	VersionMajor int `json:"versionMajor"`
	// Parsed minor version number
	VersionMinor int `json:"versionMinor"`
	// Parsed patch version number
	VersionPatch *int `json:"versionPatch,omitempty"`
	// List of installed packages
	InstalledPackages []string `json:"installedPackages"`
	// License level (0-6)
	LicenseLevel int `json:"licenseLevel"`
	// Update channel (stable, testing, development)
	UpdateChannel *string `json:"updateChannel,omitempty"`
}

// Result of starting a troubleshooting session
type StartTroubleshootPayload struct {
	// The created session
	Session *TroubleshootSession `json:"session,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Static IP WAN configuration
type StaticIPConfig struct {
	// Unique identifier
	ID string `json:"id"`
	// Interface name
	Interface string `json:"interface"`
	// Static IP address with CIDR
	Address CIDR `json:"address"`
	// Gateway IP address
	Gateway IPv4 `json:"gateway"`
	// Primary DNS server
	PrimaryDNS *IPv4 `json:"primaryDNS,omitempty"`
	// Secondary DNS server
	SecondaryDNS *IPv4 `json:"secondaryDNS,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (StaticIPConfig) IsNode() {}

// Input for configuring static IP WAN
type StaticIPInput struct {
	// Interface to configure
	Interface string `json:"interface"`
	// Static IP address with CIDR (e.g., 203.0.113.5/30)
	Address CIDR `json:"address"`
	// Gateway IP address
	Gateway IPv4 `json:"gateway"`
	// Primary DNS server
	PrimaryDNS graphql.Omittable[*IPv4] `json:"primaryDNS,omitempty"`
	// Secondary DNS server
	SecondaryDNS graphql.Omittable[*IPv4] `json:"secondaryDNS,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// A single data point in interface statistics history
type StatsDataPoint struct {
	// Timestamp of the data point
	Timestamp time.Time `json:"timestamp"`
	// Transmit rate in bytes per second
	TxBytesPerSec float64 `json:"txBytesPerSec"`
	// Receive rate in bytes per second
	RxBytesPerSec float64 `json:"rxBytesPerSec"`
	// Transmit rate in packets per second
	TxPacketsPerSec float64 `json:"txPacketsPerSec"`
	// Receive rate in packets per second
	RxPacketsPerSec float64 `json:"rxPacketsPerSec"`
	// Transmission errors in this interval
	TxErrors int `json:"txErrors"`
	// Receive errors in this interval
	RxErrors int `json:"rxErrors"`
}

// Input for specifying a time range
type StatsTimeRangeInput struct {
	// Start of the time range
	Start time.Time `json:"start"`
	// End of the time range
	End time.Time `json:"end"`
}

// Storage utilization metrics
type StorageMetrics struct {
	// Used storage in bytes
	Used float64 `json:"used"`
	// Total storage in bytes
	Total float64 `json:"total"`
	// Storage usage percentage (0-100)
	Percentage float64 `json:"percentage"`
}

// Alert rule contribution to storm detection
type StormRuleContribution struct {
	// Alert rule ID
	RuleID string `json:"ruleId"`
	// Alert rule name
	RuleName string `json:"ruleName"`
	// Number of alerts from this rule in current window
	AlertCount int `json:"alertCount"`
	// Percentage of total alerts
	Percentage float64 `json:"percentage"`
}

// Storm detection status
// Shows if alert storm is detected and current metrics
type StormStatus struct {
	// Whether storm is currently detected
	IsStormDetected bool `json:"isStormDetected"`
	// Number of alerts in current window
	AlertCount int `json:"alertCount"`
	// Storm detection threshold
	Threshold int `json:"threshold"`
	// Window duration in seconds
	WindowSeconds int `json:"windowSeconds"`
	// When storm detection started
	StormStartedAt *time.Time `json:"stormStartedAt,omitempty"`
	// When current window started
	WindowStart time.Time `json:"windowStart"`
	// When current window ends
	WindowEnd time.Time `json:"windowEnd"`
	// Top alert rules contributing to the storm
	TopRules []*StormRuleContribution `json:"topRules"`
}

type Subscription struct {
}

// TLS certificate status for secure connections
type TLSStatus struct {
	// Whether the certificate is valid
	Valid bool `json:"valid"`
	// Certificate issuer
	Issuer *string `json:"issuer,omitempty"`
	// Certificate subject
	Subject *string `json:"subject,omitempty"`
	// Certificate expiration date
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// Error message (if certificate is invalid)
	Error *string `json:"error,omitempty"`
}

// Layer 5: Time-series metrics and historical data.
// Collected over time for analytics and trending.
type TelemetryData struct {
	// Bandwidth history (last 24h)
	BandwidthHistory []*BandwidthDataPoint `json:"bandwidthHistory,omitempty"`
	// Uptime history (availability)
	UptimeHistory []*UptimeDataPoint `json:"uptimeHistory,omitempty"`
	// Hourly statistics
	HourlyStats []*HourlyStats `json:"hourlyStats,omitempty"`
	// Daily statistics
	DailyStats []*DailyStats `json:"dailyStats,omitempty"`
	// First data point timestamp
	DataStartedAt *time.Time `json:"dataStartedAt,omitempty"`
	// Last data point timestamp
	LastUpdatedAt *time.Time `json:"lastUpdatedAt,omitempty"`
	// Data retention period
	RetentionDays int `json:"retentionDays"`
}

// Detected conflict between template and existing configuration.
type TemplateConflict struct {
	// Type of conflict
	Type TemplateConflictType `json:"type"`
	// Human-readable conflict description
	Message string `json:"message"`
	// Existing rule ID that conflicts (if applicable)
	ExistingRuleID *string `json:"existingRuleId,omitempty"`
	// Proposed template rule that conflicts
	ProposedRule *TemplateRule `json:"proposedRule"`
}

// Template preview result
type TemplatePreview struct {
	// The template that was previewed
	Template *AlertTemplate `json:"template"`
	// Rendered subject after variable substitution
	RenderedSubject string `json:"renderedSubject"`
	// Rendered body after variable substitution
	RenderedBody string `json:"renderedBody"`
	// Variables used in preview
	Variables map[string]interface{} `json:"variables"`
	// Validation information
	ValidationInfo *TemplateValidationInfo `json:"validationInfo"`
}

// Template preview payload
type TemplatePreviewPayload struct {
	// Preview result
	Preview *TemplatePreview `json:"preview,omitempty"`
	// Errors encountered during preview
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of template preview operation.
// Shows what will happen when template is applied.
type TemplatePreviewResult struct {
	// The template being previewed
	Template *FirewallTemplate `json:"template"`
	// Rules with variables resolved
	ResolvedRules []*TemplateRule `json:"resolvedRules"`
	// Detected conflicts with existing rules
	Conflicts []*TemplateConflict `json:"conflicts"`
	// Impact analysis
	ImpactAnalysis *ImpactAnalysis `json:"impactAnalysis"`
}

// Template rule definition.
// Represents a firewall rule that will be created when template is applied.
type TemplateRule struct {
	// Firewall table (filter, nat, mangle, raw)
	Table FirewallTable `json:"table"`
	// Chain name
	Chain string `json:"chain"`
	// Action to perform
	Action string `json:"action"`
	// Optional comment (can include template metadata)
	Comment *string `json:"comment,omitempty"`
	// Position in the chain (null = append to end)
	Position *int `json:"position,omitempty"`
	// Rule properties as JSON (can include variable references like {{LAN_INTERFACE}})
	Properties map[string]interface{} `json:"properties"`
}

// Input for defining a template rule.
type TemplateRuleInput struct {
	// Firewall table
	Table FirewallTable `json:"table"`
	// Chain name
	Chain string `json:"chain"`
	// Action
	Action string `json:"action"`
	// Comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
	// Position
	Position graphql.Omittable[*int] `json:"position,omitempty"`
	// Rule properties as JSON
	Properties map[string]interface{} `json:"properties"`
}

// Template validation information
type TemplateValidationInfo struct {
	// Whether the template is valid with provided variables
	IsValid bool `json:"isValid"`
	// Missing required variables
	MissingVariables []string `json:"missingVariables"`
	// Validation warnings
	Warnings []string `json:"warnings"`
}

// Result of testing all router credentials.
type TestAllCredentialsPayload struct {
	// Total number of routers tested
	TotalRouters int `json:"totalRouters"`
	// Number of successful credential tests
	SuccessCount int `json:"successCount"`
	// Number of failed credential tests
	FailureCount int `json:"failureCount"`
	// Per-router test results
	Results []*CredentialTestResult `json:"results"`
}

type TestConnectionPayload struct {
	// Whether the connection test succeeded
	Success bool `json:"success"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Router version if connection succeeded
	Version *string `json:"version,omitempty"`
	// Error message if connection failed
	Error *string `json:"error,omitempty"`
}

// Test notification payload
type TestNotificationPayload struct {
	// Whether test was successful
	Success bool `json:"success"`
	// Test result message
	Message *string `json:"message,omitempty"`
	// Errors encountered during test
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of test port knock operation.
type TestPortKnockResult struct {
	// Whether test rules were created successfully
	Success bool `json:"success"`
	// Test instructions for user
	TestInstructions string `json:"testInstructions"`
	// Message
	Message string `json:"message"`
	// Test rule IDs (will auto-expire)
	TestRuleIds []string `json:"testRuleIds"`
}

// Throttle configuration to prevent alert spam
type ThrottleConfig struct {
	// Maximum number of alerts allowed
	MaxAlerts int `json:"maxAlerts"`
	// Time period in seconds
	PeriodSeconds int `json:"periodSeconds"`
	// Optional field to group alerts by
	GroupByField *string `json:"groupByField,omitempty"`
}

// Throttle configuration input
type ThrottleConfigInput struct {
	// Maximum number of alerts allowed
	MaxAlerts int `json:"maxAlerts"`
	// Time period in seconds
	PeriodSeconds int `json:"periodSeconds"`
	// Optional field to group alerts by
	GroupByField graphql.Omittable[*string] `json:"groupByField,omitempty"`
}

// Throttle status for a specific group (when groupByField is used)
type ThrottleGroupStatus struct {
	// Group identifier (value of groupByField)
	GroupKey string `json:"groupKey"`
	// Whether this group is currently throttled
	IsThrottled bool `json:"isThrottled"`
	// Number of alerts suppressed for this group
	SuppressedCount int `json:"suppressedCount"`
	// When the throttle window for this group started
	WindowStart time.Time `json:"windowStart"`
	// When the throttle window for this group ends
	WindowEnd time.Time `json:"windowEnd"`
}

// Throttle status for an alert rule
// Shows current throttling state and suppressed alert counts
type ThrottleStatus struct {
	// Alert rule ID
	RuleID string `json:"ruleId"`
	// Whether the rule is currently throttled
	IsThrottled bool `json:"isThrottled"`
	// Number of alerts suppressed in current throttle window
	SuppressedCount int `json:"suppressedCount"`
	// When the current throttle window started
	WindowStart *time.Time `json:"windowStart,omitempty"`
	// When the current throttle window ends
	WindowEnd *time.Time `json:"windowEnd,omitempty"`
	// Throttle groups (if groupByField is configured)
	Groups []*ThrottleGroupStatus `json:"groups"`
}

// Edge connecting nodes in a topology
type TopologyEdge struct {
	// Edge ID
	ID string `json:"id"`
	// Source node ID
	Source string `json:"source"`
	// Target node ID
	Target string `json:"target"`
	// Edge label (optional)
	Label *string `json:"label,omitempty"`
	// Additional edge data
	Data map[string]interface{} `json:"data,omitempty"`
	// Edge styling
	Style *TopologyEdgeStyle `json:"style,omitempty"`
}

// Styling for topology edges
type TopologyEdgeStyle struct {
	// Stroke color (CSS color)
	Stroke *string `json:"stroke,omitempty"`
	// Stroke width in pixels
	StrokeWidth *float64 `json:"strokeWidth,omitempty"`
	// Stroke dash array (for dashed lines)
	StrokeDasharray *string `json:"strokeDasharray,omitempty"`
}

// Node in a VLAN network topology diagram
type TopologyNode struct {
	// Node ID
	ID string `json:"id"`
	// Node type (bridge, vlan, port)
	Type TopologyNodeType `json:"type"`
	// Display label
	Label string `json:"label"`
	// Sub-label (optional)
	Sublabel *string `json:"sublabel,omitempty"`
	// Node position in the diagram
	Position *TopologyPosition `json:"position"`
	// Additional node data
	Data map[string]interface{} `json:"data,omitempty"`
	// Node styling
	Style *TopologyNodeStyle `json:"style,omitempty"`
}

// Styling for topology nodes
type TopologyNodeStyle struct {
	// Fill color (CSS color)
	Fill *string `json:"fill,omitempty"`
	// Stroke color (CSS color)
	Stroke *string `json:"stroke,omitempty"`
	// Stroke width in pixels
	StrokeWidth *float64 `json:"strokeWidth,omitempty"`
}

// Position of a node in the topology
type TopologyPosition struct {
	// X coordinate
	X float64 `json:"x"`
	// Y coordinate
	Y float64 `json:"y"`
}

// A single hop in the traceroute path
type TracerouteHop struct {
	// Hop number (1-based)
	HopNumber int `json:"hopNumber"`
	// IP address of the hop (null for timeout)
	Address *string `json:"address,omitempty"`
	// Reverse DNS hostname (if available)
	Hostname *string `json:"hostname,omitempty"`
	// Individual probe results for this hop
	Probes []*HopProbe `json:"probes"`
	// Status of this hop
	Status HopStatus `json:"status"`
	// Average latency across successful probes
	AvgLatencyMs *float64 `json:"avgLatencyMs,omitempty"`
	// Packet loss percentage for this hop (0-100)
	PacketLoss float64 `json:"packetLoss"`
}

// Input parameters for starting a traceroute
type TracerouteInput struct {
	// Target hostname or IP address
	Target string `json:"target"`
	// Maximum number of hops (default: 30, max: 64)
	MaxHops graphql.Omittable[*int] `json:"maxHops,omitempty"`
	// Timeout per hop in milliseconds (default: 3000)
	Timeout graphql.Omittable[*int] `json:"timeout,omitempty"`
	// Number of probes per hop (default: 3)
	ProbeCount graphql.Omittable[*int] `json:"probeCount,omitempty"`
	// Protocol to use for probes (default: ICMP)
	Protocol graphql.Omittable[*TracerouteProtocol] `json:"protocol,omitempty"`
}

// Traceroute job reference for subscription tracking
type TracerouteJob struct {
	// Unique job identifier
	JobID string `json:"jobId"`
	// Current job status
	Status JobStatus `json:"status"`
}

// Progress event emitted during traceroute execution
type TracerouteProgressEvent struct {
	// Job identifier
	JobID string `json:"jobId"`
	// Type of event
	EventType TracerouteEventType `json:"eventType"`
	// Newly discovered hop (for HOP_DISCOVERED events)
	Hop *TracerouteHop `json:"hop,omitempty"`
	// Final result (for COMPLETE events)
	Result *TracerouteResult `json:"result,omitempty"`
	// Error message (for ERROR events)
	Error *string `json:"error,omitempty"`
}

// Complete traceroute result
type TracerouteResult struct {
	// Target hostname or IP address
	Target string `json:"target"`
	// Resolved target IP address
	TargetIP string `json:"targetIp"`
	// Protocol used for probes
	Protocol TracerouteProtocol `json:"protocol"`
	// Maximum hops configured
	MaxHops int `json:"maxHops"`
	// Discovered hops in order
	Hops []*TracerouteHop `json:"hops"`
	// Whether traceroute completed
	Completed bool `json:"completed"`
	// Whether destination was reached
	ReachedDestination bool `json:"reachedDestination"`
	// Total time from start to completion (ms)
	TotalTimeMs float64 `json:"totalTimeMs"`
	// When the traceroute started
	StartedAt time.Time `json:"startedAt"`
	// When the traceroute completed (if finished)
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

// Suggested fix for a failed diagnostic step
type TroubleshootFixSuggestion struct {
	// Unique issue code (e.g., WAN_DISABLED, NO_DEFAULT_ROUTE)
	IssueCode string `json:"issueCode"`
	// User-friendly fix title
	Title string `json:"title"`
	// Detailed explanation of what will be fixed
	Explanation string `json:"explanation"`
	// Confidence level for this fix
	Confidence FixConfidence `json:"confidence"`
	// Whether user confirmation is required before applying
	RequiresConfirmation bool `json:"requiresConfirmation"`
	// Whether this is a manual fix (requires user action)
	IsManualFix bool `json:"isManualFix"`
	// Manual steps if this cannot be automated
	ManualSteps []string `json:"manualSteps,omitempty"`
	// RouterOS command that will be executed
	Command *string `json:"command,omitempty"`
	// Rollback command if fix needs to be reverted
	RollbackCommand *string `json:"rollbackCommand,omitempty"`
}

// Complete troubleshooting session
type TroubleshootSession struct {
	// Unique session identifier
	ID string `json:"id"`
	// Router being diagnosed
	RouterID string `json:"routerId"`
	// All diagnostic steps
	Steps []*TroubleshootStep `json:"steps"`
	// Current step index (0-based)
	CurrentStepIndex int `json:"currentStepIndex"`
	// Overall session status
	Status TroubleshootSessionStatus `json:"status"`
	// Detected WAN interface name
	WanInterface *string `json:"wanInterface,omitempty"`
	// Detected default gateway IP
	Gateway *string `json:"gateway,omitempty"`
	// Detected ISP information
	IspInfo *ISPInfo `json:"ispInfo,omitempty"`
	// Fixes that have been applied
	AppliedFixes []string `json:"appliedFixes"`
	// When the session started
	StartedAt time.Time `json:"startedAt"`
	// When the session completed
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

// A single step in the troubleshooting wizard
type TroubleshootStep struct {
	// Step type/ID
	ID TroubleshootStepType `json:"id"`
	// Step display name
	Name string `json:"name"`
	// Step description
	Description string `json:"description"`
	// Current status of this step
	Status TroubleshootStepStatus `json:"status"`
	// Result of executing this step
	Result *TroubleshootStepResult `json:"result,omitempty"`
	// Suggested fix if step failed
	Fix *TroubleshootFixSuggestion `json:"fix,omitempty"`
	// When the step started
	StartedAt *time.Time `json:"startedAt,omitempty"`
	// When the step completed
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

// Result of a single diagnostic step
type TroubleshootStepResult struct {
	// Whether the check passed
	Success bool `json:"success"`
	// User-friendly message about the result
	Message string `json:"message"`
	// Technical details for debugging
	Details *string `json:"details,omitempty"`
	// Execution time in milliseconds
	ExecutionTimeMs int `json:"executionTimeMs"`
	// Detected error code
	IssueCode *string `json:"issueCode,omitempty"`
	// Target that was checked (IP, interface name, etc.)
	Target *string `json:"target,omitempty"`
}

// A network tunnel interface for connecting remote networks
type Tunnel struct {
	// Unique tunnel identifier
	ID string `json:"id"`
	// Tunnel interface name
	Name string `json:"name"`
	// Tunnel protocol type
	Type TunnelType `json:"type"`
	// Local endpoint IP address
	LocalAddress string `json:"localAddress"`
	// Remote endpoint IP address
	RemoteAddress string `json:"remoteAddress"`
	// Operational status of the tunnel
	Status InterfaceStatus `json:"status"`
	// MTU setting for the tunnel interface
	Mtu *int `json:"mtu,omitempty"`
	// IPsec profile name (GRE tunnels only)
	IpsecProfile *string `json:"ipsecProfile,omitempty"`
	// Tunnel ID (EoIP tunnels only, must be unique per remote address pair)
	TunnelID *int `json:"tunnelId,omitempty"`
	// VXLAN Network Identifier (VXLAN tunnels only)
	Vni *int `json:"vni,omitempty"`
	// VXLAN port (default 4789)
	Port *int `json:"port,omitempty"`
	// VTEP peer addresses (VXLAN tunnels only)
	VtepPeers []string `json:"vtepPeers,omitempty"`
	// Traffic statistics for this tunnel
	Statistics *InterfaceStats `json:"statistics,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// Whether the tunnel is disabled
	Disabled *bool `json:"disabled,omitempty"`
}

func (Tunnel) IsNode() {}

// Input for creating or updating a tunnel
type TunnelInput struct {
	// Tunnel interface name (alphanumeric, hyphens, underscores)
	Name string `json:"name"`
	// Tunnel protocol type
	Type TunnelType `json:"type"`
	// Local endpoint IP address
	LocalAddress string `json:"localAddress"`
	// Remote endpoint IP address
	RemoteAddress string `json:"remoteAddress"`
	// MTU setting (optional, default calculated based on tunnel type)
	Mtu graphql.Omittable[*int] `json:"mtu,omitempty"`
	// IPsec profile name (GRE tunnels only)
	IpsecProfile graphql.Omittable[*string] `json:"ipsecProfile,omitempty"`
	// Tunnel ID (EoIP tunnels only, 0-65535)
	TunnelID graphql.Omittable[*int] `json:"tunnelId,omitempty"`
	// VXLAN Network Identifier (VXLAN tunnels only, 1-16777215)
	Vni graphql.Omittable[*int] `json:"vni,omitempty"`
	// VXLAN port (default 4789)
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// VTEP peer addresses (VXLAN tunnels only)
	VtepPeers graphql.Omittable[[]string] `json:"vtepPeers,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Result of a tunnel mutation (create, update)
type TunnelMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The created or updated tunnel (if successful)
	Tunnel *Tunnel `json:"tunnel,omitempty"`
	// Configuration preview (RouterOS commands)
	Preview *string `json:"preview,omitempty"`
	// MTU guidance for the tunnel type
	MtuGuidance *MtuGuidance `json:"mtuGuidance,omitempty"`
	// Errors that occurred during the operation
	Errors []string `json:"errors"`
}

// Result of a tunnel connectivity test
type TunnelTestResult struct {
	// Whether the remote endpoint is reachable
	Reachable bool `json:"reachable"`
	// Average ping latency in milliseconds (null if unreachable)
	Latency *float64 `json:"latency,omitempty"`
	// Throughput in Mbps (null if iperf not available)
	Throughput *float64 `json:"throughput,omitempty"`
	// Path MTU discovered (null if not tested)
	MtuPath *int `json:"mtuPath,omitempty"`
	// Suggestions for common connectivity issues
	Suggestions []string `json:"suggestions"`
}

// Input for updating an alert rule
type UpdateAlertRuleInput struct {
	// Human-readable alert rule name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Event type to match
	EventType graphql.Omittable[*string] `json:"eventType,omitempty"`
	// Array of conditions
	Conditions graphql.Omittable[[]*AlertConditionInput] `json:"conditions,omitempty"`
	// Alert severity level
	Severity graphql.Omittable[*AlertSeverity] `json:"severity,omitempty"`
	// Notification channels
	Channels graphql.Omittable[[]string] `json:"channels,omitempty"`
	// Throttle configuration
	Throttle graphql.Omittable[*ThrottleConfigInput] `json:"throttle,omitempty"`
	// Quiet hours configuration
	QuietHours graphql.Omittable[*QuietHoursConfigInput] `json:"quietHours,omitempty"`
	// Escalation configuration (NAS-18.9)
	Escalation graphql.Omittable[*EscalationConfigInput] `json:"escalation,omitempty"`
	// Optional device ID filter
	DeviceID graphql.Omittable[*string] `json:"deviceId,omitempty"`
	// Whether rule is enabled
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

type UpdateBridgeInput struct {
	Comment       graphql.Omittable[*string]      `json:"comment,omitempty"`
	Protocol      graphql.Omittable[*StpProtocol] `json:"protocol,omitempty"`
	Priority      graphql.Omittable[*int]         `json:"priority,omitempty"`
	VlanFiltering graphql.Omittable[*bool]        `json:"vlanFiltering,omitempty"`
	Pvid          graphql.Omittable[*int]         `json:"pvid,omitempty"`
	Mtu           graphql.Omittable[*int]         `json:"mtu,omitempty"`
	Disabled      graphql.Omittable[*bool]        `json:"disabled,omitempty"`
}

type UpdateBridgePortInput struct {
	Pvid             graphql.Omittable[*int]        `json:"pvid,omitempty"`
	FrameTypes       graphql.Omittable[*FrameTypes] `json:"frameTypes,omitempty"`
	IngressFiltering graphql.Omittable[*bool]       `json:"ingressFiltering,omitempty"`
	TaggedVlans      graphql.Omittable[[]int]       `json:"taggedVlans,omitempty"`
	UntaggedVlans    graphql.Omittable[[]int]       `json:"untaggedVlans,omitempty"`
	Edge             graphql.Omittable[*bool]       `json:"edge,omitempty"`
	PathCost         graphql.Omittable[*int]        `json:"pathCost,omitempty"`
}

// Input for updating an item in a change set
type UpdateChangeSetItemInput struct {
	// Updated name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Updated description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Updated configuration
	Configuration graphql.Omittable[map[string]interface{}] `json:"configuration,omitempty"`
	// Updated dependencies
	Dependencies graphql.Omittable[[]string] `json:"dependencies,omitempty"`
}

type UpdateChangeSetItemPayload struct {
	// The updated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating interface settings
type UpdateInterfaceInput struct {
	// Enable or disable the interface
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
	// MTU size (68-9000 bytes)
	Mtu graphql.Omittable[*int] `json:"mtu,omitempty"`
	// Interface comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Payload returned by updateInterface, enableInterface, and disableInterface mutations
type UpdateInterfacePayload struct {
	// Updated interface
	Interface *Interface `json:"interface,omitempty"`
	// Errors that occurred during the operation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating an existing notification channel configuration
type UpdateNotificationChannelConfigInput struct {
	// New name (optional)
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// New description (optional)
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Enable/disable configuration (optional)
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
	// Set as default (optional)
	IsDefault graphql.Omittable[*bool] `json:"isDefault,omitempty"`
	// New configuration (optional, replaces entire config if provided)
	Config graphql.Omittable[map[string]interface{}] `json:"config,omitempty"`
}

// Input for updating an existing port mirror configuration
type UpdatePortMirrorInput struct {
	// Updated name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Updated source interface IDs (must be bridge members)
	SourceInterfaceIds graphql.Omittable[[]string] `json:"sourceInterfaceIds,omitempty"`
	// Updated destination interface ID
	DestinationInterfaceID graphql.Omittable[*string] `json:"destinationInterfaceId,omitempty"`
	// Updated direction of traffic to mirror
	Direction graphql.Omittable[*MirrorDirection] `json:"direction,omitempty"`
	// Updated comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Input for updating resource configuration
type UpdateResourceInput struct {
	// Updated configuration (partial or full)
	Configuration graphql.Omittable[map[string]interface{}] `json:"configuration,omitempty"`
	// Updated relationships
	Relationships graphql.Omittable[*ResourceRelationshipsInput] `json:"relationships,omitempty"`
	// Updated tags
	Tags graphql.Omittable[[]string] `json:"tags,omitempty"`
	// Updated description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

type UpdateResourcePayload struct {
	// The updated resource
	Resource Resource `json:"resource,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating router settings
type UpdateRouterInput struct {
	// Updated display name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Updated hostname or IP address
	Host graphql.Omittable[*string] `json:"host,omitempty"`
	// Updated connection port
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Updated username
	Username graphql.Omittable[*string] `json:"username,omitempty"`
	// Updated password
	Password graphql.Omittable[*string] `json:"password,omitempty"`
}

type UpdateRouterPayload struct {
	// The updated router
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during update
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating a webhook
type UpdateWebhookInput struct {
	// Human-readable webhook name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Webhook URL endpoint
	URL graphql.Omittable[*string] `json:"url,omitempty"`
	// HTTP method
	Method graphql.Omittable[*string] `json:"method,omitempty"`
	// Authentication type
	AuthType graphql.Omittable[*WebhookAuthType] `json:"authType,omitempty"`
	// Username for Basic auth
	Username graphql.Omittable[*string] `json:"username,omitempty"`
	// Password for Basic auth (only set if provided)
	Password graphql.Omittable[*string] `json:"password,omitempty"`
	// Bearer token for Bearer auth (only set if provided)
	BearerToken graphql.Omittable[*string] `json:"bearerToken,omitempty"`
	// Custom HTTP headers (as JSON object)
	Headers graphql.Omittable[map[string]interface{}] `json:"headers,omitempty"`
	// Template type for webhook payload
	Template graphql.Omittable[*WebhookTemplate] `json:"template,omitempty"`
	// Custom template body
	CustomTemplate graphql.Omittable[*string] `json:"customTemplate,omitempty"`
	// Signing secret for HMAC signature (only set if provided)
	SigningSecret graphql.Omittable[*string] `json:"signingSecret,omitempty"`
	// Timeout in seconds
	TimeoutSeconds graphql.Omittable[*int] `json:"timeoutSeconds,omitempty"`
	// Whether to retry failed deliveries
	RetryEnabled graphql.Omittable[*bool] `json:"retryEnabled,omitempty"`
	// Maximum retry attempts
	MaxRetries graphql.Omittable[*int] `json:"maxRetries,omitempty"`
	// Whether webhook is enabled
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

// Impact assessment for an upgrade
type UpgradeImpact struct {
	// Whether reboot is required
	RequiresReboot bool `json:"requiresReboot"`
	// Estimated downtime description
	EstimatedDowntime *string `json:"estimatedDowntime,omitempty"`
	// Whether configuration backup is recommended before upgrade
	BackupRecommended bool `json:"backupRecommended"`
	// Potential breaking changes to be aware of
	BreakingChanges []string `json:"breakingChanges"`
}

// Upgrade recommendation for enabling a feature
type UpgradeRecommendation struct {
	// Feature that requires upgrade
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	FeatureName string `json:"featureName"`
	// Current RouterOS version
	CurrentVersion string `json:"currentVersion"`
	// Minimum required version for this feature
	RequiredVersion string `json:"requiredVersion"`
	// Whether this is a major version upgrade (e.g., 6.x to 7.x)
	IsMajorUpgrade bool `json:"isMajorUpgrade"`
	// Priority level (critical, high, medium, low)
	Priority UpgradePriority `json:"priority"`
	// Steps to complete the upgrade
	Steps []*UpgradeStep `json:"steps"`
	// Estimated impact on router operation
	Impact *UpgradeImpact `json:"impact"`
	// URL to MikroTik upgrade documentation
	DocumentationURL *string `json:"documentationUrl,omitempty"`
	// Warnings or important notes about this upgrade
	Warnings []string `json:"warnings"`
}

// Single step in an upgrade process
type UpgradeStep struct {
	// Step number (1-based)
	Step int `json:"step"`
	// Step title
	Title string `json:"title"`
	// Detailed instructions
	Description string `json:"description"`
	// RouterOS command to execute (if applicable)
	Command *string `json:"command,omitempty"`
	// Whether this step is optional
	Optional bool `json:"optional"`
}

// An uptime data point
type UptimeDataPoint struct {
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
	// Whether resource was up during this period
	IsUp bool `json:"isUp"`
	// Period duration in seconds
	PeriodSeconds int `json:"periodSeconds"`
}

// Single step in VIF enablement guidance
type VIFGuidanceStep struct {
	// Step number (1-based)
	Step int `json:"step"`
	// Short title for the step
	Title string `json:"title"`
	// Detailed instruction
	Description string `json:"description"`
	// Whether this requirement is already met
	Completed bool `json:"completed"`
	// RouterOS command to execute (if applicable)
	RouterCommand *string `json:"routerCommand,omitempty"`
}

// VIF (Virtual Interface Factory) requirements check result
type VIFRequirements struct {
	// Whether all VIF requirements are satisfied
	Met bool `json:"met"`
	// Whether RouterOS version is sufficient (7.13+)
	RouterOSVersion bool `json:"routerOSVersion"`
	// Whether container package is installed
	ContainerPackage bool `json:"containerPackage"`
	// Whether container feature is enabled
	ContainerEnabled bool `json:"containerEnabled"`
	// Whether there's sufficient storage (>100MB)
	SufficientStorage bool `json:"sufficientStorage"`
	// Whether network namespace is supported
	NetworkNamespace bool `json:"networkNamespace"`
	// Human-readable reasons why VIF is not available
	MissingReasons []string `json:"missingReasons"`
	// Step-by-step guidance for enabling VIF
	GuidanceSteps []*VIFGuidanceStep `json:"guidanceSteps"`
}

// VPN tunnel information for routes through VPN
type VPNTunnelInfo struct {
	// Tunnel name
	Name string `json:"name"`
	// Tunnel type (wireguard, ipsec, ovpn, l2tp, gre, eoip)
	Type string `json:"type"`
	// Current tunnel connection status
	Status TunnelStatus `json:"status"`
	// Remote endpoint address
	RemoteAddress *string `json:"remoteAddress,omitempty"`
}

type ValidateChangeSetPayload struct {
	// The validated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Validation result
	Validation *ChangeSetValidationResult `json:"validation,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

type ValidateResourcePayload struct {
	// The validated resource
	Resource Resource `json:"resource,omitempty"`
	// Validation result
	Validation *ValidationResult `json:"validation,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Field-level validation error with suggestions for fixing.
type ValidationError struct {
	// Field path that failed validation (e.g., 'input.host', 'input.port')
	Field string `json:"field"`
	// Error code for the validation failure
	Code string `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Suggestion for fixing the validation error
	Suggestion *string `json:"suggestion,omitempty"`
	// The invalid value (redacted for sensitive fields)
	ProvidedValue *string `json:"providedValue,omitempty"`
}

// A validation issue (error or warning)
type ValidationIssue struct {
	// Error code for programmatic handling
	Code string `json:"code"`
	// Human-readable message
	Message string `json:"message"`
	// Field path that caused the issue (e.g., 'configuration.listenPort')
	Field *string `json:"field,omitempty"`
	// Severity level
	Severity ValidationSeverity `json:"severity"`
	// Suggested fix
	SuggestedFix *string `json:"suggestedFix,omitempty"`
	// Link to documentation
	DocsURL *string `json:"docsUrl,omitempty"`
}

// Layer 2: Validation result from 7-stage backend validation pipeline.
// Computed on every configuration change.
type ValidationResult struct {
	// Whether the resource can be applied
	CanApply bool `json:"canApply"`
	// Current validation stage
	Stage ValidationStage `json:"stage"`
	// Validation errors (blocking)
	Errors []*ValidationIssue `json:"errors"`
	// Validation warnings (non-blocking)
	Warnings []*ValidationIssue `json:"warnings"`
	// Resource conflicts detected
	Conflicts []*ResourceConflict `json:"conflicts"`
	// Required dependencies that must be active
	RequiredDependencies []*DependencyStatus `json:"requiredDependencies"`
	// When validation was performed
	ValidatedAt time.Time `json:"validatedAt"`
	// Duration of validation in milliseconds
	ValidationDurationMs int `json:"validationDurationMs"`
}

// A VLAN (Virtual LAN) interface for network segmentation using 802.1Q tagging
type Vlan struct {
	// Unique VLAN identifier
	ID string `json:"id"`
	// VLAN interface name (e.g., vlan10, vlan-guest)
	Name string `json:"name"`
	// 802.1Q VLAN ID (1-4094)
	VlanID int `json:"vlanId"`
	// Parent interface (bridge or physical interface)
	Interface *Interface `json:"interface"`
	// MTU setting (optional, inherits from parent if not set)
	Mtu *int `json:"mtu,omitempty"`
	// MAC address of the VLAN interface
	MacAddress *MAC `json:"macAddress,omitempty"`
	// Whether the VLAN interface is disabled
	Disabled bool `json:"disabled"`
	// Whether the VLAN interface is running (link up)
	Running bool `json:"running"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// IP addresses assigned to this VLAN
	IPAddresses []*IPAddress `json:"ipAddresses"`
	// Traffic statistics for this VLAN
	Statistics *InterfaceStats `json:"statistics,omitempty"`
}

func (Vlan) IsNode() {}

// Resources that depend on a VLAN interface
type VlanDependencies struct {
	// VLAN interface ID
	VlanID string `json:"vlanId"`
	// IP addresses assigned to this VLAN
	IPAddresses []*IPAddress `json:"ipAddresses"`
	// DHCP servers using this VLAN
	DhcpServers []*DhcpServer `json:"dhcpServers"`
	// Firewall rules referencing this VLAN
	FirewallRules []*FirewallRuleReference `json:"firewallRules"`
	// Routes using this VLAN interface
	Routes []*Route `json:"routes"`
	// Number of active connections on this VLAN
	ActiveConnections int `json:"activeConnections"`
	// Whether the VLAN has any dependencies
	HasDependencies bool `json:"hasDependencies"`
}

// Filter options for querying VLANs
type VlanFilter struct {
	// Filter by parent interface ID
	ParentInterface graphql.Omittable[*string] `json:"parentInterface,omitempty"`
	// Filter by VLAN ID range
	VlanIDRange graphql.Omittable[*IntRange] `json:"vlanIdRange,omitempty"`
	// Filter by name containing this string
	NameContains graphql.Omittable[*string] `json:"nameContains,omitempty"`
}

// Input for creating a new VLAN interface
type VlanInput struct {
	// VLAN interface name (alphanumeric, hyphens, underscores)
	Name string `json:"name"`
	// 802.1Q VLAN ID (1-4094)
	VlanID int `json:"vlanId"`
	// Parent interface ID (bridge or physical interface)
	Interface string `json:"interface"`
	// MTU setting (optional, inherits from parent if not set)
	Mtu graphql.Omittable[*int] `json:"mtu,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Result of a VLAN mutation (create, update)
type VlanMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The created or updated VLAN (if successful)
	Vlan *Vlan `json:"vlan,omitempty"`
	// Configuration preview (RouterOS commands that will be executed)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Errors that occurred during the operation
	Errors []*MutationError `json:"errors,omitempty"`
}

// VLAN topology data (nodes and edges)
type VlanTopology struct {
	// Topology nodes (bridges, VLANs, ports)
	Nodes []*TopologyNode `json:"nodes"`
	// Topology edges (connections)
	Edges []*TopologyEdge `json:"edges"`
}

// WAN connection history entry
type WANConnectionEvent struct {
	// Event ID
	ID string `json:"id"`
	// WAN interface ID
	WanInterfaceID string `json:"wanInterfaceId"`
	// Event type
	EventType WANEventType `json:"eventType"`
	// Event timestamp
	Timestamp time.Time `json:"timestamp"`
	// Public IP at the time (if applicable)
	PublicIP *IPv4 `json:"publicIP,omitempty"`
	// Gateway IP
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Reason/error message (if applicable)
	Reason *string `json:"reason,omitempty"`
	// Connection duration (for disconnect events)
	Duration *Duration `json:"duration,omitempty"`
}

// Connection history pagination
type WANConnectionEventConnection struct {
	Edges      []*WANConnectionEventEdge `json:"edges"`
	PageInfo   *PageInfo                 `json:"pageInfo"`
	TotalCount *int                      `json:"totalCount,omitempty"`
}

func (WANConnectionEventConnection) IsConnection() {}

type WANConnectionEventEdge struct {
	Node   *WANConnectionEvent `json:"node"`
	Cursor string              `json:"cursor"`
}

func (WANConnectionEventEdge) IsEdge() {}

// Input for configuring WAN health check
type WANHealthCheckInput struct {
	// Target host to ping (IP or hostname)
	Target string `json:"target"`
	// Check interval in seconds
	Interval int `json:"interval"`
	// Enable health check
	Enabled bool `json:"enabled"`
}

// WAN health check status
type WANHealthStatus struct {
	// Overall health status
	Status HealthCheckStatus `json:"status"`
	// Target host being monitored
	Target string `json:"target"`
	// Check interval
	Interval Duration `json:"interval"`
	// Current latency (if reachable)
	Latency *int `json:"latency,omitempty"`
	// Packet loss percentage (0-100)
	PacketLoss int `json:"packetLoss"`
	// Consecutive successful checks
	SuccessCount int `json:"successCount"`
	// Consecutive failed checks
	FailureCount int `json:"failureCount"`
	// Last check timestamp
	LastCheck time.Time `json:"lastCheck"`
	// Whether health check is enabled
	Enabled bool `json:"enabled"`
}

// WAN interface status with connection details
type WANInterface struct {
	// Unique identifier
	ID string `json:"id"`
	// Underlying network interface
	Interface *Interface `json:"interface"`
	// WAN connection type
	Type WANConnectionType `json:"type"`
	// Current connection status
	Status WANStatus `json:"status"`
	// Public IP address (if connected)
	PublicIP *IPv4 `json:"publicIP,omitempty"`
	// Gateway IP address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Primary DNS server
	PrimaryDNS *IPv4 `json:"primaryDNS,omitempty"`
	// Secondary DNS server
	SecondaryDNS *IPv4 `json:"secondaryDNS,omitempty"`
	// Connection uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Last connection time
	LastConnected *time.Time `json:"lastConnected,omitempty"`
	// Health check status
	Health *WANHealthStatus `json:"health,omitempty"`
	// DHCP client configuration (if type is DHCP)
	DhcpClient *DhcpClient `json:"dhcpClient,omitempty"`
	// PPPoE client configuration (if type is PPPOE)
	PppoeClient *PppoeClient `json:"pppoeClient,omitempty"`
	// Static IP configuration (if type is STATIC)
	StaticConfig *StaticIPConfig `json:"staticConfig,omitempty"`
	// LTE modem configuration (if type is LTE)
	LteModem *LteModem `json:"lteModem,omitempty"`
	// Whether this is the default route
	IsDefaultRoute bool `json:"isDefaultRoute"`
	// Traffic statistics
	Statistics *InterfaceStats `json:"statistics,omitempty"`
}

func (WANInterface) IsNode() {}

// WAN Link resource for internet connectivity
type WANLink struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]interface{} `json:"configuration,omitempty"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	WanRuntime    *WANLinkRuntime        `json:"wanRuntime,omitempty"`
	// Interface name
	Interface string `json:"interface"`
	// Connection type (static, dhcp, pppoe)
	ConnectionType WANConnectionType `json:"connectionType"`
	// Whether this is the primary WAN
	IsPrimary bool `json:"isPrimary"`
	// Failover priority (lower = higher priority)
	FailoverPriority *int `json:"failoverPriority,omitempty"`
}

func (WANLink) IsResource() {}

func (WANLink) IsNode() {}

// WAN Link runtime state
type WANLinkRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Current IP address
	CurrentIP *IPv4 `json:"currentIP,omitempty"`
	// Gateway address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Public IP (may differ due to NAT)
	PublicIP *IPv4 `json:"publicIP,omitempty"`
	// DNS servers received
	DNSServers []IPv4 `json:"dnsServers,omitempty"`
	// Current uplink speed (bytes/sec)
	UplinkSpeed *Size `json:"uplinkSpeed,omitempty"`
	// Current downlink speed (bytes/sec)
	DownlinkSpeed *Size `json:"downlinkSpeed,omitempty"`
	// Total uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Last connection change
	LastStateChange *time.Time `json:"lastStateChange,omitempty"`
}

// Result of WAN configuration mutation
type WANMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The configured WAN interface
	WanInterface *WANInterface `json:"wanInterface,omitempty"`
	// Configuration preview (RouterOS commands)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Webhook notification configuration
type Webhook struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Human-readable webhook name
	Name string `json:"name"`
	// Optional description
	Description *string `json:"description,omitempty"`
	// Webhook URL endpoint
	URL string `json:"url"`
	// HTTP method (default: POST)
	Method string `json:"method"`
	// Authentication type
	AuthType WebhookAuthType `json:"authType"`
	// Username for Basic auth
	Username *string `json:"username,omitempty"`
	// Bearer token (masked, only shown on creation)
	BearerToken *string `json:"bearerToken,omitempty"`
	// Custom HTTP headers (as JSON object)
	Headers map[string]interface{} `json:"headers,omitempty"`
	// Template type for webhook payload
	Template WebhookTemplate `json:"template"`
	// Custom template body (for CUSTOM template type)
	CustomTemplate *string `json:"customTemplate,omitempty"`
	// Signing secret (masked with ******, never returned in plaintext except on creation)
	SigningSecretMasked *string `json:"signingSecretMasked,omitempty"`
	// Timeout in seconds (default: 10)
	TimeoutSeconds int `json:"timeoutSeconds"`
	// Whether to retry failed deliveries
	RetryEnabled bool `json:"retryEnabled"`
	// Maximum retry attempts (default: 3)
	MaxRetries int `json:"maxRetries"`
	// Whether this webhook is enabled
	Enabled bool `json:"enabled"`
	// Record creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// Last successful delivery timestamp
	LastDeliveredAt *time.Time `json:"lastDeliveredAt,omitempty"`
	// Delivery statistics
	DeliveryStats *WebhookDeliveryStats `json:"deliveryStats,omitempty"`
}

func (Webhook) IsNode() {}

// Webhook delivery statistics
type WebhookDeliveryStats struct {
	// Total deliveries attempted
	TotalAttempts int `json:"totalAttempts"`
	// Successful deliveries
	SuccessCount int `json:"successCount"`
	// Failed deliveries
	FailureCount int `json:"failureCount"`
	// Success rate (0-100)
	SuccessRate float64 `json:"successRate"`
	// Average response time in milliseconds
	AvgResponseTimeMs *int `json:"avgResponseTimeMs,omitempty"`
}

// Webhook mutation payload
type WebhookPayload struct {
	// Created/updated webhook
	Webhook *Webhook `json:"webhook,omitempty"`
	// Signing secret (only returned on creation, one-time show)
	SigningSecret *string `json:"signingSecret,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Webhook test mutation payload
type WebhookTestPayload struct {
	// Test result
	Result *WebhookTestResult `json:"result,omitempty"`
	// Errors encountered during test
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of testing a webhook
type WebhookTestResult struct {
	// Whether the test was successful
	Success bool `json:"success"`
	// HTTP status code received
	StatusCode *int `json:"statusCode,omitempty"`
	// Response body from webhook endpoint
	ResponseBody *string `json:"responseBody,omitempty"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if test failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// WireGuard VPN Client resource implementing 8-layer model
type WireGuardClient struct {
	ID                  string                 `json:"id"`
	ScopedID            string                 `json:"scopedId"`
	Type                string                 `json:"type"`
	Category            ResourceCategory       `json:"category"`
	Configuration       map[string]interface{} `json:"configuration,omitempty"`
	Validation          *ValidationResult      `json:"validation,omitempty"`
	Deployment          *DeploymentState       `json:"deployment,omitempty"`
	Runtime             *RuntimeState          `json:"runtime,omitempty"`
	Telemetry           *TelemetryData         `json:"telemetry,omitempty"`
	Metadata            *ResourceMetadata      `json:"metadata"`
	Relationships       *ResourceRelationships `json:"relationships,omitempty"`
	Platform            *PlatformInfo          `json:"platform,omitempty"`
	Config              *WireGuardClientConfig `json:"config"`
	WireguardDeployment *WireGuardDeployment   `json:"wireguardDeployment,omitempty"`
	WireguardRuntime    *WireGuardRuntime      `json:"wireguardRuntime,omitempty"`
}

func (WireGuardClient) IsResource() {}

func (WireGuardClient) IsNode() {}

// WireGuard client configuration
type WireGuardClientConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// WireGuard private key
	PrivateKey string `json:"privateKey"`
	// Peer public key
	PeerPublicKey string `json:"peerPublicKey"`
	// Peer endpoint (IP:port)
	PeerEndpoint string `json:"peerEndpoint"`
	// Allowed IPs (CIDR notation)
	AllowedIPs []CIDR `json:"allowedIPs"`
	// Persistent keepalive interval
	PersistentKeepalive *Duration `json:"persistentKeepalive,omitempty"`
	// Listen port (0 for auto)
	ListenPort *Port `json:"listenPort,omitempty"`
	// WAN interface to use
	WanInterface *string `json:"wanInterface,omitempty"`
	// Enable kill switch
	KillSwitch *bool `json:"killSwitch,omitempty"`
	// DNS servers to use
	DNSServers []IPv4 `json:"dnsServers,omitempty"`
}

// WireGuard deployment state (router-generated)
type WireGuardDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Generated public key
	PublicKey *string `json:"publicKey,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// WireGuard runtime state
type WireGuardRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether connected to peer
	IsConnected bool `json:"isConnected"`
	// Last handshake time
	LastHandshake *time.Time `json:"lastHandshake,omitempty"`
	// Current endpoint (may differ from configured)
	CurrentEndpoint *string `json:"currentEndpoint,omitempty"`
	// Bytes transferred in
	BytesIn Size `json:"bytesIn"`
	// Bytes transferred out
	BytesOut Size `json:"bytesOut"`
	// Current active peers count
	ActivePeers int `json:"activePeers"`
}

// Alert action types for subscriptions
type AlertAction string

const (
	// Alert was created/triggered
	AlertActionCreated AlertAction = "CREATED"
	// Alert was acknowledged
	AlertActionAcknowledged AlertAction = "ACKNOWLEDGED"
	// Alert was resolved
	AlertActionResolved AlertAction = "RESOLVED"
)

var AllAlertAction = []AlertAction{
	AlertActionCreated,
	AlertActionAcknowledged,
	AlertActionResolved,
}

func (e AlertAction) IsValid() bool {
	switch e {
	case AlertActionCreated, AlertActionAcknowledged, AlertActionResolved:
		return true
	}
	return false
}

func (e AlertAction) String() string {
	return string(e)
}

func (e *AlertAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertAction", str)
	}
	return nil
}

func (e AlertAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Alert rule template categories
type AlertRuleTemplateCategory string

const (
	// Network connectivity and interface monitoring
	AlertRuleTemplateCategoryNetwork AlertRuleTemplateCategory = "NETWORK"
	// Security and firewall events
	AlertRuleTemplateCategorySecurity AlertRuleTemplateCategory = "SECURITY"
	// Resource usage (CPU, memory, disk)
	AlertRuleTemplateCategoryResources AlertRuleTemplateCategory = "RESOURCES"
	// VPN and tunnel monitoring
	AlertRuleTemplateCategoryVpn AlertRuleTemplateCategory = "VPN"
	// DHCP and IP address management
	AlertRuleTemplateCategoryDhcp AlertRuleTemplateCategory = "DHCP"
	// System events and maintenance
	AlertRuleTemplateCategorySystem AlertRuleTemplateCategory = "SYSTEM"
	// Custom user-defined templates
	AlertRuleTemplateCategoryCustom AlertRuleTemplateCategory = "CUSTOM"
)

var AllAlertRuleTemplateCategory = []AlertRuleTemplateCategory{
	AlertRuleTemplateCategoryNetwork,
	AlertRuleTemplateCategorySecurity,
	AlertRuleTemplateCategoryResources,
	AlertRuleTemplateCategoryVpn,
	AlertRuleTemplateCategoryDhcp,
	AlertRuleTemplateCategorySystem,
	AlertRuleTemplateCategoryCustom,
}

func (e AlertRuleTemplateCategory) IsValid() bool {
	switch e {
	case AlertRuleTemplateCategoryNetwork, AlertRuleTemplateCategorySecurity, AlertRuleTemplateCategoryResources, AlertRuleTemplateCategoryVpn, AlertRuleTemplateCategoryDhcp, AlertRuleTemplateCategorySystem, AlertRuleTemplateCategoryCustom:
		return true
	}
	return false
}

func (e AlertRuleTemplateCategory) String() string {
	return string(e)
}

func (e *AlertRuleTemplateCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertRuleTemplateCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertRuleTemplateCategory", str)
	}
	return nil
}

func (e AlertRuleTemplateCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Variable types for alert rule templates
type AlertRuleTemplateVariableType string

const (
	// String value
	AlertRuleTemplateVariableTypeString AlertRuleTemplateVariableType = "STRING"
	// Integer value
	AlertRuleTemplateVariableTypeInteger AlertRuleTemplateVariableType = "INTEGER"
	// Duration in seconds
	AlertRuleTemplateVariableTypeDuration AlertRuleTemplateVariableType = "DURATION"
	// Percentage (0-100)
	AlertRuleTemplateVariableTypePercentage AlertRuleTemplateVariableType = "PERCENTAGE"
)

var AllAlertRuleTemplateVariableType = []AlertRuleTemplateVariableType{
	AlertRuleTemplateVariableTypeString,
	AlertRuleTemplateVariableTypeInteger,
	AlertRuleTemplateVariableTypeDuration,
	AlertRuleTemplateVariableTypePercentage,
}

func (e AlertRuleTemplateVariableType) IsValid() bool {
	switch e {
	case AlertRuleTemplateVariableTypeString, AlertRuleTemplateVariableTypeInteger, AlertRuleTemplateVariableTypeDuration, AlertRuleTemplateVariableTypePercentage:
		return true
	}
	return false
}

func (e AlertRuleTemplateVariableType) String() string {
	return string(e)
}

func (e *AlertRuleTemplateVariableType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertRuleTemplateVariableType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertRuleTemplateVariableType", str)
	}
	return nil
}

func (e AlertRuleTemplateVariableType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Alert severity levels
type AlertSeverity string

const (
	// Critical - requires immediate attention
	AlertSeverityCritical AlertSeverity = "CRITICAL"
	// Warning - attention needed soon
	AlertSeverityWarning AlertSeverity = "WARNING"
	// Info - informational only
	AlertSeverityInfo AlertSeverity = "INFO"
)

var AllAlertSeverity = []AlertSeverity{
	AlertSeverityCritical,
	AlertSeverityWarning,
	AlertSeverityInfo,
}

func (e AlertSeverity) IsValid() bool {
	switch e {
	case AlertSeverityCritical, AlertSeverityWarning, AlertSeverityInfo:
		return true
	}
	return false
}

func (e AlertSeverity) String() string {
	return string(e)
}

func (e *AlertSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertSeverity", str)
	}
	return nil
}

func (e AlertSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Template variable types for notification templates
type AlertTemplateVariableType string

const (
	// String value
	AlertTemplateVariableTypeString AlertTemplateVariableType = "STRING"
	// Numeric value
	AlertTemplateVariableTypeNumber AlertTemplateVariableType = "NUMBER"
	// Timestamp value
	AlertTemplateVariableTypeTimestamp AlertTemplateVariableType = "TIMESTAMP"
	// Boolean value
	AlertTemplateVariableTypeBoolean AlertTemplateVariableType = "BOOLEAN"
	// Interface name
	AlertTemplateVariableTypeInterface AlertTemplateVariableType = "INTERFACE"
	// IP address
	AlertTemplateVariableTypeIpaddress AlertTemplateVariableType = "IPADDRESS"
)

var AllAlertTemplateVariableType = []AlertTemplateVariableType{
	AlertTemplateVariableTypeString,
	AlertTemplateVariableTypeNumber,
	AlertTemplateVariableTypeTimestamp,
	AlertTemplateVariableTypeBoolean,
	AlertTemplateVariableTypeInterface,
	AlertTemplateVariableTypeIpaddress,
}

func (e AlertTemplateVariableType) IsValid() bool {
	switch e {
	case AlertTemplateVariableTypeString, AlertTemplateVariableTypeNumber, AlertTemplateVariableTypeTimestamp, AlertTemplateVariableTypeBoolean, AlertTemplateVariableTypeInterface, AlertTemplateVariableTypeIpaddress:
		return true
	}
	return false
}

func (e AlertTemplateVariableType) String() string {
	return string(e)
}

func (e *AlertTemplateVariableType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertTemplateVariableType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertTemplateVariableType", str)
	}
	return nil
}

func (e AlertTemplateVariableType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Actions available for batch interface operations
type BatchInterfaceAction string

const (
	BatchInterfaceActionEnable  BatchInterfaceAction = "ENABLE"
	BatchInterfaceActionDisable BatchInterfaceAction = "DISABLE"
	BatchInterfaceActionUpdate  BatchInterfaceAction = "UPDATE"
)

var AllBatchInterfaceAction = []BatchInterfaceAction{
	BatchInterfaceActionEnable,
	BatchInterfaceActionDisable,
	BatchInterfaceActionUpdate,
}

func (e BatchInterfaceAction) IsValid() bool {
	switch e {
	case BatchInterfaceActionEnable, BatchInterfaceActionDisable, BatchInterfaceActionUpdate:
		return true
	}
	return false
}

func (e BatchInterfaceAction) String() string {
	return string(e)
}

func (e *BatchInterfaceAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BatchInterfaceAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BatchInterfaceAction", str)
	}
	return nil
}

func (e BatchInterfaceAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Frame types that can be admitted on a bridge port
type BridgePortFrameTypes string

const (
	// Accept all frames (tagged and untagged)
	BridgePortFrameTypesAdmitAll BridgePortFrameTypes = "ADMIT_ALL"
	// Accept only untagged and priority-tagged frames
	BridgePortFrameTypesAdmitOnlyUntaggedAndPriorityTagged BridgePortFrameTypes = "ADMIT_ONLY_UNTAGGED_AND_PRIORITY_TAGGED"
	// Accept only VLAN-tagged frames
	BridgePortFrameTypesAdmitOnlyVlanTagged BridgePortFrameTypes = "ADMIT_ONLY_VLAN_TAGGED"
)

var AllBridgePortFrameTypes = []BridgePortFrameTypes{
	BridgePortFrameTypesAdmitAll,
	BridgePortFrameTypesAdmitOnlyUntaggedAndPriorityTagged,
	BridgePortFrameTypesAdmitOnlyVlanTagged,
}

func (e BridgePortFrameTypes) IsValid() bool {
	switch e {
	case BridgePortFrameTypesAdmitAll, BridgePortFrameTypesAdmitOnlyUntaggedAndPriorityTagged, BridgePortFrameTypesAdmitOnlyVlanTagged:
		return true
	}
	return false
}

func (e BridgePortFrameTypes) String() string {
	return string(e)
}

func (e *BridgePortFrameTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BridgePortFrameTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BridgePortFrameTypes", str)
	}
	return nil
}

func (e BridgePortFrameTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CacheScope string

const (
	CacheScopePrivate CacheScope = "PRIVATE"
	CacheScopePublic  CacheScope = "PUBLIC"
)

var AllCacheScope = []CacheScope{
	CacheScopePrivate,
	CacheScopePublic,
}

func (e CacheScope) IsValid() bool {
	switch e {
	case CacheScopePrivate, CacheScopePublic:
		return true
	}
	return false
}

func (e CacheScope) String() string {
	return string(e)
}

func (e *CacheScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CacheScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CacheScope", str)
	}
	return nil
}

func (e CacheScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Feature capability categories detected on routers.
// Used to determine what features are available on a specific router.
type Capability string

const (
	// Container/Docker support
	CapabilityContainer Capability = "CONTAINER"
	// Virtual Interface Factory support
	CapabilityVif Capability = "VIF"
	// Wireless/WiFi support
	CapabilityWireless Capability = "WIRELESS"
	// Advanced routing features
	CapabilityRouting Capability = "ROUTING"
	// Firewall features
	CapabilityFirewall Capability = "FIREWALL"
	// MPLS support
	CapabilityMpls Capability = "MPLS"
	// IPv6 support
	CapabilityIPV6 Capability = "IPV6"
	// Hotspot features
	CapabilityHotspot Capability = "HOTSPOT"
	// User Manager features
	CapabilityUserManager Capability = "USER_MANAGER"
	// Dude monitoring support
	CapabilityDude Capability = "DUDE"
	// WireGuard VPN support
	CapabilityWireguard Capability = "WIREGUARD"
	// ZeroTier support
	CapabilityZerotier Capability = "ZEROTIER"
)

var AllCapability = []Capability{
	CapabilityContainer,
	CapabilityVif,
	CapabilityWireless,
	CapabilityRouting,
	CapabilityFirewall,
	CapabilityMpls,
	CapabilityIPV6,
	CapabilityHotspot,
	CapabilityUserManager,
	CapabilityDude,
	CapabilityWireguard,
	CapabilityZerotier,
}

func (e Capability) IsValid() bool {
	switch e {
	case CapabilityContainer, CapabilityVif, CapabilityWireless, CapabilityRouting, CapabilityFirewall, CapabilityMpls, CapabilityIPV6, CapabilityHotspot, CapabilityUserManager, CapabilityDude, CapabilityWireguard, CapabilityZerotier:
		return true
	}
	return false
}

func (e Capability) String() string {
	return string(e)
}

func (e *Capability) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Capability(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Capability", str)
	}
	return nil
}

func (e Capability) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Capability support level for a feature.
// Determines how the feature appears in the UI.
type CapabilityLevel string

const (
	// Feature not supported (hide in UI)
	CapabilityLevelNone CapabilityLevel = "NONE"
	// Limited support (show with warnings)
	CapabilityLevelBasic CapabilityLevel = "BASIC"
	// Full RouterOS native support
	CapabilityLevelAdvanced CapabilityLevel = "ADVANCED"
	// Complete support including container-based features
	CapabilityLevelFull CapabilityLevel = "FULL"
)

var AllCapabilityLevel = []CapabilityLevel{
	CapabilityLevelNone,
	CapabilityLevelBasic,
	CapabilityLevelAdvanced,
	CapabilityLevelFull,
}

func (e CapabilityLevel) IsValid() bool {
	switch e {
	case CapabilityLevelNone, CapabilityLevelBasic, CapabilityLevelAdvanced, CapabilityLevelFull:
		return true
	}
	return false
}

func (e CapabilityLevel) String() string {
	return string(e)
}

func (e *CapabilityLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CapabilityLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CapabilityLevel", str)
	}
	return nil
}

func (e CapabilityLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of operation to perform on a resource
type ChangeOperation string

const (
	// Create a new resource
	ChangeOperationCreate ChangeOperation = "CREATE"
	// Update an existing resource
	ChangeOperationUpdate ChangeOperation = "UPDATE"
	// Delete an existing resource
	ChangeOperationDelete ChangeOperation = "DELETE"
)

var AllChangeOperation = []ChangeOperation{
	ChangeOperationCreate,
	ChangeOperationUpdate,
	ChangeOperationDelete,
}

func (e ChangeOperation) IsValid() bool {
	switch e {
	case ChangeOperationCreate, ChangeOperationUpdate, ChangeOperationDelete:
		return true
	}
	return false
}

func (e ChangeOperation) String() string {
	return string(e)
}

func (e *ChangeOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeOperation", str)
	}
	return nil
}

func (e ChangeOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of individual items within a change set
type ChangeSetItemStatus string

const (
	// Waiting to be applied
	ChangeSetItemStatusPending ChangeSetItemStatus = "PENDING"
	// Currently being applied
	ChangeSetItemStatusApplying ChangeSetItemStatus = "APPLYING"
	// Successfully applied
	ChangeSetItemStatusApplied ChangeSetItemStatus = "APPLIED"
	// Application failed
	ChangeSetItemStatusFailed ChangeSetItemStatus = "FAILED"
	// Successfully rolled back
	ChangeSetItemStatusRolledBack ChangeSetItemStatus = "ROLLED_BACK"
	// Rollback failed - manual intervention needed
	ChangeSetItemStatusRollbackFailed ChangeSetItemStatus = "ROLLBACK_FAILED"
	// Skipped due to dependency failure
	ChangeSetItemStatusSkipped ChangeSetItemStatus = "SKIPPED"
)

var AllChangeSetItemStatus = []ChangeSetItemStatus{
	ChangeSetItemStatusPending,
	ChangeSetItemStatusApplying,
	ChangeSetItemStatusApplied,
	ChangeSetItemStatusFailed,
	ChangeSetItemStatusRolledBack,
	ChangeSetItemStatusRollbackFailed,
	ChangeSetItemStatusSkipped,
}

func (e ChangeSetItemStatus) IsValid() bool {
	switch e {
	case ChangeSetItemStatusPending, ChangeSetItemStatusApplying, ChangeSetItemStatusApplied, ChangeSetItemStatusFailed, ChangeSetItemStatusRolledBack, ChangeSetItemStatusRollbackFailed, ChangeSetItemStatusSkipped:
		return true
	}
	return false
}

func (e ChangeSetItemStatus) String() string {
	return string(e)
}

func (e *ChangeSetItemStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeSetItemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeSetItemStatus", str)
	}
	return nil
}

func (e ChangeSetItemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Change set lifecycle status
type ChangeSetStatus string

const (
	// Initial state - adding items, not yet validated
	ChangeSetStatusDraft ChangeSetStatus = "DRAFT"
	// Running validation on all items
	ChangeSetStatusValidating ChangeSetStatus = "VALIDATING"
	// All items validated, ready to apply
	ChangeSetStatusReady ChangeSetStatus = "READY"
	// Applying resources in dependency order
	ChangeSetStatusApplying ChangeSetStatus = "APPLYING"
	// All resources applied successfully
	ChangeSetStatusCompleted ChangeSetStatus = "COMPLETED"
	// Apply failed, may have partial application
	ChangeSetStatusFailed ChangeSetStatus = "FAILED"
	// Rolling back applied changes
	ChangeSetStatusRollingBack ChangeSetStatus = "ROLLING_BACK"
	// Rollback completed successfully
	ChangeSetStatusRolledBack ChangeSetStatus = "ROLLED_BACK"
	// Rollback partially failed - manual intervention needed
	ChangeSetStatusPartialFailure ChangeSetStatus = "PARTIAL_FAILURE"
	// User cancelled the operation
	ChangeSetStatusCancelled ChangeSetStatus = "CANCELLED"
)

var AllChangeSetStatus = []ChangeSetStatus{
	ChangeSetStatusDraft,
	ChangeSetStatusValidating,
	ChangeSetStatusReady,
	ChangeSetStatusApplying,
	ChangeSetStatusCompleted,
	ChangeSetStatusFailed,
	ChangeSetStatusRollingBack,
	ChangeSetStatusRolledBack,
	ChangeSetStatusPartialFailure,
	ChangeSetStatusCancelled,
}

func (e ChangeSetStatus) IsValid() bool {
	switch e {
	case ChangeSetStatusDraft, ChangeSetStatusValidating, ChangeSetStatusReady, ChangeSetStatusApplying, ChangeSetStatusCompleted, ChangeSetStatusFailed, ChangeSetStatusRollingBack, ChangeSetStatusRolledBack, ChangeSetStatusPartialFailure, ChangeSetStatusCancelled:
		return true
	}
	return false
}

func (e ChangeSetStatus) String() string {
	return string(e)
}

func (e *ChangeSetStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeSetStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeSetStatus", str)
	}
	return nil
}

func (e ChangeSetStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of change for resource events
type ChangeType string

const (
	ChangeTypeCreate ChangeType = "CREATE"
	ChangeTypeUpdate ChangeType = "UPDATE"
	ChangeTypeDelete ChangeType = "DELETE"
)

var AllChangeType = []ChangeType{
	ChangeTypeCreate,
	ChangeTypeUpdate,
	ChangeTypeDelete,
}

func (e ChangeType) IsValid() bool {
	switch e {
	case ChangeTypeCreate, ChangeTypeUpdate, ChangeTypeDelete:
		return true
	}
	return false
}

func (e ChangeType) String() string {
	return string(e)
}

func (e *ChangeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeType", str)
	}
	return nil
}

func (e ChangeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of notification channel
type ChannelType string

const (
	ChannelTypePushover ChannelType = "PUSHOVER"
	ChannelTypeEmail    ChannelType = "EMAIL"
	ChannelTypeSLACk    ChannelType = "SLACK"
	ChannelTypeWebhook  ChannelType = "WEBHOOK"
	ChannelTypeTelegram ChannelType = "TELEGRAM"
)

var AllChannelType = []ChannelType{
	ChannelTypePushover,
	ChannelTypeEmail,
	ChannelTypeSLACk,
	ChannelTypeWebhook,
	ChannelTypeTelegram,
}

func (e ChannelType) IsValid() bool {
	switch e {
	case ChannelTypePushover, ChannelTypeEmail, ChannelTypeSLACk, ChannelTypeWebhook, ChannelTypeTelegram:
		return true
	}
	return false
}

func (e ChannelType) String() string {
	return string(e)
}

func (e *ChannelType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChannelType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChannelType", str)
	}
	return nil
}

func (e ChannelType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Circuit breaker state
type CircuitBreakerState string

const (
	// Circuit is closed (normal operation)
	CircuitBreakerStateClosed CircuitBreakerState = "CLOSED"
	// Circuit is open (blocking requests)
	CircuitBreakerStateOpen CircuitBreakerState = "OPEN"
	// Circuit is half-open (testing recovery)
	CircuitBreakerStateHalfOpen CircuitBreakerState = "HALF_OPEN"
)

var AllCircuitBreakerState = []CircuitBreakerState{
	CircuitBreakerStateClosed,
	CircuitBreakerStateOpen,
	CircuitBreakerStateHalfOpen,
}

func (e CircuitBreakerState) IsValid() bool {
	switch e {
	case CircuitBreakerStateClosed, CircuitBreakerStateOpen, CircuitBreakerStateHalfOpen:
		return true
	}
	return false
}

func (e CircuitBreakerState) String() string {
	return string(e)
}

func (e *CircuitBreakerState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CircuitBreakerState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CircuitBreakerState", str)
	}
	return nil
}

func (e CircuitBreakerState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Condition comparison operators
type ConditionOperator string

const (
	// Exact match
	ConditionOperatorEquals ConditionOperator = "EQUALS"
	// Not equal
	ConditionOperatorNotEquals ConditionOperator = "NOT_EQUALS"
	// Numeric greater than
	ConditionOperatorGreaterThan ConditionOperator = "GREATER_THAN"
	// Numeric less than
	ConditionOperatorLessThan ConditionOperator = "LESS_THAN"
	// String contains
	ConditionOperatorContains ConditionOperator = "CONTAINS"
	// Regular expression match
	ConditionOperatorRegex ConditionOperator = "REGEX"
)

var AllConditionOperator = []ConditionOperator{
	ConditionOperatorEquals,
	ConditionOperatorNotEquals,
	ConditionOperatorGreaterThan,
	ConditionOperatorLessThan,
	ConditionOperatorContains,
	ConditionOperatorRegex,
}

func (e ConditionOperator) IsValid() bool {
	switch e {
	case ConditionOperatorEquals, ConditionOperatorNotEquals, ConditionOperatorGreaterThan, ConditionOperatorLessThan, ConditionOperatorContains, ConditionOperatorRegex:
		return true
	}
	return false
}

func (e ConditionOperator) String() string {
	return string(e)
}

func (e *ConditionOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionOperator", str)
	}
	return nil
}

func (e ConditionOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a configuration apply operation
type ConfigApplyStatus string

const (
	ConfigApplyStatusPending    ConfigApplyStatus = "PENDING"
	ConfigApplyStatusValidating ConfigApplyStatus = "VALIDATING"
	ConfigApplyStatusApplying   ConfigApplyStatus = "APPLYING"
	ConfigApplyStatusVerifying  ConfigApplyStatus = "VERIFYING"
	ConfigApplyStatusCompleted  ConfigApplyStatus = "COMPLETED"
	ConfigApplyStatusFailed     ConfigApplyStatus = "FAILED"
	ConfigApplyStatusRolledBack ConfigApplyStatus = "ROLLED_BACK"
)

var AllConfigApplyStatus = []ConfigApplyStatus{
	ConfigApplyStatusPending,
	ConfigApplyStatusValidating,
	ConfigApplyStatusApplying,
	ConfigApplyStatusVerifying,
	ConfigApplyStatusCompleted,
	ConfigApplyStatusFailed,
	ConfigApplyStatusRolledBack,
}

func (e ConfigApplyStatus) IsValid() bool {
	switch e {
	case ConfigApplyStatusPending, ConfigApplyStatusValidating, ConfigApplyStatusApplying, ConfigApplyStatusVerifying, ConfigApplyStatusCompleted, ConfigApplyStatusFailed, ConfigApplyStatusRolledBack:
		return true
	}
	return false
}

func (e ConfigApplyStatus) String() string {
	return string(e)
}

func (e *ConfigApplyStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfigApplyStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfigApplyStatus", str)
	}
	return nil
}

func (e ConfigApplyStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Severity level for confirmation dialogs
type ConfirmationSeverity string

const (
	// Critical operation requiring explicit confirmation
	ConfirmationSeverityCritical ConfirmationSeverity = "CRITICAL"
	// Standard operation with brief confirmation
	ConfirmationSeverityStandard ConfirmationSeverity = "STANDARD"
)

var AllConfirmationSeverity = []ConfirmationSeverity{
	ConfirmationSeverityCritical,
	ConfirmationSeverityStandard,
}

func (e ConfirmationSeverity) IsValid() bool {
	switch e {
	case ConfirmationSeverityCritical, ConfirmationSeverityStandard:
		return true
	}
	return false
}

func (e ConfirmationSeverity) String() string {
	return string(e)
}

func (e *ConfirmationSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfirmationSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfirmationSeverity", str)
	}
	return nil
}

func (e ConfirmationSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of resource conflicts
type ConflictType string

const (
	// Port number conflict
	ConflictTypePort ConflictType = "PORT"
	// IP address conflict
	ConflictTypeIPAddress ConflictType = "IP_ADDRESS"
	// Route overlap
	ConflictTypeRoute ConflictType = "ROUTE"
	// Interface conflict
	ConflictTypeInterface ConflictType = "INTERFACE"
	// Name collision
	ConflictTypeName ConflictType = "NAME"
	// Configuration incompatibility
	ConflictTypeConfiguration ConflictType = "CONFIGURATION"
)

var AllConflictType = []ConflictType{
	ConflictTypePort,
	ConflictTypeIPAddress,
	ConflictTypeRoute,
	ConflictTypeInterface,
	ConflictTypeName,
	ConflictTypeConfiguration,
}

func (e ConflictType) IsValid() bool {
	switch e {
	case ConflictTypePort, ConflictTypeIPAddress, ConflictTypeRoute, ConflictTypeInterface, ConflictTypeName, ConflictTypeConfiguration:
		return true
	}
	return false
}

func (e ConflictType) String() string {
	return string(e)
}

func (e *ConflictType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConflictType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConflictType", str)
	}
	return nil
}

func (e ConflictType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error codes for connection failures.
// Each code has specific meaning and recovery suggestions.
type ConnectionErrorCode string

const (
	// Authentication failed - invalid username or password
	ConnectionErrorCodeAuthFailed ConnectionErrorCode = "AUTH_FAILED"
	// Network unreachable - cannot reach the host
	ConnectionErrorCodeNetworkUnreachable ConnectionErrorCode = "NETWORK_UNREACHABLE"
	// Connection refused - port is closed or blocked
	ConnectionErrorCodeConnectionRefused ConnectionErrorCode = "CONNECTION_REFUSED"
	// No compatible protocol found after trying all options
	ConnectionErrorCodeProtocolMismatch ConnectionErrorCode = "PROTOCOL_MISMATCH"
	// Connection or response timed out
	ConnectionErrorCodeTimeout ConnectionErrorCode = "TIMEOUT"
	// DNS resolution failed for hostname
	ConnectionErrorCodeDNSFailed ConnectionErrorCode = "DNS_FAILED"
	// Router with same host/port already exists
	ConnectionErrorCodeDuplicateRouter ConnectionErrorCode = "DUPLICATE_ROUTER"
	// TLS/SSL handshake failed
	ConnectionErrorCodeTLSError ConnectionErrorCode = "TLS_ERROR"
	// Router responded but is not a MikroTik device
	ConnectionErrorCodeNotMikrotik ConnectionErrorCode = "NOT_MIKROTIK"
	// Unknown or unexpected error
	ConnectionErrorCodeUnknown ConnectionErrorCode = "UNKNOWN"
)

var AllConnectionErrorCode = []ConnectionErrorCode{
	ConnectionErrorCodeAuthFailed,
	ConnectionErrorCodeNetworkUnreachable,
	ConnectionErrorCodeConnectionRefused,
	ConnectionErrorCodeProtocolMismatch,
	ConnectionErrorCodeTimeout,
	ConnectionErrorCodeDNSFailed,
	ConnectionErrorCodeDuplicateRouter,
	ConnectionErrorCodeTLSError,
	ConnectionErrorCodeNotMikrotik,
	ConnectionErrorCodeUnknown,
}

func (e ConnectionErrorCode) IsValid() bool {
	switch e {
	case ConnectionErrorCodeAuthFailed, ConnectionErrorCodeNetworkUnreachable, ConnectionErrorCodeConnectionRefused, ConnectionErrorCodeProtocolMismatch, ConnectionErrorCodeTimeout, ConnectionErrorCodeDNSFailed, ConnectionErrorCodeDuplicateRouter, ConnectionErrorCodeTLSError, ConnectionErrorCodeNotMikrotik, ConnectionErrorCodeUnknown:
		return true
	}
	return false
}

func (e ConnectionErrorCode) String() string {
	return string(e)
}

func (e *ConnectionErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionErrorCode", str)
	}
	return nil
}

func (e ConnectionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Router connection status
type ConnectionStatus string

const (
	// Actively connected and responsive
	ConnectionStatusConnected ConnectionStatus = "CONNECTED"
	// Connection attempt in progress
	ConnectionStatusConnecting ConnectionStatus = "CONNECTING"
	// Not connected
	ConnectionStatusDisconnected ConnectionStatus = "DISCONNECTED"
	// Connection failed with error
	ConnectionStatusError ConnectionStatus = "ERROR"
)

var AllConnectionStatus = []ConnectionStatus{
	ConnectionStatusConnected,
	ConnectionStatusConnecting,
	ConnectionStatusDisconnected,
	ConnectionStatusError,
}

func (e ConnectionStatus) IsValid() bool {
	switch e {
	case ConnectionStatusConnected, ConnectionStatusConnecting, ConnectionStatusDisconnected, ConnectionStatusError:
		return true
	}
	return false
}

func (e ConnectionStatus) String() string {
	return string(e)
}

func (e *ConnectionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionStatus", str)
	}
	return nil
}

func (e ConnectionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Error codes specific to credential operations.
type CredentialErrorCode string

const (
	// Authentication failed with new credentials
	CredentialErrorCodeAuthFailed CredentialErrorCode = "AUTH_FAILED"
	// Connection timed out when testing credentials
	CredentialErrorCodeTimeout CredentialErrorCode = "TIMEOUT"
	// Connection was refused
	CredentialErrorCodeConnectionRefused CredentialErrorCode = "CONNECTION_REFUSED"
	// Router not found
	CredentialErrorCodeRouterNotFound CredentialErrorCode = "ROUTER_NOT_FOUND"
	// Credentials not found for router
	CredentialErrorCodeCredentialsNotFound CredentialErrorCode = "CREDENTIALS_NOT_FOUND"
	// Encryption failed
	CredentialErrorCodeEncryptionFailed CredentialErrorCode = "ENCRYPTION_FAILED"
	// Decryption failed (key may have rotated)
	CredentialErrorCodeDecryptionFailed CredentialErrorCode = "DECRYPTION_FAILED"
	// Invalid input provided
	CredentialErrorCodeInvalidInput CredentialErrorCode = "INVALID_INPUT"
)

var AllCredentialErrorCode = []CredentialErrorCode{
	CredentialErrorCodeAuthFailed,
	CredentialErrorCodeTimeout,
	CredentialErrorCodeConnectionRefused,
	CredentialErrorCodeRouterNotFound,
	CredentialErrorCodeCredentialsNotFound,
	CredentialErrorCodeEncryptionFailed,
	CredentialErrorCodeDecryptionFailed,
	CredentialErrorCodeInvalidInput,
}

func (e CredentialErrorCode) IsValid() bool {
	switch e {
	case CredentialErrorCodeAuthFailed, CredentialErrorCodeTimeout, CredentialErrorCodeConnectionRefused, CredentialErrorCodeRouterNotFound, CredentialErrorCodeCredentialsNotFound, CredentialErrorCodeEncryptionFailed, CredentialErrorCodeDecryptionFailed, CredentialErrorCodeInvalidInput:
		return true
	}
	return false
}

func (e CredentialErrorCode) String() string {
	return string(e)
}

func (e *CredentialErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CredentialErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CredentialErrorCode", str)
	}
	return nil
}

func (e CredentialErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a credential test.
type CredentialTestStatus string

const (
	// Credentials are valid and connection succeeded
	CredentialTestStatusSuccess CredentialTestStatus = "SUCCESS"
	// Authentication failed
	CredentialTestStatusAuthFailed CredentialTestStatus = "AUTH_FAILED"
	// Connection timed out
	CredentialTestStatusTimeout CredentialTestStatus = "TIMEOUT"
	// Connection was refused
	CredentialTestStatusConnectionRefused CredentialTestStatus = "CONNECTION_REFUSED"
	// Network unreachable
	CredentialTestStatusNetworkError CredentialTestStatus = "NETWORK_ERROR"
	// No credentials stored for this router
	CredentialTestStatusNoCredentials CredentialTestStatus = "NO_CREDENTIALS"
	// Unknown error occurred
	CredentialTestStatusError CredentialTestStatus = "ERROR"
)

var AllCredentialTestStatus = []CredentialTestStatus{
	CredentialTestStatusSuccess,
	CredentialTestStatusAuthFailed,
	CredentialTestStatusTimeout,
	CredentialTestStatusConnectionRefused,
	CredentialTestStatusNetworkError,
	CredentialTestStatusNoCredentials,
	CredentialTestStatusError,
}

func (e CredentialTestStatus) IsValid() bool {
	switch e {
	case CredentialTestStatusSuccess, CredentialTestStatusAuthFailed, CredentialTestStatusTimeout, CredentialTestStatusConnectionRefused, CredentialTestStatusNetworkError, CredentialTestStatusNoCredentials, CredentialTestStatusError:
		return true
	}
	return false
}

func (e CredentialTestStatus) String() string {
	return string(e)
}

func (e *CredentialTestStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CredentialTestStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CredentialTestStatus", str)
	}
	return nil
}

func (e CredentialTestStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Reason for router disconnection
type DisconnectReason string

const (
	// Unknown reason
	DisconnectReasonUnknown DisconnectReason = "UNKNOWN"
	// User manually disconnected
	DisconnectReasonManual DisconnectReason = "MANUAL"
	// Network failure
	DisconnectReasonNetworkFailure DisconnectReason = "NETWORK_FAILURE"
	// Authentication failed
	DisconnectReasonAuthFailure DisconnectReason = "AUTH_FAILURE"
	// Connection timed out
	DisconnectReasonTimeout DisconnectReason = "TIMEOUT"
	// Circuit breaker is open
	DisconnectReasonCircuitOpen DisconnectReason = "CIRCUIT_OPEN"
	// Application shutting down
	DisconnectReasonShutdown DisconnectReason = "SHUTDOWN"
)

var AllDisconnectReason = []DisconnectReason{
	DisconnectReasonUnknown,
	DisconnectReasonManual,
	DisconnectReasonNetworkFailure,
	DisconnectReasonAuthFailure,
	DisconnectReasonTimeout,
	DisconnectReasonCircuitOpen,
	DisconnectReasonShutdown,
}

func (e DisconnectReason) IsValid() bool {
	switch e {
	case DisconnectReasonUnknown, DisconnectReasonManual, DisconnectReasonNetworkFailure, DisconnectReasonAuthFailure, DisconnectReasonTimeout, DisconnectReasonCircuitOpen, DisconnectReasonShutdown:
		return true
	}
	return false
}

func (e DisconnectReason) String() string {
	return string(e)
}

func (e *DisconnectReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DisconnectReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DisconnectReason", str)
	}
	return nil
}

func (e DisconnectReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DNS lookup status codes
type DNSLookupStatus string

const (
	// Query completed successfully
	DNSLookupStatusSuccess DNSLookupStatus = "SUCCESS"
	// Domain does not exist (NXDOMAIN)
	DNSLookupStatusNxdomain DNSLookupStatus = "NXDOMAIN"
	// DNS server failure (SERVFAIL)
	DNSLookupStatusServfail DNSLookupStatus = "SERVFAIL"
	// Query timed out
	DNSLookupStatusTimeout DNSLookupStatus = "TIMEOUT"
	// Query refused by server
	DNSLookupStatusRefused DNSLookupStatus = "REFUSED"
	// Network error occurred
	DNSLookupStatusNetworkError DNSLookupStatus = "NETWORK_ERROR"
)

var AllDNSLookupStatus = []DNSLookupStatus{
	DNSLookupStatusSuccess,
	DNSLookupStatusNxdomain,
	DNSLookupStatusServfail,
	DNSLookupStatusTimeout,
	DNSLookupStatusRefused,
	DNSLookupStatusNetworkError,
}

func (e DNSLookupStatus) IsValid() bool {
	switch e {
	case DNSLookupStatusSuccess, DNSLookupStatusNxdomain, DNSLookupStatusServfail, DNSLookupStatusTimeout, DNSLookupStatusRefused, DNSLookupStatusNetworkError:
		return true
	}
	return false
}

func (e DNSLookupStatus) String() string {
	return string(e)
}

func (e *DNSLookupStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DNSLookupStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DnsLookupStatus", str)
	}
	return nil
}

func (e DNSLookupStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// DNS record types supported
type DNSRecordType string

const (
	// IPv4 address record
	DNSRecordTypeA DNSRecordType = "A"
	// IPv6 address record
	DNSRecordTypeAaaa DNSRecordType = "AAAA"
	// Mail exchange record
	DNSRecordTypeMx DNSRecordType = "MX"
	// Text record
	DNSRecordTypeTxt DNSRecordType = "TXT"
	// Canonical name record
	DNSRecordTypeCname DNSRecordType = "CNAME"
	// Name server record
	DNSRecordTypeNs DNSRecordType = "NS"
	// Pointer record (reverse DNS)
	DNSRecordTypePtr DNSRecordType = "PTR"
	// Start of authority record
	DNSRecordTypeSoa DNSRecordType = "SOA"
	// Service record
	DNSRecordTypeSrv DNSRecordType = "SRV"
)

var AllDNSRecordType = []DNSRecordType{
	DNSRecordTypeA,
	DNSRecordTypeAaaa,
	DNSRecordTypeMx,
	DNSRecordTypeTxt,
	DNSRecordTypeCname,
	DNSRecordTypeNs,
	DNSRecordTypePtr,
	DNSRecordTypeSoa,
	DNSRecordTypeSrv,
}

func (e DNSRecordType) IsValid() bool {
	switch e {
	case DNSRecordTypeA, DNSRecordTypeAaaa, DNSRecordTypeMx, DNSRecordTypeTxt, DNSRecordTypeCname, DNSRecordTypeNs, DNSRecordTypePtr, DNSRecordTypeSoa, DNSRecordTypeSrv:
		return true
	}
	return false
}

func (e DNSRecordType) String() string {
	return string(e)
}

func (e *DNSRecordType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DNSRecordType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DnsRecordType", str)
	}
	return nil
}

func (e DNSRecordType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status classification for DNS servers in benchmark
type DNSServerStatus string

const (
	// Fastest responding server
	DNSServerStatusFastest DNSServerStatus = "FASTEST"
	// Server responded in acceptable time (<100ms)
	DNSServerStatusGood DNSServerStatus = "GOOD"
	// Server responded slowly (>100ms)
	DNSServerStatusSlow DNSServerStatus = "SLOW"
	// Server did not respond
	DNSServerStatusUnreachable DNSServerStatus = "UNREACHABLE"
)

var AllDNSServerStatus = []DNSServerStatus{
	DNSServerStatusFastest,
	DNSServerStatusGood,
	DNSServerStatusSlow,
	DNSServerStatusUnreachable,
}

func (e DNSServerStatus) IsValid() bool {
	switch e {
	case DNSServerStatusFastest, DNSServerStatusGood, DNSServerStatusSlow, DNSServerStatusUnreachable:
		return true
	}
	return false
}

func (e DNSServerStatus) String() string {
	return string(e)
}

func (e *DNSServerStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DNSServerStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DnsServerStatus", str)
	}
	return nil
}

func (e DNSServerStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Actions to resolve drift
type DriftAction string

const (
	// Re-apply configuration to router
	DriftActionReapply DriftAction = "REAPPLY"
	// Update configuration to match router
	DriftActionAccept DriftAction = "ACCEPT"
	// Manual review required
	DriftActionReview DriftAction = "REVIEW"
)

var AllDriftAction = []DriftAction{
	DriftActionReapply,
	DriftActionAccept,
	DriftActionReview,
}

func (e DriftAction) IsValid() bool {
	switch e {
	case DriftActionReapply, DriftActionAccept, DriftActionReview:
		return true
	}
	return false
}

func (e DriftAction) String() string {
	return string(e)
}

func (e *DriftAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DriftAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DriftAction", str)
	}
	return nil
}

func (e DriftAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Category of connection error for classification
type ErrorCategory string

const (
	// Connection or response timeout
	ErrorCategoryTimeout ErrorCategory = "TIMEOUT"
	// Connection actively refused
	ErrorCategoryRefused ErrorCategory = "REFUSED"
	// Authentication failed
	ErrorCategoryAuthFailed ErrorCategory = "AUTH_FAILED"
	// Protocol-level error
	ErrorCategoryProtocolError ErrorCategory = "PROTOCOL_ERROR"
	// Network unreachable or DNS failure
	ErrorCategoryNetworkError ErrorCategory = "NETWORK_ERROR"
	// TLS/SSL certificate or handshake error
	ErrorCategoryTLSError ErrorCategory = "TLS_ERROR"
)

var AllErrorCategory = []ErrorCategory{
	ErrorCategoryTimeout,
	ErrorCategoryRefused,
	ErrorCategoryAuthFailed,
	ErrorCategoryProtocolError,
	ErrorCategoryNetworkError,
	ErrorCategoryTLSError,
}

func (e ErrorCategory) IsValid() bool {
	switch e {
	case ErrorCategoryTimeout, ErrorCategoryRefused, ErrorCategoryAuthFailed, ErrorCategoryProtocolError, ErrorCategoryNetworkError, ErrorCategoryTLSError:
		return true
	}
	return false
}

func (e ErrorCategory) String() string {
	return string(e)
}

func (e *ErrorCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorCategory", str)
	}
	return nil
}

func (e ErrorCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Escalation status (NAS-18.9)
type EscalationStatus string

const (
	// Escalation is pending/in progress
	EscalationStatusPending EscalationStatus = "PENDING"
	// Escalation was resolved (alert acknowledged)
	EscalationStatusResolved EscalationStatus = "RESOLVED"
	// Maximum escalation level reached
	EscalationStatusMaxReached EscalationStatus = "MAX_REACHED"
)

var AllEscalationStatus = []EscalationStatus{
	EscalationStatusPending,
	EscalationStatusResolved,
	EscalationStatusMaxReached,
}

func (e EscalationStatus) IsValid() bool {
	switch e {
	case EscalationStatusPending, EscalationStatusResolved, EscalationStatusMaxReached:
		return true
	}
	return false
}

func (e EscalationStatus) String() string {
	return string(e)
}

func (e *EscalationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EscalationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EscalationStatus", str)
	}
	return nil
}

func (e EscalationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Firewall table types.
type FirewallTable string

const (
	// Packet filtering
	FirewallTableFilter FirewallTable = "FILTER"
	// Network address translation
	FirewallTableNat FirewallTable = "NAT"
	// Packet marking and modification
	FirewallTableMangle FirewallTable = "MANGLE"
	// Raw packet processing
	FirewallTableRaw FirewallTable = "RAW"
)

var AllFirewallTable = []FirewallTable{
	FirewallTableFilter,
	FirewallTableNat,
	FirewallTableMangle,
	FirewallTableRaw,
}

func (e FirewallTable) IsValid() bool {
	switch e {
	case FirewallTableFilter, FirewallTableNat, FirewallTableMangle, FirewallTableRaw:
		return true
	}
	return false
}

func (e FirewallTable) String() string {
	return string(e)
}

func (e *FirewallTable) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallTable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FirewallTable", str)
	}
	return nil
}

func (e FirewallTable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a fix application
type FixApplicationStatus string

const (
	// Fix is available but not yet applied
	FixApplicationStatusAvailable FixApplicationStatus = "AVAILABLE"
	// Fix is being applied
	FixApplicationStatusApplying FixApplicationStatus = "APPLYING"
	// Fix was applied successfully
	FixApplicationStatusApplied FixApplicationStatus = "APPLIED"
	// Fix application failed
	FixApplicationStatusFailed FixApplicationStatus = "FAILED"
	// Fix was applied but issue persists
	FixApplicationStatusIssuePersists FixApplicationStatus = "ISSUE_PERSISTS"
)

var AllFixApplicationStatus = []FixApplicationStatus{
	FixApplicationStatusAvailable,
	FixApplicationStatusApplying,
	FixApplicationStatusApplied,
	FixApplicationStatusFailed,
	FixApplicationStatusIssuePersists,
}

func (e FixApplicationStatus) IsValid() bool {
	switch e {
	case FixApplicationStatusAvailable, FixApplicationStatusApplying, FixApplicationStatusApplied, FixApplicationStatusFailed, FixApplicationStatusIssuePersists:
		return true
	}
	return false
}

func (e FixApplicationStatus) String() string {
	return string(e)
}

func (e *FixApplicationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FixApplicationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FixApplicationStatus", str)
	}
	return nil
}

func (e FixApplicationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Confidence level for a fix suggestion
type FixConfidence string

const (
	// High confidence this fix will resolve the issue
	FixConfidenceHigh FixConfidence = "HIGH"
	// Medium confidence, may resolve the issue
	FixConfidenceMedium FixConfidence = "MEDIUM"
	// Low confidence, worth trying as last resort
	FixConfidenceLow FixConfidence = "LOW"
)

var AllFixConfidence = []FixConfidence{
	FixConfidenceHigh,
	FixConfidenceMedium,
	FixConfidenceLow,
}

func (e FixConfidence) IsValid() bool {
	switch e {
	case FixConfidenceHigh, FixConfidenceMedium, FixConfidenceLow:
		return true
	}
	return false
}

func (e FixConfidence) String() string {
	return string(e)
}

func (e *FixConfidence) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FixConfidence(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FixConfidence", str)
	}
	return nil
}

func (e FixConfidence) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FrameTypes string

const (
	FrameTypesAdmitAll                     FrameTypes = "ADMIT_ALL"
	FrameTypesAdmitOnlyUntaggedAndPriority FrameTypes = "ADMIT_ONLY_UNTAGGED_AND_PRIORITY"
	FrameTypesAdmitOnlyVlanTagged          FrameTypes = "ADMIT_ONLY_VLAN_TAGGED"
)

var AllFrameTypes = []FrameTypes{
	FrameTypesAdmitAll,
	FrameTypesAdmitOnlyUntaggedAndPriority,
	FrameTypesAdmitOnlyVlanTagged,
}

func (e FrameTypes) IsValid() bool {
	switch e {
	case FrameTypesAdmitAll, FrameTypesAdmitOnlyUntaggedAndPriority, FrameTypesAdmitOnlyVlanTagged:
		return true
	}
	return false
}

func (e FrameTypes) String() string {
	return string(e)
}

func (e *FrameTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FrameTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FrameTypes", str)
	}
	return nil
}

func (e FrameTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Health check status
type HealthCheckStatus string

const (
	// Target is reachable (healthy)
	HealthCheckStatusHealthy HealthCheckStatus = "HEALTHY"
	// Target is unreachable (unhealthy)
	HealthCheckStatusUnhealthy HealthCheckStatus = "UNHEALTHY"
	// Health check is disabled
	HealthCheckStatusDisabled HealthCheckStatus = "DISABLED"
	// Health check is starting
	HealthCheckStatusUnknown HealthCheckStatus = "UNKNOWN"
)

var AllHealthCheckStatus = []HealthCheckStatus{
	HealthCheckStatusHealthy,
	HealthCheckStatusUnhealthy,
	HealthCheckStatusDisabled,
	HealthCheckStatusUnknown,
}

func (e HealthCheckStatus) IsValid() bool {
	switch e {
	case HealthCheckStatusHealthy, HealthCheckStatusUnhealthy, HealthCheckStatusDisabled, HealthCheckStatusUnknown:
		return true
	}
	return false
}

func (e HealthCheckStatus) String() string {
	return string(e)
}

func (e *HealthCheckStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthCheckStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthCheckStatus", str)
	}
	return nil
}

func (e HealthCheckStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a single hop in a traceroute
type HopStatus string

const (
	// Hop responded successfully
	HopStatusSuccess HopStatus = "SUCCESS"
	// Hop did not respond (timeout)
	HopStatusTimeout HopStatus = "TIMEOUT"
	// Destination unreachable at this hop
	HopStatusUnreachable HopStatus = "UNREACHABLE"
	// Access prohibited (firewall/ACL)
	HopStatusProhibited HopStatus = "PROHIBITED"
)

var AllHopStatus = []HopStatus{
	HopStatusSuccess,
	HopStatusTimeout,
	HopStatusUnreachable,
	HopStatusProhibited,
}

func (e HopStatus) IsValid() bool {
	switch e {
	case HopStatusSuccess, HopStatusTimeout, HopStatusUnreachable, HopStatusProhibited:
		return true
	}
	return false
}

func (e HopStatus) String() string {
	return string(e)
}

func (e *HopStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HopStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HopStatus", str)
	}
	return nil
}

func (e HopStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Operational status of a network interface
type InterfaceStatus string

const (
	// Interface is up and running
	InterfaceStatusUp InterfaceStatus = "UP"
	// Interface is down
	InterfaceStatusDown InterfaceStatus = "DOWN"
	// Interface is disabled
	InterfaceStatusDisabled InterfaceStatus = "DISABLED"
	// Status unknown or error
	InterfaceStatusUnknown InterfaceStatus = "UNKNOWN"
)

var AllInterfaceStatus = []InterfaceStatus{
	InterfaceStatusUp,
	InterfaceStatusDown,
	InterfaceStatusDisabled,
	InterfaceStatusUnknown,
}

func (e InterfaceStatus) IsValid() bool {
	switch e {
	case InterfaceStatusUp, InterfaceStatusDown, InterfaceStatusDisabled, InterfaceStatusUnknown:
		return true
	}
	return false
}

func (e InterfaceStatus) String() string {
	return string(e)
}

func (e *InterfaceStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfaceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InterfaceStatus", str)
	}
	return nil
}

func (e InterfaceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of network interfaces
type InterfaceType string

const (
	InterfaceTypeEthernet InterfaceType = "ETHERNET"
	InterfaceTypeVlan     InterfaceType = "VLAN"
	InterfaceTypeBridge   InterfaceType = "BRIDGE"
	InterfaceTypeWireless InterfaceType = "WIRELESS"
	InterfaceTypeTunnel   InterfaceType = "TUNNEL"
	InterfaceTypePpp      InterfaceType = "PPP"
	InterfaceTypeBonding  InterfaceType = "BONDING"
	InterfaceTypeLoopback InterfaceType = "LOOPBACK"
	InterfaceTypeVirtual  InterfaceType = "VIRTUAL"
	InterfaceTypeOther    InterfaceType = "OTHER"
)

var AllInterfaceType = []InterfaceType{
	InterfaceTypeEthernet,
	InterfaceTypeVlan,
	InterfaceTypeBridge,
	InterfaceTypeWireless,
	InterfaceTypeTunnel,
	InterfaceTypePpp,
	InterfaceTypeBonding,
	InterfaceTypeLoopback,
	InterfaceTypeVirtual,
	InterfaceTypeOther,
}

func (e InterfaceType) IsValid() bool {
	switch e {
	case InterfaceTypeEthernet, InterfaceTypeVlan, InterfaceTypeBridge, InterfaceTypeWireless, InterfaceTypeTunnel, InterfaceTypePpp, InterfaceTypeBonding, InterfaceTypeLoopback, InterfaceTypeVirtual, InterfaceTypeOther:
		return true
	}
	return false
}

func (e InterfaceType) String() string {
	return string(e)
}

func (e *InterfaceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfaceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InterfaceType", str)
	}
	return nil
}

func (e InterfaceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of IP address conflict
type IPConflictType string

const (
	// Exact IP address match on different interface
	IPConflictTypeExact IPConflictType = "EXACT"
	// IP addresses are in overlapping subnets
	IPConflictTypeSubnetOverlap IPConflictType = "SUBNET_OVERLAP"
	// IP is the broadcast address of another subnet
	IPConflictTypeBroadcast IPConflictType = "BROADCAST"
	// IP is the network address of another subnet
	IPConflictTypeNetwork IPConflictType = "NETWORK"
)

var AllIPConflictType = []IPConflictType{
	IPConflictTypeExact,
	IPConflictTypeSubnetOverlap,
	IPConflictTypeBroadcast,
	IPConflictTypeNetwork,
}

func (e IPConflictType) IsValid() bool {
	switch e {
	case IPConflictTypeExact, IPConflictTypeSubnetOverlap, IPConflictTypeBroadcast, IPConflictTypeNetwork:
		return true
	}
	return false
}

func (e IPConflictType) String() string {
	return string(e)
}

func (e *IPConflictType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPConflictType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpConflictType", str)
	}
	return nil
}

func (e IPConflictType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Job status for async traceroute execution
type JobStatus string

const (
	// Job has been created
	JobStatusStarted JobStatus = "STARTED"
	// Job is currently running
	JobStatusRunning JobStatus = "RUNNING"
	// Job completed successfully
	JobStatusComplete JobStatus = "COMPLETE"
	// Job was cancelled by user
	JobStatusCancelled JobStatus = "CANCELLED"
	// Job encountered an error
	JobStatusError JobStatus = "ERROR"
)

var AllJobStatus = []JobStatus{
	JobStatusStarted,
	JobStatusRunning,
	JobStatusComplete,
	JobStatusCancelled,
	JobStatusError,
}

func (e JobStatus) IsValid() bool {
	switch e {
	case JobStatusStarted, JobStatusRunning, JobStatusComplete, JobStatusCancelled, JobStatusError:
		return true
	}
	return false
}

func (e JobStatus) String() string {
	return string(e)
}

func (e *JobStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobStatus", str)
	}
	return nil
}

func (e JobStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Protocol for knock port.
type KnockProtocol string

const (
	// TCP only
	KnockProtocolTCP KnockProtocol = "TCP"
	// UDP only
	KnockProtocolUDP KnockProtocol = "UDP"
	// Both TCP and UDP
	KnockProtocolBoth KnockProtocol = "BOTH"
)

var AllKnockProtocol = []KnockProtocol{
	KnockProtocolTCP,
	KnockProtocolUDP,
	KnockProtocolBoth,
}

func (e KnockProtocol) IsValid() bool {
	switch e {
	case KnockProtocolTCP, KnockProtocolUDP, KnockProtocolBoth:
		return true
	}
	return false
}

func (e KnockProtocol) String() string {
	return string(e)
}

func (e *KnockProtocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KnockProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KnockProtocol", str)
	}
	return nil
}

func (e KnockProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of knock attempt.
type KnockStatus string

const (
	// All ports hit correctly, access granted
	KnockStatusSuccess KnockStatus = "SUCCESS"
	// Wrong port order
	KnockStatusFailed KnockStatus = "FAILED"
	// Some ports hit, sequence incomplete
	KnockStatusPartial KnockStatus = "PARTIAL"
	// Time between knocks exceeded
	KnockStatusTimeout KnockStatus = "TIMEOUT"
)

var AllKnockStatus = []KnockStatus{
	KnockStatusSuccess,
	KnockStatusFailed,
	KnockStatusPartial,
	KnockStatusTimeout,
}

func (e KnockStatus) IsValid() bool {
	switch e {
	case KnockStatusSuccess, KnockStatusFailed, KnockStatusPartial, KnockStatusTimeout:
		return true
	}
	return false
}

func (e KnockStatus) String() string {
	return string(e)
}

func (e *KnockStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KnockStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KnockStatus", str)
	}
	return nil
}

func (e KnockStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Direction of traffic to mirror
type MirrorDirection string

const (
	// Mirror only ingress (incoming) traffic
	MirrorDirectionIngress MirrorDirection = "INGRESS"
	// Mirror only egress (outgoing) traffic
	MirrorDirectionEgress MirrorDirection = "EGRESS"
	// Mirror both ingress and egress traffic
	MirrorDirectionBoth MirrorDirection = "BOTH"
)

var AllMirrorDirection = []MirrorDirection{
	MirrorDirectionIngress,
	MirrorDirectionEgress,
	MirrorDirectionBoth,
}

func (e MirrorDirection) IsValid() bool {
	switch e {
	case MirrorDirectionIngress, MirrorDirectionEgress, MirrorDirectionBoth:
		return true
	}
	return false
}

func (e MirrorDirection) String() string {
	return string(e)
}

func (e *MirrorDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MirrorDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MirrorDirection", str)
	}
	return nil
}

func (e MirrorDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// NAT action types for firewall NAT rules.
type NatAction string

const (
	// Masquerade (dynamic source NAT)
	NatActionMasquerade NatAction = "MASQUERADE"
	// Destination NAT (port forwarding)
	NatActionDstNat NatAction = "DST_NAT"
	// Source NAT (static mapping)
	NatActionSrcNat NatAction = "SRC_NAT"
	// Redirect to different port
	NatActionRedirect NatAction = "REDIRECT"
	// Network mapping
	NatActionNetmap NatAction = "NETMAP"
	// Use same IP
	NatActionSame NatAction = "SAME"
	// Accept packet
	NatActionAccept NatAction = "ACCEPT"
	// Drop packet
	NatActionDrop NatAction = "DROP"
	// Jump to different chain
	NatActionJump NatAction = "JUMP"
	// Return to parent chain
	NatActionReturn NatAction = "RETURN"
	// Log packet
	NatActionLog NatAction = "LOG"
	// Pass through without action
	NatActionPassthrough NatAction = "PASSTHROUGH"
)

var AllNatAction = []NatAction{
	NatActionMasquerade,
	NatActionDstNat,
	NatActionSrcNat,
	NatActionRedirect,
	NatActionNetmap,
	NatActionSame,
	NatActionAccept,
	NatActionDrop,
	NatActionJump,
	NatActionReturn,
	NatActionLog,
	NatActionPassthrough,
}

func (e NatAction) IsValid() bool {
	switch e {
	case NatActionMasquerade, NatActionDstNat, NatActionSrcNat, NatActionRedirect, NatActionNetmap, NatActionSame, NatActionAccept, NatActionDrop, NatActionJump, NatActionReturn, NatActionLog, NatActionPassthrough:
		return true
	}
	return false
}

func (e NatAction) String() string {
	return string(e)
}

func (e *NatAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NatAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NatAction", str)
	}
	return nil
}

func (e NatAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// NAT chain types (srcnat for source NAT, dstnat for destination NAT).
type NatChain string

const (
	// Source NAT (outgoing traffic)
	NatChainSrcnat NatChain = "SRCNAT"
	// Destination NAT (incoming traffic)
	NatChainDstnat NatChain = "DSTNAT"
)

var AllNatChain = []NatChain{
	NatChainSrcnat,
	NatChainDstnat,
}

func (e NatChain) IsValid() bool {
	switch e {
	case NatChainSrcnat, NatChainDstnat:
		return true
	}
	return false
}

func (e NatChain) String() string {
	return string(e)
}

func (e *NatChain) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NatChain(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NatChain", str)
	}
	return nil
}

func (e NatChain) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification channel types
type NotificationChannel string

const (
	// Email notifications
	NotificationChannelEmail NotificationChannel = "EMAIL"
	// Telegram notifications
	NotificationChannelTelegram NotificationChannel = "TELEGRAM"
	// Pushover notifications
	NotificationChannelPushover NotificationChannel = "PUSHOVER"
	// Webhook notifications
	NotificationChannelWebhook NotificationChannel = "WEBHOOK"
	// In-app notifications
	NotificationChannelInapp NotificationChannel = "INAPP"
)

var AllNotificationChannel = []NotificationChannel{
	NotificationChannelEmail,
	NotificationChannelTelegram,
	NotificationChannelPushover,
	NotificationChannelWebhook,
	NotificationChannelInapp,
}

func (e NotificationChannel) IsValid() bool {
	switch e {
	case NotificationChannelEmail, NotificationChannelTelegram, NotificationChannelPushover, NotificationChannelWebhook, NotificationChannelInapp:
		return true
	}
	return false
}

func (e NotificationChannel) String() string {
	return string(e)
}

func (e *NotificationChannel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationChannel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationChannel", str)
	}
	return nil
}

func (e NotificationChannel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Notification delivery status
type NotificationStatus string

const (
	// Delivery pending
	NotificationStatusPending NotificationStatus = "PENDING"
	// Successfully delivered
	NotificationStatusSuccess NotificationStatus = "SUCCESS"
	// Delivery failed
	NotificationStatusFailed NotificationStatus = "FAILED"
	// Retrying after failure
	NotificationStatusRetrying NotificationStatus = "RETRYING"
)

var AllNotificationStatus = []NotificationStatus{
	NotificationStatusPending,
	NotificationStatusSuccess,
	NotificationStatusFailed,
	NotificationStatusRetrying,
}

func (e NotificationStatus) IsValid() bool {
	switch e {
	case NotificationStatusPending, NotificationStatusSuccess, NotificationStatusFailed, NotificationStatusRetrying:
		return true
	}
	return false
}

func (e NotificationStatus) String() string {
	return string(e)
}

func (e *NotificationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationStatus", str)
	}
	return nil
}

func (e NotificationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a port forward configuration.
type PortForwardStatus string

const (
	// Port forward is active and working
	PortForwardStatusActive PortForwardStatus = "ACTIVE"
	// Port forward is disabled
	PortForwardStatusDisabled PortForwardStatus = "DISABLED"
	// Port forward has errors or misconfiguration
	PortForwardStatusError PortForwardStatus = "ERROR"
	// Port forward is partially configured (missing rules)
	PortForwardStatusIncomplete PortForwardStatus = "INCOMPLETE"
)

var AllPortForwardStatus = []PortForwardStatus{
	PortForwardStatusActive,
	PortForwardStatusDisabled,
	PortForwardStatusError,
	PortForwardStatusIncomplete,
}

func (e PortForwardStatus) IsValid() bool {
	switch e {
	case PortForwardStatusActive, PortForwardStatusDisabled, PortForwardStatusError, PortForwardStatusIncomplete:
		return true
	}
	return false
}

func (e PortForwardStatus) String() string {
	return string(e)
}

func (e *PortForwardStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PortForwardStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PortForwardStatus", str)
	}
	return nil
}

func (e PortForwardStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Port mode for VLAN configuration
type PortMode string

const (
	// Trunk port (carries multiple VLANs with tagging)
	PortModeTrunk PortMode = "TRUNK"
	// Access port (single VLAN, untagged)
	PortModeAccess PortMode = "ACCESS"
)

var AllPortMode = []PortMode{
	PortModeTrunk,
	PortModeAccess,
}

func (e PortMode) IsValid() bool {
	switch e {
	case PortModeTrunk, PortModeAccess:
		return true
	}
	return false
}

func (e PortMode) String() string {
	return string(e)
}

func (e *PortMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PortMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PortMode", str)
	}
	return nil
}

func (e PortMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Protocol used for router communication
type Protocol string

const (
	// REST API protocol (RouterOS 7.1+)
	ProtocolRest Protocol = "REST"
	// Binary API protocol (port 8728)
	ProtocolAPI Protocol = "API"
	// TLS-encrypted binary API (port 8729)
	ProtocolAPISsl Protocol = "API_SSL"
	// SSH protocol (port 22)
	ProtocolSSH Protocol = "SSH"
	// Telnet protocol (port 23)
	ProtocolTelnet Protocol = "TELNET"
)

var AllProtocol = []Protocol{
	ProtocolRest,
	ProtocolAPI,
	ProtocolAPISsl,
	ProtocolSSH,
	ProtocolTelnet,
}

func (e Protocol) IsValid() bool {
	switch e {
	case ProtocolRest, ProtocolAPI, ProtocolAPISsl, ProtocolSSH, ProtocolTelnet:
		return true
	}
	return false
}

func (e Protocol) String() string {
	return string(e)
}

func (e *Protocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Protocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Protocol", str)
	}
	return nil
}

func (e Protocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// User preference for which protocol to use when connecting to a router.
// AUTO will try protocols in the recommended fallback order.
type ProtocolPreference string

const (
	// Automatically detect best protocol (REST -> API -> API_SSL -> SSH -> Telnet)
	ProtocolPreferenceAuto ProtocolPreference = "AUTO"
	// Force REST API protocol (RouterOS 7.1+)
	ProtocolPreferenceRest ProtocolPreference = "REST"
	// Force Binary API protocol (port 8728)
	ProtocolPreferenceAPI ProtocolPreference = "API"
	// Force TLS-encrypted binary API (port 8729)
	ProtocolPreferenceAPISsl ProtocolPreference = "API_SSL"
	// Force SSH protocol (port 22)
	ProtocolPreferenceSSH ProtocolPreference = "SSH"
	// Force Telnet protocol (port 23, insecure - use only as last resort)
	ProtocolPreferenceTelnet ProtocolPreference = "TELNET"
)

var AllProtocolPreference = []ProtocolPreference{
	ProtocolPreferenceAuto,
	ProtocolPreferenceRest,
	ProtocolPreferenceAPI,
	ProtocolPreferenceAPISsl,
	ProtocolPreferenceSSH,
	ProtocolPreferenceTelnet,
}

func (e ProtocolPreference) IsValid() bool {
	switch e {
	case ProtocolPreferenceAuto, ProtocolPreferenceRest, ProtocolPreferenceAPI, ProtocolPreferenceAPISsl, ProtocolPreferenceSSH, ProtocolPreferenceTelnet:
		return true
	}
	return false
}

func (e ProtocolPreference) String() string {
	return string(e)
}

func (e *ProtocolPreference) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProtocolPreference(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProtocolPreference", str)
	}
	return nil
}

func (e ProtocolPreference) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Categories of managed resources
type ResourceCategory string

const (
	// Network topology: WAN Links, LAN Networks, VLANs
	ResourceCategoryNetwork ResourceCategory = "NETWORK"
	// VPN connectivity: WireGuard, OpenVPN, IPsec
	ResourceCategoryVpn ResourceCategory = "VPN"
	// System infrastructure: Certificates, NTP, DDNS
	ResourceCategoryInfrastructure ResourceCategory = "INFRASTRUCTURE"
	// Application-level: Port Forwarding, Game Rules
	ResourceCategoryApplication ResourceCategory = "APPLICATION"
	// Marketplace features: Tor, AdGuard, sing-box
	ResourceCategoryFeature ResourceCategory = "FEATURE"
	// Community extensions: Third-party plugins
	ResourceCategoryPlugin ResourceCategory = "PLUGIN"
)

var AllResourceCategory = []ResourceCategory{
	ResourceCategoryNetwork,
	ResourceCategoryVpn,
	ResourceCategoryInfrastructure,
	ResourceCategoryApplication,
	ResourceCategoryFeature,
	ResourceCategoryPlugin,
}

func (e ResourceCategory) IsValid() bool {
	switch e {
	case ResourceCategoryNetwork, ResourceCategoryVpn, ResourceCategoryInfrastructure, ResourceCategoryApplication, ResourceCategoryFeature, ResourceCategoryPlugin:
		return true
	}
	return false
}

func (e ResourceCategory) String() string {
	return string(e)
}

func (e *ResourceCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceCategory", str)
	}
	return nil
}

func (e ResourceCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Impact level for affected resources
type ResourceImpact string

const (
	// Resource will be modified
	ResourceImpactModified ResourceImpact = "MODIFIED"
	// Resource will be disabled
	ResourceImpactDisabled ResourceImpact = "DISABLED"
	// Resource will be removed
	ResourceImpactRemoved ResourceImpact = "REMOVED"
	// Connections will be dropped
	ResourceImpactConnectionDrop ResourceImpact = "CONNECTION_DROP"
)

var AllResourceImpact = []ResourceImpact{
	ResourceImpactModified,
	ResourceImpactDisabled,
	ResourceImpactRemoved,
	ResourceImpactConnectionDrop,
}

func (e ResourceImpact) IsValid() bool {
	switch e {
	case ResourceImpactModified, ResourceImpactDisabled, ResourceImpactRemoved, ResourceImpactConnectionDrop:
		return true
	}
	return false
}

func (e ResourceImpact) String() string {
	return string(e)
}

func (e *ResourceImpact) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceImpact(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceImpact", str)
	}
	return nil
}

func (e ResourceImpact) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Selectable resource layers for optimized fetching
type ResourceLayer string

const (
	ResourceLayerConfiguration ResourceLayer = "CONFIGURATION"
	ResourceLayerValidation    ResourceLayer = "VALIDATION"
	ResourceLayerDeployment    ResourceLayer = "DEPLOYMENT"
	ResourceLayerRuntime       ResourceLayer = "RUNTIME"
	ResourceLayerTelemetry     ResourceLayer = "TELEMETRY"
	ResourceLayerMetadata      ResourceLayer = "METADATA"
	ResourceLayerRelationships ResourceLayer = "RELATIONSHIPS"
	ResourceLayerPlatform      ResourceLayer = "PLATFORM"
)

var AllResourceLayer = []ResourceLayer{
	ResourceLayerConfiguration,
	ResourceLayerValidation,
	ResourceLayerDeployment,
	ResourceLayerRuntime,
	ResourceLayerTelemetry,
	ResourceLayerMetadata,
	ResourceLayerRelationships,
	ResourceLayerPlatform,
}

func (e ResourceLayer) IsValid() bool {
	switch e {
	case ResourceLayerConfiguration, ResourceLayerValidation, ResourceLayerDeployment, ResourceLayerRuntime, ResourceLayerTelemetry, ResourceLayerMetadata, ResourceLayerRelationships, ResourceLayerPlatform:
		return true
	}
	return false
}

func (e ResourceLayer) String() string {
	return string(e)
}

func (e *ResourceLayer) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceLayer(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceLayer", str)
	}
	return nil
}

func (e ResourceLayer) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Resource lifecycle states for state machine
type ResourceLifecycleState string

const (
	// Initial creation, not yet validated
	ResourceLifecycleStateDraft ResourceLifecycleState = "DRAFT"
	// Backend validation in progress
	ResourceLifecycleStateValidating ResourceLifecycleState = "VALIDATING"
	// Passed validation, ready to apply
	ResourceLifecycleStateValid ResourceLifecycleState = "VALID"
	// Being applied to router
	ResourceLifecycleStateApplying ResourceLifecycleState = "APPLYING"
	// Successfully applied and running
	ResourceLifecycleStateActive ResourceLifecycleState = "ACTIVE"
	// Running but with issues
	ResourceLifecycleStateDegraded ResourceLifecycleState = "DEGRADED"
	// Failed state (validation or apply)
	ResourceLifecycleStateError ResourceLifecycleState = "ERROR"
	// Marked for removal
	ResourceLifecycleStateDeprecated ResourceLifecycleState = "DEPRECATED"
	// Final state, no longer active
	ResourceLifecycleStateArchived ResourceLifecycleState = "ARCHIVED"
)

var AllResourceLifecycleState = []ResourceLifecycleState{
	ResourceLifecycleStateDraft,
	ResourceLifecycleStateValidating,
	ResourceLifecycleStateValid,
	ResourceLifecycleStateApplying,
	ResourceLifecycleStateActive,
	ResourceLifecycleStateDegraded,
	ResourceLifecycleStateError,
	ResourceLifecycleStateDeprecated,
	ResourceLifecycleStateArchived,
}

func (e ResourceLifecycleState) IsValid() bool {
	switch e {
	case ResourceLifecycleStateDraft, ResourceLifecycleStateValidating, ResourceLifecycleStateValid, ResourceLifecycleStateApplying, ResourceLifecycleStateActive, ResourceLifecycleStateDegraded, ResourceLifecycleStateError, ResourceLifecycleStateDeprecated, ResourceLifecycleStateArchived:
		return true
	}
	return false
}

func (e ResourceLifecycleState) String() string {
	return string(e)
}

func (e *ResourceLifecycleState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceLifecycleState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceLifecycleState", str)
	}
	return nil
}

func (e ResourceLifecycleState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Types of relationships between resources
type ResourceRelationshipType string

const (
	// Child depends on parent
	ResourceRelationshipTypeDependsOn ResourceRelationshipType = "DEPENDS_ON"
	// Traffic routes via this resource
	ResourceRelationshipTypeRoutesVia ResourceRelationshipType = "ROUTES_VIA"
	// Parent-child hierarchy
	ResourceRelationshipTypeParentChild ResourceRelationshipType = "PARENT_CHILD"
	// Resources are in the same group
	ResourceRelationshipTypeGroup ResourceRelationshipType = "GROUP"
	// Custom relationship
	ResourceRelationshipTypeCustom ResourceRelationshipType = "CUSTOM"
)

var AllResourceRelationshipType = []ResourceRelationshipType{
	ResourceRelationshipTypeDependsOn,
	ResourceRelationshipTypeRoutesVia,
	ResourceRelationshipTypeParentChild,
	ResourceRelationshipTypeGroup,
	ResourceRelationshipTypeCustom,
}

func (e ResourceRelationshipType) IsValid() bool {
	switch e {
	case ResourceRelationshipTypeDependsOn, ResourceRelationshipTypeRoutesVia, ResourceRelationshipTypeParentChild, ResourceRelationshipTypeGroup, ResourceRelationshipTypeCustom:
		return true
	}
	return false
}

func (e ResourceRelationshipType) String() string {
	return string(e)
}

func (e *ResourceRelationshipType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceRelationshipType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceRelationshipType", str)
	}
	return nil
}

func (e ResourceRelationshipType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Rollback operation type
type RollbackOperation string

const (
	// Delete a created resource
	RollbackOperationDelete RollbackOperation = "DELETE"
	// Restore a deleted resource
	RollbackOperationRestore RollbackOperation = "RESTORE"
	// Revert an updated resource
	RollbackOperationRevert RollbackOperation = "REVERT"
)

var AllRollbackOperation = []RollbackOperation{
	RollbackOperationDelete,
	RollbackOperationRestore,
	RollbackOperationRevert,
}

func (e RollbackOperation) IsValid() bool {
	switch e {
	case RollbackOperationDelete, RollbackOperationRestore, RollbackOperationRevert:
		return true
	}
	return false
}

func (e RollbackOperation) String() string {
	return string(e)
}

func (e *RollbackOperation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RollbackOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RollbackOperation", str)
	}
	return nil
}

func (e RollbackOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Route scope
type RouteScope string

const (
	// Global route (forwarded between interfaces)
	RouteScopeGlobal RouteScope = "GLOBAL"
	// Link-local route (not forwarded)
	RouteScopeLink RouteScope = "LINK"
	// Host-local route
	RouteScopeHost RouteScope = "HOST"
)

var AllRouteScope = []RouteScope{
	RouteScopeGlobal,
	RouteScopeLink,
	RouteScopeHost,
}

func (e RouteScope) IsValid() bool {
	switch e {
	case RouteScopeGlobal, RouteScopeLink, RouteScopeHost:
		return true
	}
	return false
}

func (e RouteScope) String() string {
	return string(e)
}

func (e *RouteScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RouteScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RouteScope", str)
	}
	return nil
}

func (e RouteScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Route type classification
type RouteType string

const (
	// Static route (manually configured)
	RouteTypeStatic RouteType = "STATIC"
	// Connected route (directly connected network)
	RouteTypeConnected RouteType = "CONNECTED"
	// Dynamic route (learned via routing protocol)
	RouteTypeDynamic RouteType = "DYNAMIC"
	// BGP route
	RouteTypeBgp RouteType = "BGP"
	// OSPF route
	RouteTypeOspf RouteType = "OSPF"
)

var AllRouteType = []RouteType{
	RouteTypeStatic,
	RouteTypeConnected,
	RouteTypeDynamic,
	RouteTypeBgp,
	RouteTypeOspf,
}

func (e RouteType) IsValid() bool {
	switch e {
	case RouteTypeStatic, RouteTypeConnected, RouteTypeDynamic, RouteTypeBgp, RouteTypeOspf:
		return true
	}
	return false
}

func (e RouteType) String() string {
	return string(e)
}

func (e *RouteType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RouteType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RouteType", str)
	}
	return nil
}

func (e RouteType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported router platforms
type RouterPlatform string

const (
	// MikroTik RouterOS
	RouterPlatformMikrotik RouterPlatform = "MIKROTIK"
	// OpenWrt
	RouterPlatformOpenwrt RouterPlatform = "OPENWRT"
	// VyOS
	RouterPlatformVyos RouterPlatform = "VYOS"
	// Generic/Unknown
	RouterPlatformGeneric RouterPlatform = "GENERIC"
)

var AllRouterPlatform = []RouterPlatform{
	RouterPlatformMikrotik,
	RouterPlatformOpenwrt,
	RouterPlatformVyos,
	RouterPlatformGeneric,
}

func (e RouterPlatform) IsValid() bool {
	switch e {
	case RouterPlatformMikrotik, RouterPlatformOpenwrt, RouterPlatformVyos, RouterPlatformGeneric:
		return true
	}
	return false
}

func (e RouterPlatform) String() string {
	return string(e)
}

func (e *RouterPlatform) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RouterPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RouterPlatform", str)
	}
	return nil
}

func (e RouterPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Runtime health status
type RuntimeHealth string

const (
	// Resource is healthy and operating normally
	RuntimeHealthHealthy RuntimeHealth = "HEALTHY"
	// Resource is running but with warnings
	RuntimeHealthWarning RuntimeHealth = "WARNING"
	// Resource is running but degraded
	RuntimeHealthDegraded RuntimeHealth = "DEGRADED"
	// Resource has failed
	RuntimeHealthFailed RuntimeHealth = "FAILED"
	// Health status unknown
	RuntimeHealthUnknown RuntimeHealth = "UNKNOWN"
)

var AllRuntimeHealth = []RuntimeHealth{
	RuntimeHealthHealthy,
	RuntimeHealthWarning,
	RuntimeHealthDegraded,
	RuntimeHealthFailed,
	RuntimeHealthUnknown,
}

func (e RuntimeHealth) IsValid() bool {
	switch e {
	case RuntimeHealthHealthy, RuntimeHealthWarning, RuntimeHealthDegraded, RuntimeHealthFailed, RuntimeHealthUnknown:
		return true
	}
	return false
}

func (e RuntimeHealth) String() string {
	return string(e)
}

func (e *RuntimeHealth) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuntimeHealth(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuntimeHealth", str)
	}
	return nil
}

func (e RuntimeHealth) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a network scan operation
type ScanStatus string

const (
	// Scan is queued and waiting to start
	ScanStatusPending ScanStatus = "PENDING"
	// Scan is actively running
	ScanStatusRunning ScanStatus = "RUNNING"
	// Scan completed successfully
	ScanStatusCompleted ScanStatus = "COMPLETED"
	// Scan was cancelled by user
	ScanStatusCancelled ScanStatus = "CANCELLED"
	// Scan failed with an error
	ScanStatusFailed ScanStatus = "FAILED"
)

var AllScanStatus = []ScanStatus{
	ScanStatusPending,
	ScanStatusRunning,
	ScanStatusCompleted,
	ScanStatusCancelled,
	ScanStatusFailed,
}

func (e ScanStatus) IsValid() bool {
	switch e {
	case ScanStatusPending, ScanStatusRunning, ScanStatusCompleted, ScanStatusCancelled, ScanStatusFailed:
		return true
	}
	return false
}

func (e ScanStatus) String() string {
	return string(e)
}

func (e *ScanStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScanStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScanStatus", str)
	}
	return nil
}

func (e ScanStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Service operational status
type ServiceStatus string

const (
	// Service is fully operational
	ServiceStatusHealthy ServiceStatus = "HEALTHY"
	// Service is operational with degraded performance
	ServiceStatusDegraded ServiceStatus = "DEGRADED"
	// Service is not operational
	ServiceStatusUnhealthy ServiceStatus = "UNHEALTHY"
)

var AllServiceStatus = []ServiceStatus{
	ServiceStatusHealthy,
	ServiceStatusDegraded,
	ServiceStatusUnhealthy,
}

func (e ServiceStatus) IsValid() bool {
	switch e {
	case ServiceStatusHealthy, ServiceStatusDegraded, ServiceStatusUnhealthy:
		return true
	}
	return false
}

func (e ServiceStatus) String() string {
	return string(e)
}

func (e *ServiceStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceStatus", str)
	}
	return nil
}

func (e ServiceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StpPortRole string

const (
	StpPortRoleRoot       StpPortRole = "ROOT"
	StpPortRoleDesignated StpPortRole = "DESIGNATED"
	StpPortRoleAlternate  StpPortRole = "ALTERNATE"
	StpPortRoleBackup     StpPortRole = "BACKUP"
	StpPortRoleDisabled   StpPortRole = "DISABLED"
)

var AllStpPortRole = []StpPortRole{
	StpPortRoleRoot,
	StpPortRoleDesignated,
	StpPortRoleAlternate,
	StpPortRoleBackup,
	StpPortRoleDisabled,
}

func (e StpPortRole) IsValid() bool {
	switch e {
	case StpPortRoleRoot, StpPortRoleDesignated, StpPortRoleAlternate, StpPortRoleBackup, StpPortRoleDisabled:
		return true
	}
	return false
}

func (e StpPortRole) String() string {
	return string(e)
}

func (e *StpPortRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StpPortRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StpPortRole", str)
	}
	return nil
}

func (e StpPortRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StpPortState string

const (
	StpPortStateDisabled   StpPortState = "DISABLED"
	StpPortStateBlocking   StpPortState = "BLOCKING"
	StpPortStateListening  StpPortState = "LISTENING"
	StpPortStateLearning   StpPortState = "LEARNING"
	StpPortStateForwarding StpPortState = "FORWARDING"
)

var AllStpPortState = []StpPortState{
	StpPortStateDisabled,
	StpPortStateBlocking,
	StpPortStateListening,
	StpPortStateLearning,
	StpPortStateForwarding,
}

func (e StpPortState) IsValid() bool {
	switch e {
	case StpPortStateDisabled, StpPortStateBlocking, StpPortStateListening, StpPortStateLearning, StpPortStateForwarding:
		return true
	}
	return false
}

func (e StpPortState) String() string {
	return string(e)
}

func (e *StpPortState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StpPortState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StpPortState", str)
	}
	return nil
}

func (e StpPortState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StpProtocol string

const (
	StpProtocolNone StpProtocol = "NONE"
	StpProtocolStp  StpProtocol = "STP"
	StpProtocolRstp StpProtocol = "RSTP"
	StpProtocolMstp StpProtocol = "MSTP"
)

var AllStpProtocol = []StpProtocol{
	StpProtocolNone,
	StpProtocolStp,
	StpProtocolRstp,
	StpProtocolMstp,
}

func (e StpProtocol) IsValid() bool {
	switch e {
	case StpProtocolNone, StpProtocolStp, StpProtocolRstp, StpProtocolMstp:
		return true
	}
	return false
}

func (e StpProtocol) String() string {
	return string(e)
}

func (e *StpProtocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StpProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StpProtocol", str)
	}
	return nil
}

func (e StpProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Severity level for diagnostic suggestions
type SuggestionSeverity string

const (
	// Informational message, no action required
	SuggestionSeverityInfo SuggestionSeverity = "INFO"
	// Warning that may affect functionality
	SuggestionSeverityWarning SuggestionSeverity = "WARNING"
	// Error that needs to be addressed
	SuggestionSeverityError SuggestionSeverity = "ERROR"
	// Critical issue blocking connectivity
	SuggestionSeverityCritical SuggestionSeverity = "CRITICAL"
)

var AllSuggestionSeverity = []SuggestionSeverity{
	SuggestionSeverityInfo,
	SuggestionSeverityWarning,
	SuggestionSeverityError,
	SuggestionSeverityCritical,
}

func (e SuggestionSeverity) IsValid() bool {
	switch e {
	case SuggestionSeverityInfo, SuggestionSeverityWarning, SuggestionSeverityError, SuggestionSeverityCritical:
		return true
	}
	return false
}

func (e SuggestionSeverity) String() string {
	return string(e)
}

func (e *SuggestionSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SuggestionSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SuggestionSeverity", str)
	}
	return nil
}

func (e SuggestionSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Template categories for organization.
type TemplateCategory string

const (
	// Basic security rules
	TemplateCategoryBasic TemplateCategory = "BASIC"
	// Home network configurations
	TemplateCategoryHome TemplateCategory = "HOME"
	// Gaming-optimized rules
	TemplateCategoryGaming TemplateCategory = "GAMING"
	// IoT device isolation
	TemplateCategoryIot TemplateCategory = "IOT"
	// Guest network access
	TemplateCategoryGuest TemplateCategory = "GUEST"
	// User-created custom templates
	TemplateCategoryCustom TemplateCategory = "CUSTOM"
)

var AllTemplateCategory = []TemplateCategory{
	TemplateCategoryBasic,
	TemplateCategoryHome,
	TemplateCategoryGaming,
	TemplateCategoryIot,
	TemplateCategoryGuest,
	TemplateCategoryCustom,
}

func (e TemplateCategory) IsValid() bool {
	switch e {
	case TemplateCategoryBasic, TemplateCategoryHome, TemplateCategoryGaming, TemplateCategoryIot, TemplateCategoryGuest, TemplateCategoryCustom:
		return true
	}
	return false
}

func (e TemplateCategory) String() string {
	return string(e)
}

func (e *TemplateCategory) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateCategory", str)
	}
	return nil
}

func (e TemplateCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Template complexity levels.
type TemplateComplexity string

const (
	// Simple templates with few rules
	TemplateComplexitySimple TemplateComplexity = "SIMPLE"
	// Moderate complexity
	TemplateComplexityModerate TemplateComplexity = "MODERATE"
	// Advanced templates with many rules
	TemplateComplexityAdvanced TemplateComplexity = "ADVANCED"
)

var AllTemplateComplexity = []TemplateComplexity{
	TemplateComplexitySimple,
	TemplateComplexityModerate,
	TemplateComplexityAdvanced,
}

func (e TemplateComplexity) IsValid() bool {
	switch e {
	case TemplateComplexitySimple, TemplateComplexityModerate, TemplateComplexityAdvanced:
		return true
	}
	return false
}

func (e TemplateComplexity) String() string {
	return string(e)
}

func (e *TemplateComplexity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateComplexity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateComplexity", str)
	}
	return nil
}

func (e TemplateComplexity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Conflict types between template and existing configuration.
type TemplateConflictType string

const (
	// Duplicate rule already exists
	TemplateConflictTypeDuplicateRule TemplateConflictType = "DUPLICATE_RULE"
	// IP address range overlaps
	TemplateConflictTypeIPOverlap TemplateConflictType = "IP_OVERLAP"
	// Chain configuration conflicts
	TemplateConflictTypeChainConflict TemplateConflictType = "CHAIN_CONFLICT"
	// Position conflict in chain
	TemplateConflictTypePositionConflict TemplateConflictType = "POSITION_CONFLICT"
)

var AllTemplateConflictType = []TemplateConflictType{
	TemplateConflictTypeDuplicateRule,
	TemplateConflictTypeIPOverlap,
	TemplateConflictTypeChainConflict,
	TemplateConflictTypePositionConflict,
}

func (e TemplateConflictType) IsValid() bool {
	switch e {
	case TemplateConflictTypeDuplicateRule, TemplateConflictTypeIPOverlap, TemplateConflictTypeChainConflict, TemplateConflictTypePositionConflict:
		return true
	}
	return false
}

func (e TemplateConflictType) String() string {
	return string(e)
}

func (e *TemplateConflictType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateConflictType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateConflictType", str)
	}
	return nil
}

func (e TemplateConflictType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Type of topology node
type TopologyNodeType string

const (
	// Bridge interface
	TopologyNodeTypeBridge TopologyNodeType = "BRIDGE"
	// VLAN interface
	TopologyNodeTypeVlan TopologyNodeType = "VLAN"
	// Physical port
	TopologyNodeTypePort TopologyNodeType = "PORT"
)

var AllTopologyNodeType = []TopologyNodeType{
	TopologyNodeTypeBridge,
	TopologyNodeTypeVlan,
	TopologyNodeTypePort,
}

func (e TopologyNodeType) IsValid() bool {
	switch e {
	case TopologyNodeTypeBridge, TopologyNodeTypeVlan, TopologyNodeTypePort:
		return true
	}
	return false
}

func (e TopologyNodeType) String() string {
	return string(e)
}

func (e *TopologyNodeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TopologyNodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TopologyNodeType", str)
	}
	return nil
}

func (e TopologyNodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Event type for traceroute progress updates
type TracerouteEventType string

const (
	// A new hop was discovered
	TracerouteEventTypeHopDiscovered TracerouteEventType = "HOP_DISCOVERED"
	// Traceroute completed
	TracerouteEventTypeComplete TracerouteEventType = "COMPLETE"
	// Traceroute encountered an error
	TracerouteEventTypeError TracerouteEventType = "ERROR"
	// Traceroute was cancelled
	TracerouteEventTypeCancelled TracerouteEventType = "CANCELLED"
)

var AllTracerouteEventType = []TracerouteEventType{
	TracerouteEventTypeHopDiscovered,
	TracerouteEventTypeComplete,
	TracerouteEventTypeError,
	TracerouteEventTypeCancelled,
}

func (e TracerouteEventType) IsValid() bool {
	switch e {
	case TracerouteEventTypeHopDiscovered, TracerouteEventTypeComplete, TracerouteEventTypeError, TracerouteEventTypeCancelled:
		return true
	}
	return false
}

func (e TracerouteEventType) String() string {
	return string(e)
}

func (e *TracerouteEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TracerouteEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TracerouteEventType", str)
	}
	return nil
}

func (e TracerouteEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Protocol to use for traceroute probes
type TracerouteProtocol string

const (
	// ICMP echo request (default)
	TracerouteProtocolICMP TracerouteProtocol = "ICMP"
	// UDP probes
	TracerouteProtocolUDP TracerouteProtocol = "UDP"
	// TCP SYN probes
	TracerouteProtocolTCP TracerouteProtocol = "TCP"
)

var AllTracerouteProtocol = []TracerouteProtocol{
	TracerouteProtocolICMP,
	TracerouteProtocolUDP,
	TracerouteProtocolTCP,
}

func (e TracerouteProtocol) IsValid() bool {
	switch e {
	case TracerouteProtocolICMP, TracerouteProtocolUDP, TracerouteProtocolTCP:
		return true
	}
	return false
}

func (e TracerouteProtocol) String() string {
	return string(e)
}

func (e *TracerouteProtocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TracerouteProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TracerouteProtocol", str)
	}
	return nil
}

func (e TracerouteProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Transport protocol enum for network traffic.
type TransportProtocol string

const (
	TransportProtocolTCP TransportProtocol = "TCP"
	TransportProtocolUDP TransportProtocol = "UDP"
)

var AllTransportProtocol = []TransportProtocol{
	TransportProtocolTCP,
	TransportProtocolUDP,
}

func (e TransportProtocol) IsValid() bool {
	switch e {
	case TransportProtocolTCP, TransportProtocolUDP:
		return true
	}
	return false
}

func (e TransportProtocol) String() string {
	return string(e)
}

func (e *TransportProtocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransportProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransportProtocol", str)
	}
	return nil
}

func (e TransportProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Overall status of a troubleshooting session
type TroubleshootSessionStatus string

const (
	// Session created but not started
	TroubleshootSessionStatusIdle TroubleshootSessionStatus = "IDLE"
	// Detecting network configuration
	TroubleshootSessionStatusInitializing TroubleshootSessionStatus = "INITIALIZING"
	// Running diagnostic steps
	TroubleshootSessionStatusRunning TroubleshootSessionStatus = "RUNNING"
	// Waiting for user decision on fix
	TroubleshootSessionStatusAwaitingFixDecision TroubleshootSessionStatus = "AWAITING_FIX_DECISION"
	// Applying a fix
	TroubleshootSessionStatusApplyingFix TroubleshootSessionStatus = "APPLYING_FIX"
	// Verifying fix worked
	TroubleshootSessionStatusVerifyingFix TroubleshootSessionStatus = "VERIFYING_FIX"
	// Session completed
	TroubleshootSessionStatusCompleted TroubleshootSessionStatus = "COMPLETED"
	// Session was cancelled
	TroubleshootSessionStatusCancelled TroubleshootSessionStatus = "CANCELLED"
)

var AllTroubleshootSessionStatus = []TroubleshootSessionStatus{
	TroubleshootSessionStatusIdle,
	TroubleshootSessionStatusInitializing,
	TroubleshootSessionStatusRunning,
	TroubleshootSessionStatusAwaitingFixDecision,
	TroubleshootSessionStatusApplyingFix,
	TroubleshootSessionStatusVerifyingFix,
	TroubleshootSessionStatusCompleted,
	TroubleshootSessionStatusCancelled,
}

func (e TroubleshootSessionStatus) IsValid() bool {
	switch e {
	case TroubleshootSessionStatusIdle, TroubleshootSessionStatusInitializing, TroubleshootSessionStatusRunning, TroubleshootSessionStatusAwaitingFixDecision, TroubleshootSessionStatusApplyingFix, TroubleshootSessionStatusVerifyingFix, TroubleshootSessionStatusCompleted, TroubleshootSessionStatusCancelled:
		return true
	}
	return false
}

func (e TroubleshootSessionStatus) String() string {
	return string(e)
}

func (e *TroubleshootSessionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TroubleshootSessionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TroubleshootSessionStatus", str)
	}
	return nil
}

func (e TroubleshootSessionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a diagnostic step
type TroubleshootStepStatus string

const (
	// Step not yet started
	TroubleshootStepStatusPending TroubleshootStepStatus = "PENDING"
	// Step currently executing
	TroubleshootStepStatusRunning TroubleshootStepStatus = "RUNNING"
	// Step completed successfully
	TroubleshootStepStatusPassed TroubleshootStepStatus = "PASSED"
	// Step failed
	TroubleshootStepStatusFailed TroubleshootStepStatus = "FAILED"
	// Step skipped
	TroubleshootStepStatusSkipped TroubleshootStepStatus = "SKIPPED"
)

var AllTroubleshootStepStatus = []TroubleshootStepStatus{
	TroubleshootStepStatusPending,
	TroubleshootStepStatusRunning,
	TroubleshootStepStatusPassed,
	TroubleshootStepStatusFailed,
	TroubleshootStepStatusSkipped,
}

func (e TroubleshootStepStatus) IsValid() bool {
	switch e {
	case TroubleshootStepStatusPending, TroubleshootStepStatusRunning, TroubleshootStepStatusPassed, TroubleshootStepStatusFailed, TroubleshootStepStatusSkipped:
		return true
	}
	return false
}

func (e TroubleshootStepStatus) String() string {
	return string(e)
}

func (e *TroubleshootStepStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TroubleshootStepStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TroubleshootStepStatus", str)
	}
	return nil
}

func (e TroubleshootStepStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Diagnostic step identifier for internet troubleshooting
type TroubleshootStepType string

const (
	// Check WAN interface status
	TroubleshootStepTypeWan TroubleshootStepType = "WAN"
	// Ping default gateway
	TroubleshootStepTypeGateway TroubleshootStepType = "GATEWAY"
	// Ping external internet server
	TroubleshootStepTypeInternet TroubleshootStepType = "INTERNET"
	// Test DNS resolution
	TroubleshootStepTypeDNS TroubleshootStepType = "DNS"
	// Verify NAT/masquerade rules
	TroubleshootStepTypeNat TroubleshootStepType = "NAT"
)

var AllTroubleshootStepType = []TroubleshootStepType{
	TroubleshootStepTypeWan,
	TroubleshootStepTypeGateway,
	TroubleshootStepTypeInternet,
	TroubleshootStepTypeDNS,
	TroubleshootStepTypeNat,
}

func (e TroubleshootStepType) IsValid() bool {
	switch e {
	case TroubleshootStepTypeWan, TroubleshootStepTypeGateway, TroubleshootStepTypeInternet, TroubleshootStepTypeDNS, TroubleshootStepTypeNat:
		return true
	}
	return false
}

func (e TroubleshootStepType) String() string {
	return string(e)
}

func (e *TroubleshootStepType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TroubleshootStepType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TroubleshootStepType", str)
	}
	return nil
}

func (e TroubleshootStepType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Status of a VPN tunnel
type TunnelStatus string

const (
	// Tunnel is connected and active
	TunnelStatusConnected TunnelStatus = "CONNECTED"
	// Tunnel is disconnected
	TunnelStatusDisconnected TunnelStatus = "DISCONNECTED"
	// Tunnel is attempting to connect
	TunnelStatusConnecting TunnelStatus = "CONNECTING"
)

var AllTunnelStatus = []TunnelStatus{
	TunnelStatusConnected,
	TunnelStatusDisconnected,
	TunnelStatusConnecting,
}

func (e TunnelStatus) IsValid() bool {
	switch e {
	case TunnelStatusConnected, TunnelStatusDisconnected, TunnelStatusConnecting:
		return true
	}
	return false
}

func (e TunnelStatus) String() string {
	return string(e)
}

func (e *TunnelStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TunnelStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TunnelStatus", str)
	}
	return nil
}

func (e TunnelStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Network tunnel types supported by MikroTik RouterOS
type TunnelType string

const (
	// IP-in-IP tunnel (RFC 2003) - Basic L3 encapsulation
	TunnelTypeIpip TunnelType = "IPIP"
	// Generic Routing Encapsulation (RFC 2784) - L3 with optional IPsec
	TunnelTypeGre TunnelType = "GRE"
	// Ethernet over IP - Layer 2 tunnel for bridge extension
	TunnelTypeEoip TunnelType = "EOIP"
	// Virtual eXtensible LAN (RFC 7348) - L2 overlay network
	TunnelTypeVxlan TunnelType = "VXLAN"
	// Secure Socket Tunneling Protocol (future support)
	TunnelTypeSstp TunnelType = "SSTP"
	// Layer 2 Tunneling Protocol (future support)
	TunnelTypeL2tp TunnelType = "L2TP"
)

var AllTunnelType = []TunnelType{
	TunnelTypeIpip,
	TunnelTypeGre,
	TunnelTypeEoip,
	TunnelTypeVxlan,
	TunnelTypeSstp,
	TunnelTypeL2tp,
}

func (e TunnelType) IsValid() bool {
	switch e {
	case TunnelTypeIpip, TunnelTypeGre, TunnelTypeEoip, TunnelTypeVxlan, TunnelTypeSstp, TunnelTypeL2tp:
		return true
	}
	return false
}

func (e TunnelType) String() string {
	return string(e)
}

func (e *TunnelType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TunnelType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TunnelType", str)
	}
	return nil
}

func (e TunnelType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Priority level for upgrade recommendations
type UpgradePriority string

const (
	// Security-related, should upgrade immediately
	UpgradePriorityCritical UpgradePriority = "CRITICAL"
	// Highly recommended for stability/features
	UpgradePriorityHigh UpgradePriority = "HIGH"
	// Recommended but not urgent
	UpgradePriorityMedium UpgradePriority = "MEDIUM"
	// Nice to have, optional
	UpgradePriorityLow UpgradePriority = "LOW"
)

var AllUpgradePriority = []UpgradePriority{
	UpgradePriorityCritical,
	UpgradePriorityHigh,
	UpgradePriorityMedium,
	UpgradePriorityLow,
}

func (e UpgradePriority) IsValid() bool {
	switch e {
	case UpgradePriorityCritical, UpgradePriorityHigh, UpgradePriorityMedium, UpgradePriorityLow:
		return true
	}
	return false
}

func (e UpgradePriority) String() string {
	return string(e)
}

func (e *UpgradePriority) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpgradePriority(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpgradePriority", str)
	}
	return nil
}

func (e UpgradePriority) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Predefined validation formats for common data types
type ValidateFormat string

const (
	ValidateFormatEmail    ValidateFormat = "EMAIL"
	ValidateFormatURL      ValidateFormat = "URL"
	ValidateFormatUUID     ValidateFormat = "UUID"
	ValidateFormatIPV4     ValidateFormat = "IPV4"
	ValidateFormatIPV6     ValidateFormat = "IPV6"
	ValidateFormatMac      ValidateFormat = "MAC"
	ValidateFormatCidr     ValidateFormat = "CIDR"
	ValidateFormatHostname ValidateFormat = "HOSTNAME"
	ValidateFormatFqdn     ValidateFormat = "FQDN"
)

var AllValidateFormat = []ValidateFormat{
	ValidateFormatEmail,
	ValidateFormatURL,
	ValidateFormatUUID,
	ValidateFormatIPV4,
	ValidateFormatIPV6,
	ValidateFormatMac,
	ValidateFormatCidr,
	ValidateFormatHostname,
	ValidateFormatFqdn,
}

func (e ValidateFormat) IsValid() bool {
	switch e {
	case ValidateFormatEmail, ValidateFormatURL, ValidateFormatUUID, ValidateFormatIPV4, ValidateFormatIPV6, ValidateFormatMac, ValidateFormatCidr, ValidateFormatHostname, ValidateFormatFqdn:
		return true
	}
	return false
}

func (e ValidateFormat) String() string {
	return string(e)
}

func (e *ValidateFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidateFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidateFormat", str)
	}
	return nil
}

func (e ValidateFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation issue severity
type ValidationSeverity string

const (
	// Blocks apply, must be fixed
	ValidationSeverityError ValidationSeverity = "ERROR"
	// Does not block, but recommended to address
	ValidationSeverityWarning ValidationSeverity = "WARNING"
	// Informational notice
	ValidationSeverityInfo ValidationSeverity = "INFO"
)

var AllValidationSeverity = []ValidationSeverity{
	ValidationSeverityError,
	ValidationSeverityWarning,
	ValidationSeverityInfo,
}

func (e ValidationSeverity) IsValid() bool {
	switch e {
	case ValidationSeverityError, ValidationSeverityWarning, ValidationSeverityInfo:
		return true
	}
	return false
}

func (e ValidationSeverity) String() string {
	return string(e)
}

func (e *ValidationSeverity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidationSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidationSeverity", str)
	}
	return nil
}

func (e ValidationSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Validation pipeline stages
type ValidationStage string

const (
	// Schema validation (Zod/GraphQL)
	ValidationStageSchema ValidationStage = "SCHEMA"
	// Semantic validation (business rules)
	ValidationStageSemantic ValidationStage = "SEMANTIC"
	// Dependency validation (required resources exist)
	ValidationStageDependency ValidationStage = "DEPENDENCY"
	// Conflict detection (port/IP/route conflicts)
	ValidationStageConflict ValidationStage = "CONFLICT"
	// Platform validation (capability checks)
	ValidationStagePlatform ValidationStage = "PLATFORM"
	// Quota validation (resource limits)
	ValidationStageQuota ValidationStage = "QUOTA"
	// Pre-flight simulation
	ValidationStageSimulation ValidationStage = "SIMULATION"
	// All stages complete
	ValidationStageComplete ValidationStage = "COMPLETE"
)

var AllValidationStage = []ValidationStage{
	ValidationStageSchema,
	ValidationStageSemantic,
	ValidationStageDependency,
	ValidationStageConflict,
	ValidationStagePlatform,
	ValidationStageQuota,
	ValidationStageSimulation,
	ValidationStageComplete,
}

func (e ValidationStage) IsValid() bool {
	switch e {
	case ValidationStageSchema, ValidationStageSemantic, ValidationStageDependency, ValidationStageConflict, ValidationStagePlatform, ValidationStageQuota, ValidationStageSimulation, ValidationStageComplete:
		return true
	}
	return false
}

func (e ValidationStage) String() string {
	return string(e)
}

func (e *ValidationStage) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidationStage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidationStage", str)
	}
	return nil
}

func (e ValidationStage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Variable types for template parameters.
type VariableType string

const (
	// Free-form string
	VariableTypeString VariableType = "STRING"
	// Interface name (autocomplete from router)
	VariableTypeInterface VariableType = "INTERFACE"
	// Subnet in CIDR notation
	VariableTypeSubnet VariableType = "SUBNET"
	// IP address
	VariableTypeIP VariableType = "IP"
	// Port number
	VariableTypePort VariableType = "PORT"
	// VLAN ID
	VariableTypeVlanID VariableType = "VLAN_ID"
)

var AllVariableType = []VariableType{
	VariableTypeString,
	VariableTypeInterface,
	VariableTypeSubnet,
	VariableTypeIP,
	VariableTypePort,
	VariableTypeVlanID,
}

func (e VariableType) IsValid() bool {
	switch e {
	case VariableTypeString, VariableTypeInterface, VariableTypeSubnet, VariableTypeIP, VariableTypePort, VariableTypeVlanID:
		return true
	}
	return false
}

func (e VariableType) String() string {
	return string(e)
}

func (e *VariableType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VariableType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VariableType", str)
	}
	return nil
}

func (e VariableType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// WAN connection type classification
type WANConnectionType string

const (
	// DHCP client (dynamic IP)
	WANConnectionTypeDhcp WANConnectionType = "DHCP"
	// PPPoE dial-up connection
	WANConnectionTypePppoe WANConnectionType = "PPPOE"
	// Static IP configuration
	WANConnectionTypeStatic WANConnectionType = "STATIC"
	// LTE/cellular connection
	WANConnectionTypeLte WANConnectionType = "LTE"
	// Not configured
	WANConnectionTypeNone WANConnectionType = "NONE"
)

var AllWANConnectionType = []WANConnectionType{
	WANConnectionTypeDhcp,
	WANConnectionTypePppoe,
	WANConnectionTypeStatic,
	WANConnectionTypeLte,
	WANConnectionTypeNone,
}

func (e WANConnectionType) IsValid() bool {
	switch e {
	case WANConnectionTypeDhcp, WANConnectionTypePppoe, WANConnectionTypeStatic, WANConnectionTypeLte, WANConnectionTypeNone:
		return true
	}
	return false
}

func (e WANConnectionType) String() string {
	return string(e)
}

func (e *WANConnectionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WANConnectionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WANConnectionType", str)
	}
	return nil
}

func (e WANConnectionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// WAN event types for history tracking
type WANEventType string

const (
	// Connection established
	WANEventTypeConnected WANEventType = "CONNECTED"
	// Connection lost
	WANEventTypeDisconnected WANEventType = "DISCONNECTED"
	// Authentication failed
	WANEventTypeAuthFailed WANEventType = "AUTH_FAILED"
	// IP address changed
	WANEventTypeIPChanged WANEventType = "IP_CHANGED"
	// Gateway changed
	WANEventTypeGatewayChanged WANEventType = "GATEWAY_CHANGED"
	// Health check failed
	WANEventTypeHealthFailed WANEventType = "HEALTH_FAILED"
	// Health check recovered
	WANEventTypeHealthRecovered WANEventType = "HEALTH_RECOVERED"
)

var AllWANEventType = []WANEventType{
	WANEventTypeConnected,
	WANEventTypeDisconnected,
	WANEventTypeAuthFailed,
	WANEventTypeIPChanged,
	WANEventTypeGatewayChanged,
	WANEventTypeHealthFailed,
	WANEventTypeHealthRecovered,
}

func (e WANEventType) IsValid() bool {
	switch e {
	case WANEventTypeConnected, WANEventTypeDisconnected, WANEventTypeAuthFailed, WANEventTypeIPChanged, WANEventTypeGatewayChanged, WANEventTypeHealthFailed, WANEventTypeHealthRecovered:
		return true
	}
	return false
}

func (e WANEventType) String() string {
	return string(e)
}

func (e *WANEventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WANEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WANEventType", str)
	}
	return nil
}

func (e WANEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// WAN connection status
type WANStatus string

const (
	// Connected and online
	WANStatusConnected WANStatus = "CONNECTED"
	// Connecting/authenticating
	WANStatusConnecting WANStatus = "CONNECTING"
	// Disconnected
	WANStatusDisconnected WANStatus = "DISCONNECTED"
	// Connection failed
	WANStatusError WANStatus = "ERROR"
	// Disabled
	WANStatusDisabled WANStatus = "DISABLED"
)

var AllWANStatus = []WANStatus{
	WANStatusConnected,
	WANStatusConnecting,
	WANStatusDisconnected,
	WANStatusError,
	WANStatusDisabled,
}

func (e WANStatus) IsValid() bool {
	switch e {
	case WANStatusConnected, WANStatusConnecting, WANStatusDisconnected, WANStatusError, WANStatusDisabled:
		return true
	}
	return false
}

func (e WANStatus) String() string {
	return string(e)
}

func (e *WANStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WANStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WANStatus", str)
	}
	return nil
}

func (e WANStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Webhook authentication types
type WebhookAuthType string

const (
	// No authentication required
	WebhookAuthTypeNone WebhookAuthType = "NONE"
	// Bearer token authentication
	WebhookAuthTypeBearer WebhookAuthType = "BEARER"
	// HTTP Basic authentication
	WebhookAuthTypeBasic WebhookAuthType = "BASIC"
)

var AllWebhookAuthType = []WebhookAuthType{
	WebhookAuthTypeNone,
	WebhookAuthTypeBearer,
	WebhookAuthTypeBasic,
}

func (e WebhookAuthType) IsValid() bool {
	switch e {
	case WebhookAuthTypeNone, WebhookAuthTypeBearer, WebhookAuthTypeBasic:
		return true
	}
	return false
}

func (e WebhookAuthType) String() string {
	return string(e)
}

func (e *WebhookAuthType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookAuthType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookAuthType", str)
	}
	return nil
}

func (e WebhookAuthType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Webhook template types for predefined formats
type WebhookTemplate string

const (
	// Generic JSON format
	WebhookTemplateGeneric WebhookTemplate = "GENERIC"
	// Slack incoming webhook format
	WebhookTemplateSLACk WebhookTemplate = "SLACK"
	// Discord webhook format
	WebhookTemplateDiscord WebhookTemplate = "DISCORD"
	// Microsoft Teams webhook format
	WebhookTemplateTeams WebhookTemplate = "TEAMS"
	// Custom template with user-defined format
	WebhookTemplateCustom WebhookTemplate = "CUSTOM"
)

var AllWebhookTemplate = []WebhookTemplate{
	WebhookTemplateGeneric,
	WebhookTemplateSLACk,
	WebhookTemplateDiscord,
	WebhookTemplateTeams,
	WebhookTemplateCustom,
}

func (e WebhookTemplate) IsValid() bool {
	switch e {
	case WebhookTemplateGeneric, WebhookTemplateSLACk, WebhookTemplateDiscord, WebhookTemplateTeams, WebhookTemplateCustom:
		return true
	}
	return false
}

func (e WebhookTemplate) String() string {
	return string(e)
}

func (e *WebhookTemplate) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookTemplate(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookTemplate", str)
	}
	return nil
}

func (e WebhookTemplate) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
