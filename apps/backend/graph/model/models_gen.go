// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
)

// Connection interface for paginated results (Relay pagination)
type Connection interface {
	IsConnection()
}

// Edge interface for connection edges
type Edge interface {
	IsEdge()
}

// Relay Node interface for global object identification
type Node interface {
	IsNode()
}

// Universal State v2 Resource Interface.
// Every managed resource implements this interface with 8 layers:
// 1. configuration - User's desired config (mutable by user)
// 2. validation - Pre-flight check results (computed by backend)
// 3. deployment - What's on router (after Apply-Confirm)
// 4. runtime - Live operational state (polled/streamed)
// 5. telemetry - Time-series metrics (historical)
// 6. metadata - Lifecycle info, tags, ownership
// 7. relationships - Dependencies (embedded + explicit)
// 8. platform - Capabilities and field mappings
type Resource interface {
	IsResource()
}

// Union type for storage mount/unmount events.
type StorageMountEvent interface {
	IsStorageMountEvent()
}

type AddBridgePortInput struct {
	InterfaceID      string                         `json:"interfaceId"`
	Pvid             graphql.Omittable[*int]        `json:"pvid,omitempty"`
	FrameTypes       graphql.Omittable[*FrameTypes] `json:"frameTypes,omitempty"`
	IngressFiltering graphql.Omittable[*bool]       `json:"ingressFiltering,omitempty"`
}

type AddChangeSetItemPayload struct {
	// The updated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// The added item ID
	ItemID *string `json:"itemId,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// AddDependencyInput contains parameters for creating a dependency relationship.
type AddDependencyInput struct {
	FromInstanceID       string         `json:"fromInstanceId"`
	ToInstanceID         string         `json:"toInstanceId"`
	DependencyType       DependencyType `json:"dependencyType"`
	AutoStart            bool           `json:"autoStart"`
	HealthTimeoutSeconds int            `json:"healthTimeoutSeconds"`
}

// Input for adding a provisioning resource to a session
type AddProvisioningResourceInput struct {
	// Resource type identifier (e.g., "wireguard-client", "ovpn-client", "tunnel-ipip")
	ResourceType string `json:"resourceType"`
	// Resource-specific configuration
	// Structure depends on resourceType
	Configuration map[string]any `json:"configuration"`
	// Resource relationships to other resources or networks
	Relationships graphql.Omittable[*ProvisioningRelationshipsInput] `json:"relationships,omitempty"`
}

// Input for manually adding a new router with full credentials and protocol preference.
// This is the primary input type for the addRouter mutation.
type AddRouterInput struct {
	// Router hostname or IP address.
	// Can be an IPv4 address (e.g., '192.168.88.1'), IPv6 address, or hostname (e.g., 'router.local').
	// Hostnames will trigger DNS resolution with caching.
	Host string `json:"host"`
	// Connection port. If not specified, defaults to protocol-specific port:
	// - REST: 443 (or 80 for HTTP)
	// - API: 8728
	// - API_SSL: 8729
	// - SSH: 22
	// - Telnet: 23
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Username for authentication.
	// For MikroTik routers, this is typically 'admin' or a custom user.
	Username string `json:"username"`
	// Password for authentication.
	// This value is encrypted before storage and never logged.
	Password string `json:"password"`
	// Protocol preference for connection.
	// Defaults to AUTO which tries protocols in recommended order.
	ProtocolPreference graphql.Omittable[*ProtocolPreference] `json:"protocolPreference,omitempty"`
	// User-friendly display name for the router.
	// If not provided, a name will be generated from the host.
	Name graphql.Omittable[*string] `json:"name,omitempty"`
}

// Payload returned from the addRouter mutation.
// Contains either the created router or validation/connection errors.
type AddRouterPayload struct {
	// The newly created router (null if errors occurred)
	Router *Router `json:"router,omitempty"`
	// Connection test result from initial connection attempt
	ConnectionResult *ConnectionTestResult `json:"connectionResult,omitempty"`
	// Field-level validation errors for retry
	ValidationErrors []*ValidationError `json:"validationErrors,omitempty"`
	// General errors that occurred during creation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Aggregated view of an address list with entry statistics.
// Address lists group IP addresses for use in firewall rules.
type AddressList struct {
	// List name (unique identifier)
	Name string `json:"name"`
	// Total number of entries in this list
	EntryCount int `json:"entryCount"`
	// Number of dynamic entries (added by firewall actions)
	DynamicCount int `json:"dynamicCount"`
	// Number of firewall rules referencing this list
	ReferencingRulesCount int `json:"referencingRulesCount"`
	// Paginated entries in this list
	Entries *AddressListEntryConnection `json:"entries"`
	// Firewall rules that reference this list
	ReferencingRules []*FirewallRule `json:"referencingRules"`
}

// Single entry in an address list.
// Represents an IP address, CIDR subnet, or IP range that belongs to a named list.
type AddressListEntry struct {
	// MikroTik internal ID
	ID string `json:"id"`
	// Name of the address list this entry belongs to
	List string `json:"list"`
	// IP address, CIDR subnet, or IP range
	Address string `json:"address"`
	// Optional description
	Comment *string `json:"comment,omitempty"`
	// Optional timeout after which entry is removed
	Timeout *string `json:"timeout,omitempty"`
	// When this entry was created
	CreationTime *time.Time `json:"creationTime,omitempty"`
	// Whether this entry was added dynamically by a firewall action
	Dynamic bool `json:"dynamic"`
	// Whether this entry is disabled
	Disabled bool `json:"disabled"`
}

func (AddressListEntry) IsNode() {}

// Connection type for paginated address list entries.
// Follows Relay pagination specification.
type AddressListEntryConnection struct {
	Edges      []*AddressListEntryEdge `json:"edges"`
	PageInfo   *PageInfo               `json:"pageInfo"`
	TotalCount *int                    `json:"totalCount,omitempty"`
}

func (AddressListEntryConnection) IsConnection() {}

// Edge type for address list entry connections.
type AddressListEntryEdge struct {
	Cursor string            `json:"cursor"`
	Node   *AddressListEntry `json:"node"`
}

func (AddressListEntryEdge) IsEdge() {}

// Resource affected by a configuration change
type AffectedResource struct {
	// Resource type (ip-address, dhcp-server, firewall-rule, etc.)
	Type string `json:"type"`
	// Resource ID
	ID string `json:"id"`
	// Resource name or description
	Name string `json:"name"`
	// How the resource will be affected (modified, disabled, removed)
	Impact ResourceImpact `json:"impact"`
}

// Individual alert instance triggered when rule conditions are met
type Alert struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Alert rule that triggered this alert
	Rule *AlertRule `json:"rule"`
	// Event type that triggered this alert
	EventType string `json:"eventType"`
	// Alert severity level
	Severity AlertSeverity `json:"severity"`
	// Alert title/summary
	Title string `json:"title"`
	// Detailed alert message
	Message string `json:"message"`
	// Event data and context information
	Data map[string]any `json:"data,omitempty"`
	// Device ID that triggered this alert
	DeviceID *string `json:"deviceId,omitempty"`
	// When alert was triggered
	TriggeredAt time.Time `json:"triggeredAt"`
	// When alert was acknowledged
	AcknowledgedAt *time.Time `json:"acknowledgedAt,omitempty"`
	// User who acknowledged the alert
	AcknowledgedBy *string `json:"acknowledgedBy,omitempty"`
	// Delivery status per channel
	DeliveryStatus map[string]any `json:"deliveryStatus,omitempty"`
	// Escalation tracking for this alert (NAS-18.9)
	Escalation *AlertEscalation `json:"escalation,omitempty"`
	// Number of alerts suppressed by throttling (if this alert is part of a throttle group)
	SuppressedCount *int `json:"suppressedCount,omitempty"`
	// Reason for suppression (e.g., "throttled", "storm_detected")
	SuppressReason *string `json:"suppressReason,omitempty"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (Alert) IsNode() {}

// Template variable input
type AlertAlertTemplateVariableInput struct {
	// Variable name
	Name string `json:"name"`
	// Display label
	Label string `json:"label"`
	// Variable type
	Type AlertTemplateVariableType `json:"type"`
	// Whether required
	Required bool `json:"required"`
	// Default value
	DefaultValue graphql.Omittable[*string] `json:"defaultValue,omitempty"`
	// Description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Options for enum types
	Options graphql.Omittable[[]string] `json:"options,omitempty"`
}

// Condition for event matching in alert rules
type AlertCondition struct {
	// Field name to evaluate
	Field string `json:"field"`
	// Comparison operator
	Operator ConditionOperator `json:"operator"`
	// Value to compare against
	Value string `json:"value"`
}

// Alert condition input
type AlertConditionInput struct {
	// Field name to evaluate
	Field string `json:"field"`
	// Comparison operator
	Operator ConditionOperator `json:"operator"`
	// Value to compare against
	Value string `json:"value"`
}

// Paginated alert connection
type AlertConnection struct {
	// Alert edges
	Edges []*AlertEdge `json:"edges"`
	// Pagination information
	PageInfo *PageInfo `json:"pageInfo"`
	// Total count of alerts
	TotalCount int `json:"totalCount"`
}

func (AlertConnection) IsConnection() {}

// Alert edge for pagination
type AlertEdge struct {
	// Alert node
	Node *Alert `json:"node"`
	// Pagination cursor
	Cursor string `json:"cursor"`
}

func (AlertEdge) IsEdge() {}

// Alert escalation tracking record (NAS-18.9)
type AlertEscalation struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Alert being tracked for escalation
	AlertID string `json:"alertId"`
	// Alert rule with escalation configuration
	RuleID string `json:"ruleId"`
	// Current escalation level (0 = initial)
	CurrentLevel int `json:"currentLevel"`
	// Maximum escalation level
	MaxLevel int `json:"maxLevel"`
	// Escalation status
	Status EscalationStatus `json:"status"`
	// When next escalation level should trigger
	NextEscalationAt *time.Time `json:"nextEscalationAt,omitempty"`
	// When escalation was resolved
	ResolvedAt *time.Time `json:"resolvedAt,omitempty"`
	// Reason for resolution
	ResolvedBy *string `json:"resolvedBy,omitempty"`
	// Record creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (AlertEscalation) IsNode() {}

// Alert event for real-time subscriptions
type AlertEvent struct {
	// The alert that changed
	Alert *Alert `json:"alert"`
	// Type of action that occurred
	Action AlertAction `json:"action"`
}

// Alert mutation payload
type AlertPayload struct {
	// Modified alert
	Alert *Alert `json:"alert,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Alert rule defines conditions that trigger notifications when met
type AlertRule struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Human-readable alert rule name
	Name string `json:"name"`
	// Optional description of what this rule monitors
	Description *string `json:"description,omitempty"`
	// Event type to match (e.g., 'router.offline', 'interface.down', 'cpu.high')
	EventType string `json:"eventType"`
	// Array of conditions for event matching
	Conditions []*AlertCondition `json:"conditions"`
	// Alert severity level
	Severity AlertSeverity `json:"severity"`
	// Notification channels to use
	Channels []string `json:"channels"`
	// Throttle configuration to prevent alert spam
	Throttle *ThrottleConfig `json:"throttle,omitempty"`
	// Quiet hours configuration for non-critical alerts
	QuietHours *QuietHoursConfig `json:"quietHours,omitempty"`
	// Escalation configuration for unacknowledged alerts (NAS-18.9)
	Escalation *EscalationConfig `json:"escalation,omitempty"`
	// Optional device ID filter - rule only applies to this device
	DeviceID *string `json:"deviceId,omitempty"`
	// Whether this alert rule is enabled
	Enabled bool `json:"enabled"`
	// Record creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// Alerts triggered by this rule
	Alerts []*Alert `json:"alerts"`
}

func (AlertRule) IsNode() {}

// Variable input for alert rule templates
type AlertRuleAlertTemplateVariableInput struct {
	// Variable name
	Name string `json:"name"`
	// Display label
	Label string `json:"label"`
	// Variable type
	Type AlertRuleTemplateVariableType `json:"type"`
	// Whether required
	Required bool `json:"required"`
	// Default value
	DefaultValue graphql.Omittable[*string] `json:"defaultValue,omitempty"`
	// Minimum value
	Min graphql.Omittable[*int] `json:"min,omitempty"`
	// Maximum value
	Max graphql.Omittable[*int] `json:"max,omitempty"`
	// Unit label
	Unit graphql.Omittable[*string] `json:"unit,omitempty"`
	// Description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

// Alert rule mutation payload
type AlertRulePayload struct {
	// Created/updated alert rule
	AlertRule *AlertRule `json:"alertRule,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Alert rule template for quick rule creation
// Pre-configured templates with variables for common alert scenarios
type AlertRuleTemplate struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Template name
	Name string `json:"name"`
	// Template description
	Description string `json:"description"`
	// Template category
	Category AlertRuleTemplateCategory `json:"category"`
	// Alert severity level
	Severity AlertSeverity `json:"severity"`
	// Event type this template monitors
	EventType string `json:"eventType"`
	// Pre-configured conditions
	Conditions []*AlertCondition `json:"conditions"`
	// Throttle configuration
	Throttle *ThrottleConfig `json:"throttle,omitempty"`
	// Default notification channels
	Channels []string `json:"channels"`
	// Template variables for customization
	Variables []*AlertRuleTemplateVariable `json:"variables"`
	// Whether this is a built-in template
	IsBuiltIn bool `json:"isBuiltIn"`
	// Template version
	Version string `json:"version"`
	// Record creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (AlertRuleTemplate) IsNode() {}

// Alert rule template mutation payload
type AlertRuleTemplatePayload struct {
	// Created/updated template
	Template *AlertRuleTemplate `json:"template,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Preview result for alert rule template
type AlertRuleTemplatePreview struct {
	// The template being previewed
	Template *AlertRuleTemplate `json:"template"`
	// Resolved conditions with variable substitution
	ResolvedConditions []*AlertCondition `json:"resolvedConditions"`
	// Validation information
	ValidationInfo *TemplateValidationInfo `json:"validationInfo"`
}

// Variable definition for alert rule templates
type AlertRuleTemplateVariable struct {
	// Variable name (used for substitution)
	Name string `json:"name"`
	// Display label
	Label string `json:"label"`
	// Variable type
	Type AlertRuleTemplateVariableType `json:"type"`
	// Whether this variable is required
	Required bool `json:"required"`
	// Default value
	DefaultValue *string `json:"defaultValue,omitempty"`
	// Minimum value (for INTEGER, DURATION, PERCENTAGE)
	Min *int `json:"min,omitempty"`
	// Maximum value (for INTEGER, DURATION, PERCENTAGE)
	Max *int `json:"max,omitempty"`
	// Unit label (e.g., "seconds", "percent", "MB")
	Unit *string `json:"unit,omitempty"`
	// Variable description
	Description *string `json:"description,omitempty"`
}

// Alert notification template
// Templates define message format for different event types and channels
type AlertTemplate struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Template name
	Name string `json:"name"`
	// Template description
	Description string `json:"description"`
	// Event type this template applies to
	EventType string `json:"eventType"`
	// Notification channel
	Channel NotificationChannel `json:"channel"`
	// Subject/title template
	SubjectTemplate *string `json:"subjectTemplate,omitempty"`
	// Body template with Go template syntax
	BodyTemplate string `json:"bodyTemplate"`
	// Template variables
	Variables []*AlertTemplateVariable `json:"variables"`
	// Whether this is a built-in template
	IsBuiltIn bool `json:"isBuiltIn"`
	// Whether this is a system default template
	IsDefault bool `json:"isDefault"`
	// Tags for categorization
	Tags []string `json:"tags"`
	// Channel-specific metadata
	Metadata map[string]any `json:"metadata,omitempty"`
	// Record creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (AlertTemplate) IsNode() {}

// Alert template mutation payload
type AlertTemplatePayload struct {
	// Created/updated template
	Template *AlertTemplate `json:"template,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Template variable definition
type AlertTemplateVariable struct {
	// Variable name (used in template as {{.Name}})
	Name string `json:"name"`
	// Display label
	Label string `json:"label"`
	// Variable type
	Type AlertTemplateVariableType `json:"type"`
	// Whether this variable is required
	Required bool `json:"required"`
	// Default value
	DefaultValue *string `json:"defaultValue,omitempty"`
	// Variable description
	Description *string `json:"description,omitempty"`
	// Options for enum-type variables
	Options []string `json:"options,omitempty"`
}

// Input for applying an alert template
type ApplyAlertTemplateInput struct {
	// Template ID to apply
	TemplateID string `json:"templateId"`
	// Variables for template substitution
	Variables map[string]any `json:"variables"`
	// Alert rule configuration
	RuleConfig *CreateAlertRuleInput `json:"ruleConfig"`
}

type ApplyChangeSetPayload struct {
	// Change set ID
	ChangeSetID string `json:"changeSetId"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of applying configuration
type ApplyConfigPayload struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// Updated service instance (if successful)
	Instance *ServiceInstance `json:"instance,omitempty"`
	// Error messages (if failed)
	Errors []string `json:"errors"`
	// Path to generated config file
	ConfigPath *string `json:"configPath,omitempty"`
}

// Result of applying a fix
type ApplyFixPayload struct {
	// Whether fix was applied successfully
	Success bool `json:"success"`
	// User-friendly message
	Message string `json:"message"`
	// Fix application status
	Status FixApplicationStatus `json:"status"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Payload for applying a provisioning session to router
type ApplyProvisioningSessionPayload struct {
	// The provisioning session after apply
	Session *ProvisioningSession `json:"session"`
	// List of resources that were successfully applied
	AppliedResources []Resource `json:"appliedResources"`
	// Changeset ID that was created and applied
	ChangesetID string `json:"changesetId"`
	// Configuration preview that was applied (RouterOS commands)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

type ApplyResourcePayload struct {
	// The applied resource
	Resource Resource `json:"resource,omitempty"`
	// Operation ID for progress tracking
	OperationID string `json:"operationId"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for applying service configuration
type ApplyServiceConfigInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Service instance ID
	InstanceID string `json:"instanceID"`
	// Configuration to apply (as JSON)
	Config map[string]any `json:"config"`
}

// Input for applying a validated service import.
// Actually creates/updates the service instance.
type ApplyServiceImportInput struct {
	// Router ID to import into
	RouterID string `json:"routerID"`
	// Service export package (JSON)
	Package map[string]any `json:"package"`
	// Conflict resolution strategy
	ConflictResolution ConflictResolution `json:"conflictResolution"`
	// User-provided values for redacted fields
	RedactedFieldValues map[string]any `json:"redactedFieldValues"`
	// Device MAC addresses to filter routing rules (optional)
	DeviceFilter graphql.Omittable[[]string] `json:"deviceFilter,omitempty"`
}

// Payload for apply service import mutation.
type ApplyServiceImportPayload struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// Created or updated service instance (null if failed)
	Instance *ServiceInstance `json:"instance,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

type ArchiveResourcePayload struct {
	// Whether archive was successful
	Success bool `json:"success"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for assigning device routing.
type AssignDeviceRoutingInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Device ID to route
	DeviceID string `json:"deviceID"`
	// Device MAC address
	MacAddress string `json:"macAddress"`
	// Device IP address (optional)
	DeviceIP graphql.Omittable[*string] `json:"deviceIP,omitempty"`
	// Device hostname (optional)
	DeviceName graphql.Omittable[*string] `json:"deviceName,omitempty"`
	// Service instance ID to route through
	InstanceID string `json:"instanceID"`
	// Virtual interface ID to route through
	InterfaceID string `json:"interfaceID"`
	// Routing mark
	RoutingMark string `json:"routingMark"`
	// Routing mode
	RoutingMode RoutingMode `json:"routingMode"`
}

// Authentication test status
type AuthStatus struct {
	// Whether authentication was tested
	Tested bool `json:"tested"`
	// Whether authentication succeeded
	Success bool `json:"success"`
	// Error message (if authentication failed)
	Error *string `json:"error,omitempty"`
	// Error code mapped to ErrorCodes (A5xx)
	ErrorCode *string `json:"errorCode,omitempty"`
}

// Available service that can be installed from the Feature Marketplace.
// Represents a downloadable network service with metadata from the manifest.
type AvailableService struct {
	// Unique service identifier (e.g., 'tor', 'sing-box', 'xray')
	ID string `json:"id"`
	// Display name
	Name string `json:"name"`
	// Service description
	Description string `json:"description"`
	// Service version
	Version string `json:"version"`
	// Service category (VPN, Privacy, DNS, Messaging)
	Category string `json:"category"`
	// Service author
	Author string `json:"author"`
	// License
	License string `json:"license"`
	// Homepage URL
	Homepage *string `json:"homepage,omitempty"`
	// Icon filename or URL
	Icon *string `json:"icon,omitempty"`
	// Tags for filtering and search
	Tags []string `json:"tags"`
	// Supported architectures
	Architectures []string `json:"architectures"`
	// Minimum RouterOS version required
	MinRouterOSVersion *string `json:"minRouterOSVersion,omitempty"`
	// Required packages
	RequiredPackages []string `json:"requiredPackages"`
	// Required ports
	RequiredPorts []int `json:"requiredPorts"`
	// Required memory in MB
	RequiredMemoryMb int `json:"requiredMemoryMB"`
	// Required disk space in MB
	RequiredDiskMb int `json:"requiredDiskMB"`
	// Docker image name
	DockerImage string `json:"dockerImage"`
	// Docker image tag
	DockerTag string `json:"dockerTag"`
	// Default configuration (JSON)
	DefaultConfig map[string]any `json:"defaultConfig,omitempty"`
	// Configuration schema (JSON Schema)
	ConfigSchema map[string]any `json:"configSchema,omitempty"`
}

// A bandwidth data point
type BandwidthDataPoint struct {
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
	// Bytes in during this period
	BytesIn Size `json:"bytesIn"`
	// Bytes out during this period
	BytesOut Size `json:"bytesOut"`
	// Period duration in seconds
	PeriodSeconds int `json:"periodSeconds"`
}

// Input for batch interface operations
type BatchInterfaceInput struct {
	// Interface IDs to operate on
	InterfaceIds []string `json:"interfaceIds"`
	// Action to perform
	Action BatchInterfaceAction `json:"action"`
	// Optional input for UPDATE action
	Input graphql.Omittable[*UpdateInterfaceInput] `json:"input,omitempty"`
}

// Payload returned by batchInterfaceOperation mutation
type BatchInterfacePayload struct {
	// Interfaces that were successfully updated
	Succeeded []*Interface `json:"succeeded"`
	// Interfaces that failed with reasons
	Failed []*InterfaceOperationError `json:"failed"`
	// General errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Binary verification information for a service instance.
// Contains hashes and verification status for security auditing.
type BinaryVerification struct {
	// Whether binary verification is enabled for this instance
	Enabled bool `json:"enabled"`
	// SHA256 hash of the original downloaded archive (from checksums.txt)
	ArchiveHash *string `json:"archiveHash,omitempty"`
	// SHA256 hash of the extracted binary (computed at runtime)
	BinaryHash *string `json:"binaryHash,omitempty"`
	// Whether GPG signature verification was performed and passed
	GpgVerified bool `json:"gpgVerified"`
	// GPG key ID that signed the checksums file
	GpgKeyID *string `json:"gpgKeyID,omitempty"`
	// URL where checksums.txt was fetched from
	ChecksumsURL *string `json:"checksumsURL,omitempty"`
	// Timestamp when binary was last verified
	VerifiedAt *time.Time `json:"verifiedAt,omitempty"`
	// Verification status (valid, invalid, pending, not_verified)
	Status VerificationStatus `json:"status"`
}

// Bonding/link aggregation configuration
type BondingConfig struct {
	// Bonding mode
	Mode BondingMode `json:"mode"`
	// Interface monitoring interval
	MonitorInterval *Duration `json:"monitorInterval,omitempty"`
	// ARP targets to monitor
	ArpTargets []IPv4 `json:"arpTargets,omitempty"`
	// Enable bonding
	Enabled bool `json:"enabled"`
}

// BootSequenceEvent represents a real-time boot sequence event.
type BootSequenceEvent struct {
	ID           string    `json:"id"`
	Type         string    `json:"type"`
	Timestamp    time.Time `json:"timestamp"`
	Layer        *int      `json:"layer,omitempty"`
	InstanceIds  []string  `json:"instanceIds"`
	SuccessCount *int      `json:"successCount,omitempty"`
	FailureCount *int      `json:"failureCount,omitempty"`
	ErrorMessage *string   `json:"errorMessage,omitempty"`
}

// BootSequenceProgress represents the current state of the boot sequence.
type BootSequenceProgress struct {
	InProgress         bool     `json:"inProgress"`
	CurrentLayer       *int     `json:"currentLayer,omitempty"`
	TotalLayers        *int     `json:"totalLayers,omitempty"`
	StartedInstances   []string `json:"startedInstances"`
	FailedInstances    []string `json:"failedInstances"`
	RemainingInstances []string `json:"remainingInstances"`
}

type Bridge struct {
	ID                   string           `json:"id"`
	Name                 string           `json:"name"`
	Comment              *string          `json:"comment,omitempty"`
	Disabled             bool             `json:"disabled"`
	Running              bool             `json:"running"`
	MacAddress           *MAC             `json:"macAddress,omitempty"`
	Mtu                  *int             `json:"mtu,omitempty"`
	Protocol             StpProtocol      `json:"protocol"`
	Priority             *int             `json:"priority,omitempty"`
	VlanFiltering        bool             `json:"vlanFiltering"`
	Pvid                 *int             `json:"pvid,omitempty"`
	Ports                []*BridgePort    `json:"ports"`
	Vlans                []*BridgeVlan    `json:"vlans"`
	IPAddresses          []*IPAddress     `json:"ipAddresses"`
	StpStatus            *BridgeStpStatus `json:"stpStatus,omitempty"`
	DependentDhcpServers []*DhcpServer    `json:"dependentDhcpServers"`
	DependentRoutes      []*Route         `json:"dependentRoutes"`
}

func (Bridge) IsNode() {}

type BridgeMutationResult struct {
	Success bool             `json:"success"`
	Bridge  *Bridge          `json:"bridge,omitempty"`
	Errors  []*MutationError `json:"errors,omitempty"`
	// Previous state for undo functionality
	PreviousState map[string]any `json:"previousState,omitempty"`
	// Unique operation ID for undo within 10-second window
	OperationID *string `json:"operationId,omitempty"`
}

type BridgePort struct {
	ID               string       `json:"id"`
	Bridge           *Bridge      `json:"bridge"`
	Interface        *Interface   `json:"interface"`
	Pvid             int          `json:"pvid"`
	FrameTypes       FrameTypes   `json:"frameTypes"`
	IngressFiltering bool         `json:"ingressFiltering"`
	TaggedVlans      []int        `json:"taggedVlans"`
	UntaggedVlans    []int        `json:"untaggedVlans"`
	Role             StpPortRole  `json:"role"`
	State            StpPortState `json:"state"`
	PathCost         int          `json:"pathCost"`
	Edge             bool         `json:"edge"`
}

func (BridgePort) IsNode() {}

type BridgePortMutationResult struct {
	Success       bool             `json:"success"`
	Port          *BridgePort      `json:"port,omitempty"`
	Errors        []*MutationError `json:"errors,omitempty"`
	PreviousState map[string]any   `json:"previousState,omitempty"`
	OperationID   *string          `json:"operationId,omitempty"`
}

// VLAN configuration for a bridge port (trunk/access port setup)
type BridgePortVlanConfig struct {
	// Bridge port ID
	PortID string `json:"portId"`
	// Port VLAN ID (PVID) for untagged traffic
	Pvid int `json:"pvid"`
	// Frame types allowed on this port
	FrameTypes BridgePortFrameTypes `json:"frameTypes"`
	// Tagged VLANs allowed on this port (trunk mode)
	TaggedVlans []int `json:"taggedVlans"`
	// Untagged VLANs on this port (typically just PVID)
	UntaggedVlans []int `json:"untaggedVlans"`
	// Port mode (trunk or access)
	Mode PortMode `json:"mode"`
}

// Input for configuring bridge port VLAN settings
type BridgePortVlanInput struct {
	// Port VLAN ID (PVID) for untagged traffic
	Pvid int `json:"pvid"`
	// Frame types allowed on this port
	FrameTypes BridgePortFrameTypes `json:"frameTypes"`
	// Tagged VLANs (for trunk ports)
	TaggedVlans graphql.Omittable[[]int] `json:"taggedVlans,omitempty"`
	// Port mode (trunk or access)
	Mode PortMode `json:"mode"`
}

// Bridge resource (part of LANNetwork)
type BridgeResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]any         `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Bridge name
	Name string `json:"name"`
	// Ports in this bridge
	Ports []string `json:"ports"`
	// Protocol mode (rstp, stp, none)
	ProtocolMode *string `json:"protocolMode,omitempty"`
}

func (BridgeResource) IsResource() {}

func (BridgeResource) IsNode() {}

// Bridge status for service instance network setup.
// Combines interface and gateway status for health monitoring.
type BridgeStatus struct {
	// The virtual interface
	Interface *VirtualInterface `json:"interface,omitempty"`
	// Whether the interface is ready for traffic
	IsReady bool `json:"isReady"`
	// Whether the gateway (if any) is running
	GatewayRunning bool `json:"gatewayRunning"`
	// Any errors encountered
	Errors []string `json:"errors,omitempty"`
}

type BridgeStpStatus struct {
	RootBridge          bool       `json:"rootBridge"`
	RootBridgeID        *string    `json:"rootBridgeId,omitempty"`
	RootPort            *string    `json:"rootPort,omitempty"`
	RootPathCost        int        `json:"rootPathCost"`
	TopologyChangeCount int        `json:"topologyChangeCount"`
	LastTopologyChange  *time.Time `json:"lastTopologyChange,omitempty"`
}

type BridgeVlan struct {
	UUID          string        `json:"uuid"`
	Bridge        *Bridge       `json:"bridge"`
	VlanID        int           `json:"vlanId"`
	TaggedPorts   []*BridgePort `json:"taggedPorts"`
	UntaggedPorts []*BridgePort `json:"untaggedPorts"`
}

type BridgeVlanMutationResult struct {
	Success bool             `json:"success"`
	Vlan    *BridgeVlan      `json:"vlan,omitempty"`
	Errors  []*MutationError `json:"errors,omitempty"`
}

// Input for bulk address import.
// Used with bulkCreateAddressListEntries mutation.
type BulkAddressInput struct {
	// IP address, CIDR notation, or IP range
	Address string `json:"address"`
	// Optional description
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
	// Optional timeout
	Timeout graphql.Omittable[*string] `json:"timeout,omitempty"`
}

// Bulk alert mutation payload
type BulkAlertPayload struct {
	// Number of alerts acknowledged
	AcknowledgedCount int `json:"acknowledgedCount"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for bulk device routing assignment.
type BulkAssignRoutingInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// List of device routing assignments
	Assignments []*SingleDeviceRoutingInput `json:"assignments"`
}

// Details of a single failed entry in bulk import.
type BulkCreateError struct {
	// Index in the input array
	Index int `json:"index"`
	// The address that failed
	Address string `json:"address"`
	// Error message
	Message string `json:"message"`
}

// Result of bulk address list entry creation.
// Includes success count, failure count, and error details.
type BulkCreateResult struct {
	// Number of entries successfully created
	SuccessCount int `json:"successCount"`
	// Number of entries that failed
	FailedCount int `json:"failedCount"`
	// Details of failed entries
	Errors []*BulkCreateError `json:"errors"`
}

// Failed routing assignment in bulk operation.
type BulkRoutingFailure struct {
	// Device ID that failed
	DeviceID string `json:"deviceID"`
	// Device MAC address
	MacAddress string `json:"macAddress"`
	// Error message
	ErrorMessage string `json:"errorMessage"`
}

// Result of bulk routing assignment operation.
type BulkRoutingResult struct {
	// Number of successful assignments
	SuccessCount int `json:"successCount"`
	// Number of failed assignments
	FailureCount int `json:"failureCount"`
	// Successfully assigned routings
	Successes []*DeviceRouting `json:"successes"`
	// Failed assignments with error messages
	Failures []*BulkRoutingFailure `json:"failures"`
}

// CPU utilization metrics
type CPUMetrics struct {
	// Overall CPU usage percentage (0-100)
	Usage float64 `json:"usage"`
	// Number of CPU cores
	Cores int `json:"cores"`
	// Per-core usage percentages (one per core)
	PerCore []float64 `json:"perCore"`
	// CPU frequency in MHz (optional)
	Frequency *float64 `json:"frequency,omitempty"`
}

type CancelChangeSetPayload struct {
	// The cancelled change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Whether cancel was successful
	Success bool `json:"success"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

type CancelScanPayload struct {
	// The cancelled scan task
	Task *ScanTask `json:"task,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Single capability with its support level and guidance
type CapabilityEntry struct {
	// Capability category
	Capability Capability `json:"capability"`
	// Support level
	Level CapabilityLevel `json:"level"`
	// Human-readable description of support
	Description *string `json:"description,omitempty"`
	// Actionable message if feature unavailable
	Guidance *string `json:"guidance,omitempty"`
}

// A single hop in a multi-hop routing chain, referencing one VirtualInterface.
type ChainHop struct {
	// Hop ID (ULID)
	ID string `json:"id"`
	// 1-based position in the chain (1 = first hop, 2 = second, etc.)
	Order int `json:"order"`
	// Virtual interface for this hop
	Interface *VirtualInterface `json:"interface"`
	// MikroTik routing mark (e.g., chain-abc123-hop1)
	RoutingMark string `json:"routingMark"`
	// Latency for this hop in milliseconds (-1 if unreachable)
	LatencyMs *float64 `json:"latencyMs,omitempty"`
	// Whether this hop is currently healthy
	Healthy bool `json:"healthy"`
	// Whether kill switch is active for this hop
	KillSwitchActive bool `json:"killSwitchActive"`
}

func (ChainHop) IsNode() {}

// Input for a single hop in a chain.
type ChainHopInput struct {
	// Virtual interface ID for this hop
	InterfaceID string `json:"interfaceId"`
	// 1-based position in the chain
	Order int `json:"order"`
}

// An entry in the change log
type ChangeLogEntry struct {
	// Change timestamp
	Timestamp time.Time `json:"timestamp"`
	// User who made the change
	User string `json:"user"`
	// Type of change
	ChangeType ChangeType `json:"changeType"`
	// Changed fields
	ChangedFields []string `json:"changedFields"`
	// Brief description of the change
	Summary *string `json:"summary,omitempty"`
}

// A change set representing an atomic multi-resource operation
type ChangeSet struct {
	// Unique identifier (ULID)
	ID string `json:"id"`
	// Human-readable name
	Name string `json:"name"`
	// Optional description
	Description *string `json:"description,omitempty"`
	// Router ID this change set applies to
	RouterID string `json:"routerId"`
	// Items in this change set
	Items []*ChangeSetItem `json:"items"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Validation result
	Validation *ChangeSetValidationResult `json:"validation,omitempty"`
	// Rollback plan
	RollbackPlan []*RollbackStep `json:"rollbackPlan"`
	// Error information (if failed)
	Error *ChangeSetError `json:"error,omitempty"`
	// Created timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Apply started timestamp
	ApplyStartedAt *time.Time `json:"applyStartedAt,omitempty"`
	// Completed timestamp
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	// User who created the change set
	CreatedBy *string `json:"createdBy,omitempty"`
	// Source wizard/feature
	Source *string `json:"source,omitempty"`
	// Version for optimistic concurrency
	Version int `json:"version"`
}

// Conflict between change set items
type ChangeSetConflict struct {
	// First conflicting item ID
	ItemID1 string `json:"itemId1"`
	// Second conflicting item ID or resource UUID
	ItemID2OrResourceUUID string `json:"itemId2OrResourceUuid"`
	// Whether conflict is with existing resource
	IsExternalConflict bool `json:"isExternalConflict"`
	// Description of the conflict
	Description string `json:"description"`
	// Suggested resolution
	Resolution *string `json:"resolution,omitempty"`
}

// Detailed error for failed change sets
type ChangeSetError struct {
	// Error message
	Message string `json:"message"`
	// Item ID that caused the failure
	FailedItemID string `json:"failedItemId"`
	// Error code
	Code *string `json:"code,omitempty"`
	// Items applied before failure
	PartiallyAppliedItemIds []string `json:"partiallyAppliedItemIds"`
	// Items that failed rollback
	FailedRollbackItemIds []string `json:"failedRollbackItemIds"`
	// Whether manual intervention is required
	RequiresManualIntervention bool `json:"requiresManualIntervention"`
}

// Individual item within a change set
type ChangeSetItem struct {
	// Unique identifier for this item
	ID string `json:"id"`
	// Resource type identifier
	ResourceType string `json:"resourceType"`
	// Resource category
	ResourceCategory ResourceCategory `json:"resourceCategory"`
	// Existing resource UUID (null for create operations)
	ResourceUUID *string `json:"resourceUuid,omitempty"`
	// User-friendly name
	Name string `json:"name"`
	// Optional description
	Description *string `json:"description,omitempty"`
	// Operation to perform
	Operation ChangeOperation `json:"operation"`
	// New/updated configuration
	Configuration map[string]any `json:"configuration"`
	// Previous state (for rollback)
	PreviousState map[string]any `json:"previousState,omitempty"`
	// Item IDs this depends on
	Dependencies []string `json:"dependencies"`
	// Current status
	Status ChangeSetItemStatus `json:"status"`
	// Error message if failed
	Error *string `json:"error,omitempty"`
	// Apply started timestamp
	ApplyStartedAt *time.Time `json:"applyStartedAt,omitempty"`
	// Apply completed timestamp
	ApplyCompletedAt *time.Time `json:"applyCompletedAt,omitempty"`
	// Order in which this item will be applied
	ApplyOrder int `json:"applyOrder"`
}

// Input for adding an item to a change set
type ChangeSetItemInput struct {
	// Resource type identifier
	ResourceType string `json:"resourceType"`
	// Resource category
	ResourceCategory ResourceCategory `json:"resourceCategory"`
	// Existing resource UUID (for update/delete)
	ResourceUUID graphql.Omittable[*string] `json:"resourceUuid,omitempty"`
	// User-friendly name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Operation to perform
	Operation ChangeOperation `json:"operation"`
	// Configuration
	Configuration map[string]any `json:"configuration"`
	// Previous state (for rollback on update/delete)
	PreviousState graphql.Omittable[map[string]any] `json:"previousState,omitempty"`
	// Item IDs this depends on
	Dependencies graphql.Omittable[[]string] `json:"dependencies,omitempty"`
}

// Progress event for real-time updates during apply
type ChangeSetProgressEvent struct {
	// Change set ID
	ChangeSetID string `json:"changeSetId"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Currently processing item
	CurrentItem *CurrentItemInfo `json:"currentItem,omitempty"`
	// Number of items applied
	AppliedCount int `json:"appliedCount"`
	// Total number of items
	TotalCount int `json:"totalCount"`
	// Progress percentage (0-100)
	ProgressPercent float64 `json:"progressPercent"`
	// Estimated time remaining in milliseconds
	EstimatedRemainingMs *int `json:"estimatedRemainingMs,omitempty"`
	// Error if failed
	Error *ChangeSetError `json:"error,omitempty"`
	// Timestamp of this event
	Timestamp time.Time `json:"timestamp"`
}

// Change set status change event
type ChangeSetStatusEvent struct {
	// Change set ID
	ChangeSetID string `json:"changeSetId"`
	// Previous status
	PreviousStatus ChangeSetStatus `json:"previousStatus"`
	// New status
	NewStatus ChangeSetStatus `json:"newStatus"`
	// Error if failed
	Error *ChangeSetError `json:"error,omitempty"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// Summary of a change set for list displays
type ChangeSetSummary struct {
	// Change set ID
	ID string `json:"id"`
	// Name
	Name string `json:"name"`
	// Current status
	Status ChangeSetStatus `json:"status"`
	// Operation counts
	OperationCounts *OperationCounts `json:"operationCounts"`
	// Total items
	TotalItems int `json:"totalItems"`
	// Created timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Has validation errors
	HasErrors bool `json:"hasErrors"`
	// Has validation warnings
	HasWarnings bool `json:"hasWarnings"`
}

// Validation error for a change set item
type ChangeSetValidationError struct {
	// Item ID with validation error
	ItemID string `json:"itemId"`
	// Field path within the item configuration
	Field string `json:"field"`
	// Error message
	Message string `json:"message"`
	// Severity level
	Severity ValidationSeverity `json:"severity"`
	// Error code
	Code *string `json:"code,omitempty"`
}

// Validation result for a change set
type ChangeSetValidationResult struct {
	// Whether the change set can be applied
	CanApply bool `json:"canApply"`
	// Validation errors (blocking)
	Errors []*ChangeSetValidationError `json:"errors"`
	// Validation warnings (non-blocking)
	Warnings []*ChangeSetValidationError `json:"warnings"`
	// Detected conflicts
	Conflicts []*ChangeSetConflict `json:"conflicts"`
	// Missing dependencies
	MissingDependencies []*MissingDependency `json:"missingDependencies"`
	// Circular dependencies (if any)
	CircularDependencies [][]string `json:"circularDependencies,omitempty"`
}

// Payload for channel configuration mutations
type ChannelConfigPayload struct {
	// The created/updated configuration
	Config *NotificationChannelConfig `json:"config,omitempty"`
	// Validation or mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for checking port availability.
type CheckPortAvailabilityInput struct {
	// Router ID to check
	RouterID string `json:"routerID"`
	// Port number to check
	Port int `json:"port"`
	// Protocol to check
	Protocol PortProtocol `json:"protocol"`
}

// Event emitted when circuit breaker state changes
type CircuitBreakerEvent struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Previous state
	PreviousState CircuitBreakerState `json:"previousState"`
	// New state
	NewState CircuitBreakerState `json:"newState"`
	// Consecutive failures that triggered the change
	ConsecutiveFailures int `json:"consecutiveFailures"`
	// When the state changed
	Timestamp time.Time `json:"timestamp"`
}

// Circuit breaker status for a router
type CircuitBreakerStatus struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Current circuit breaker state
	State CircuitBreakerState `json:"state"`
	// Number of consecutive failures
	FailureCount int `json:"failureCount"`
	// Failure threshold before circuit opens
	FailureThreshold int `json:"failureThreshold"`
	// Seconds until auto-retry (when circuit is open)
	CooldownRemainingSeconds *int `json:"cooldownRemainingSeconds,omitempty"`
	// When the last failure occurred
	LastFailureAt *time.Time `json:"lastFailureAt,omitempty"`
	// When the last success occurred
	LastSuccessAt *time.Time `json:"lastSuccessAt,omitempty"`
}

// Input for cleaning up orphaned ports.
type CleanupOrphanedPortsInput struct {
	// Router ID to cleanup (if not provided, cleans all routers)
	RouterID graphql.Omittable[*string] `json:"routerID,omitempty"`
}

// A composite resource with all related sub-resources
type CompositeResource struct {
	// The root resource
	Root Resource `json:"root"`
	// All child/related resources
	Children []Resource `json:"children"`
	// Flattened relationship graph
	Relationships []*ResourceRelationshipEdge `json:"relationships"`
}

// Preview of RouterOS configuration commands
type ConfigPreview struct {
	// RouterOS commands to be executed
	Commands []string `json:"commands"`
	// Warnings about the configuration changes
	Warnings []string `json:"warnings,omitempty"`
	// Resources that will be affected
	AffectedResources []*AffectedResource `json:"affectedResources,omitempty"`
}

// Progress information for configuration apply operations
type ConfigProgress struct {
	// Unique operation identifier
	OperationID string `json:"operationId"`
	// Current status of the operation
	Status ConfigApplyStatus `json:"status"`
	// Completion percentage (0-100)
	Percentage int `json:"percentage"`
	// Human-readable progress message
	Message string `json:"message"`
	// Current step number
	CurrentStep *int `json:"currentStep,omitempty"`
	// Total number of steps
	TotalSteps *int `json:"totalSteps,omitempty"`
	// Timestamp of this progress update
	Timestamp time.Time `json:"timestamp"`
}

// Configuration schema for a service type
type ConfigSchema struct {
	// Service type identifier
	ServiceType string `json:"serviceType"`
	// Schema version
	Version string `json:"version"`
	// Configuration fields
	Fields []*ConfigSchemaField `json:"fields"`
}

// Configuration field definition for a service
type ConfigSchemaField struct {
	// Field name (internal identifier)
	Name string `json:"name"`
	// Field label (display name)
	Label string `json:"label"`
	// Field type for UI rendering
	Type ConfigFieldType `json:"type"`
	// Field description/help text
	Description *string `json:"description,omitempty"`
	// Whether the field is required
	Required bool `json:"required"`
	// Default value (as JSON)
	DefaultValue map[string]any `json:"defaultValue,omitempty"`
	// Placeholder text
	Placeholder *string `json:"placeholder,omitempty"`
	// Minimum value (for NUMBER/PORT types)
	Min *int `json:"min,omitempty"`
	// Maximum value (for NUMBER/PORT types)
	Max *int `json:"max,omitempty"`
	// Options for SELECT/MULTI_SELECT types
	Options []string `json:"options,omitempty"`
	// Whether the field contains sensitive data
	Sensitive bool `json:"sensitive"`
	// Validation function name
	ValidateFunc *string `json:"validateFunc,omitempty"`
	// Logical group/section this field belongs to (e.g., 'Basic', 'Advanced', 'Network')
	Group *string `json:"group,omitempty"`
}

// Validation error for a configuration field
type ConfigValidationError struct {
	// Field name
	Field string `json:"field"`
	// Error message
	Message string `json:"message"`
}

// Service configuration validation result
type ConfigValidationResult struct {
	// Whether the configuration is valid
	Valid bool `json:"valid"`
	// List of validation errors (empty if valid)
	Errors []*ConfigValidationError `json:"errors"`
}

// Input for configuring external storage.
type ConfigureExternalStorageInput struct {
	// Absolute path to external storage mount point
	Path string `json:"path"`
	// Whether to enable external storage (default: true)
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

// Payload for configureExternalStorage mutation.
type ConfigureExternalStoragePayload struct {
	// Storage configuration after update
	Config *StorageConfig `json:"config,omitempty"`
	// Storage info for configured path
	StorageInfo *StorageInfo `json:"storageInfo,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for configuring health check settings
type ConfigureHealthCheckInput struct {
	// Instance ID to configure
	InstanceID string `json:"instanceID"`
	// Health check interval in seconds (10-300)
	IntervalSeconds graphql.Omittable[*int] `json:"intervalSeconds,omitempty"`
	// Consecutive failures before marking unhealthy (1-10)
	FailureThreshold graphql.Omittable[*int] `json:"failureThreshold,omitempty"`
	// Whether to enable auto-restart on failure
	AutoRestart graphql.Omittable[*bool] `json:"autoRestart,omitempty"`
}

type ConnectRouterPayload struct {
	// The router that was connected
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during connection
	Errors []*MutationError `json:"errors,omitempty"`
}

// Record of a single protocol connection attempt
type ConnectionAttempt struct {
	// Protocol that was attempted
	Protocol Protocol `json:"protocol"`
	// When the attempt started
	StartedAt time.Time `json:"startedAt"`
	// When the attempt ended
	EndedAt time.Time `json:"endedAt"`
	// Whether the attempt succeeded
	Success bool `json:"success"`
	// Error code if failed
	ErrorCode *string `json:"errorCode,omitempty"`
	// Error message if failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Error category for classification
	ErrorCategory *ErrorCategory `json:"errorCategory,omitempty"`
}

// Detailed connection status for a router
type ConnectionDetails struct {
	// Current connection state
	State ConnectionStatus `json:"state"`
	// Protocol currently in use
	Protocol *Protocol `json:"protocol,omitempty"`
	// User's preferred protocol (if set)
	PreferredProtocol *Protocol `json:"preferredProtocol,omitempty"`
	// When the connection was established
	ConnectedAt *time.Time `json:"connectedAt,omitempty"`
	// Connection uptime duration
	Uptime *Duration `json:"uptime,omitempty"`
	// When the last disconnection occurred
	DisconnectedAt *time.Time `json:"disconnectedAt,omitempty"`
	// Most recent error message
	LastError *string `json:"lastError,omitempty"`
	// When the last error occurred
	LastErrorTime *time.Time `json:"lastErrorTime,omitempty"`
	// Reason for disconnection
	DisconnectReason *DisconnectReason `json:"disconnectReason,omitempty"`
	// Number of reconnection attempts made
	ReconnectAttempts int `json:"reconnectAttempts"`
	// When the next reconnection attempt will be made
	NextReconnectAt *time.Time `json:"nextReconnectAt,omitempty"`
	// Current circuit breaker state
	CircuitBreakerState CircuitBreakerState `json:"circuitBreakerState"`
	// Router version (if connected)
	Version *string `json:"version,omitempty"`
	// When the last health check was performed
	LastHealthCheck *time.Time `json:"lastHealthCheck,omitempty"`
	// Consecutive passed health checks
	HealthChecksPassed int `json:"healthChecksPassed"`
	// Consecutive failed health checks
	HealthChecksFailed int `json:"healthChecksFailed"`
	// Security warning if using insecure protocol (e.g., Telnet)
	SecurityWarning *string `json:"securityWarning,omitempty"`
	// Recommendation for upgrading to a more secure protocol
	UpgradeRecommendation *string `json:"upgradeRecommendation,omitempty"`
	// Whether the current protocol is considered legacy/insecure
	IsLegacyProtocol bool `json:"isLegacyProtocol"`
}

// Detailed error information for connection failures.
// Used to provide actionable feedback to the user.
type ConnectionError struct {
	// Error code for programmatic handling
	Code ConnectionErrorCode `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Protocol that failed (if specific to a protocol)
	Protocol *Protocol `json:"protocol,omitempty"`
	// Whether the error is likely transient and retryable
	Retryable bool `json:"retryable"`
	// Suggested user action to resolve the error
	SuggestedAction *string `json:"suggestedAction,omitempty"`
	// Timeout in milliseconds (if timeout error)
	TimeoutMs *int `json:"timeoutMs,omitempty"`
}

// Connection manager statistics
type ConnectionStats struct {
	// Total number of connections
	TotalConnections int `json:"totalConnections"`
	// Number of connected routers
	Connected int `json:"connected"`
	// Number of connecting routers
	Connecting int `json:"connecting"`
	// Number of disconnected routers
	Disconnected int `json:"disconnected"`
	// Number of reconnecting routers
	Reconnecting int `json:"reconnecting"`
	// Number of routers in error state
	Error int `json:"error"`
}

// Result of a connection test attempt, including protocol detection results.
type ConnectionTestResult struct {
	// Whether the connection was successful
	Success bool `json:"success"`
	// Protocol that was successfully used
	ProtocolUsed *Protocol `json:"protocolUsed,omitempty"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// RouterOS version detected (if connection succeeded)
	RouterVersion *string `json:"routerVersion,omitempty"`
	// Router model detected (if connection succeeded)
	RouterModel *string `json:"routerModel,omitempty"`
	// Router board name (if connection succeeded)
	BoardName *string `json:"boardName,omitempty"`
	// Uptime of the router (if connection succeeded)
	Uptime *Duration `json:"uptime,omitempty"`
	// List of protocols that were attempted
	ProtocolsAttempted []Protocol `json:"protocolsAttempted"`
	// Whether the router supports containers
	SupportsContainers *bool `json:"supportsContainers,omitempty"`
	// Architecture of the router (arm, arm64, x86, etc.)
	Architecture *string `json:"architecture,omitempty"`
	// Error details if connection failed
	Error *ConnectionError `json:"error,omitempty"`
}

// Container-specific capability information
type ContainerInfo struct {
	// Whether container package is installed
	PackageInstalled bool `json:"packageInstalled"`
	// Whether container feature is enabled in system settings
	Enabled bool `json:"enabled"`
	// Whether a container registry is configured
	RegistryConfigured bool `json:"registryConfigured"`
	// Available storage for container images in bytes
	StorageAvailable Size `json:"storageAvailable"`
	// Whether network namespace is supported
	SupportsNetworkNamespace bool `json:"supportsNetworkNamespace"`
	// Maximum number of containers supported
	MaxContainers *int `json:"maxContainers,omitempty"`
}

// Input for creating a new address list entry.
// List will be created if it doesn't exist.
type CreateAddressListEntryInput struct {
	// Target list name (will create if doesn't exist)
	List string `json:"list"`
	// IP address, CIDR notation (e.g., 192.168.1.0/24), or IP range (e.g., 192.168.1.1-192.168.1.100)
	Address string `json:"address"`
	// Optional description
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
	// Optional timeout (e.g., "1d", "12h", "30m")
	Timeout graphql.Omittable[*string] `json:"timeout,omitempty"`
}

// Input for creating an alert rule
type CreateAlertRuleInput struct {
	// Human-readable alert rule name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Event type to match
	EventType string `json:"eventType"`
	// Array of conditions
	Conditions graphql.Omittable[[]*AlertConditionInput] `json:"conditions,omitempty"`
	// Alert severity level
	Severity AlertSeverity `json:"severity"`
	// Notification channels
	Channels []string `json:"channels"`
	// Throttle configuration
	Throttle graphql.Omittable[*ThrottleConfigInput] `json:"throttle,omitempty"`
	// Quiet hours configuration
	QuietHours graphql.Omittable[*QuietHoursConfigInput] `json:"quietHours,omitempty"`
	// Escalation configuration (NAS-18.9)
	Escalation graphql.Omittable[*EscalationConfigInput] `json:"escalation,omitempty"`
	// Optional device ID filter
	DeviceID graphql.Omittable[*string] `json:"deviceId,omitempty"`
	// Whether rule is enabled (default: true)
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

type CreateBridgeInput struct {
	Name          string                          `json:"name"`
	Comment       graphql.Omittable[*string]      `json:"comment,omitempty"`
	Protocol      graphql.Omittable[*StpProtocol] `json:"protocol,omitempty"`
	Priority      graphql.Omittable[*int]         `json:"priority,omitempty"`
	VlanFiltering graphql.Omittable[*bool]        `json:"vlanFiltering,omitempty"`
	Pvid          graphql.Omittable[*int]         `json:"pvid,omitempty"`
	Mtu           graphql.Omittable[*int]         `json:"mtu,omitempty"`
}

type CreateBridgeVlanInput struct {
	VlanID          int                         `json:"vlanId"`
	TaggedPortIds   graphql.Omittable[[]string] `json:"taggedPortIds,omitempty"`
	UntaggedPortIds graphql.Omittable[[]string] `json:"untaggedPortIds,omitempty"`
}

// Input for creating a new change set
type CreateChangeSetInput struct {
	// Router to apply changes to
	RouterID string `json:"routerId"`
	// Human-readable name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Source wizard/feature
	Source graphql.Omittable[*string] `json:"source,omitempty"`
}

type CreateChangeSetPayload struct {
	// The created change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for creating a NAT rule.
type CreateNatRuleInput struct {
	// NAT chain (srcnat or dstnat)
	Chain NatChain `json:"chain"`
	// NAT action
	Action NatAction `json:"action"`
	// Source address or CIDR
	SrcAddress graphql.Omittable[*string] `json:"srcAddress,omitempty"`
	// Destination address or CIDR
	DstAddress graphql.Omittable[*string] `json:"dstAddress,omitempty"`
	// Source port or port range
	SrcPort graphql.Omittable[*string] `json:"srcPort,omitempty"`
	// Destination port (1-65535)
	DstPort graphql.Omittable[*string] `json:"dstPort,omitempty"`
	// Protocol (TCP, UDP)
	Protocol graphql.Omittable[*TransportProtocol] `json:"protocol,omitempty"`
	// Target address for NAT
	ToAddresses graphql.Omittable[*string] `json:"toAddresses,omitempty"`
	// Target port(s) for NAT
	ToPorts graphql.Omittable[*string] `json:"toPorts,omitempty"`
	// Incoming interface
	InInterface graphql.Omittable[*string] `json:"inInterface,omitempty"`
	// Outgoing interface
	OutInterface graphql.Omittable[*string] `json:"outInterface,omitempty"`
	// Optional comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
	// Whether rule is disabled
	Disabled graphql.Omittable[*bool] `json:"disabled,omitempty"`
}

// Input for creating a new notification channel configuration
type CreateNotificationChannelConfigInput struct {
	// Type of notification channel
	ChannelType ChannelType `json:"channelType"`
	// Human-readable name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Whether this should be the default configuration
	IsDefault graphql.Omittable[*bool] `json:"isDefault,omitempty"`
	// Full configuration including sensitive fields
	// For Pushover: {"userKey": "...", "apiToken": "...", "device": "...", "baseURL": "..."}
	// For Email: {"host": "...", "port": 587, "from": "...", "username": "...", "password": "...", "tlsMode": "..."}
	Config map[string]any `json:"config"`
}

// Input for creating a new port mirror configuration
type CreatePortMirrorInput struct {
	// Descriptive name for the mirror configuration
	Name string `json:"name"`
	// Source interface IDs to mirror (must be bridge members)
	SourceInterfaceIds []string `json:"sourceInterfaceIds"`
	// Destination interface ID for mirrored traffic
	DestinationInterfaceID string `json:"destinationInterfaceId"`
	// Direction of traffic to mirror (default: BOTH)
	Direction graphql.Omittable[*MirrorDirection] `json:"direction,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Input for creating a new resource
type CreateResourceInput struct {
	// Router to create resource on
	RouterID string `json:"routerId"`
	// Resource type (e.g., 'vpn.wireguard.client')
	Type string `json:"type"`
	// Resource category
	Category ResourceCategory `json:"category"`
	// Initial configuration
	Configuration map[string]any `json:"configuration"`
	// User-defined relationships
	Relationships graphql.Omittable[*ResourceRelationshipsInput] `json:"relationships,omitempty"`
	// Initial tags
	Tags graphql.Omittable[[]string] `json:"tags,omitempty"`
	// Resource description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

type CreateResourcePayload struct {
	// The created resource
	Resource Resource `json:"resource,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for creating a new router connection
type CreateRouterInput struct {
	// User-friendly display name
	Name string `json:"name"`
	// Router hostname or IP address
	Host string `json:"host"`
	// Connection port (default: 8728 for MikroTik API)
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Username for authentication
	Username string `json:"username"`
	// Password for authentication
	Password string `json:"password"`
	// Router platform type
	Platform graphql.Omittable[*RouterPlatform] `json:"platform,omitempty"`
}

type CreateRouterPayload struct {
	// The created router
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during creation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for creating or updating a multi-hop routing chain.
type CreateRoutingChainInput struct {
	// Target device identifier
	DeviceID string `json:"deviceId"`
	// Device MAC address (required if routing_mode=MAC)
	DeviceMac graphql.Omittable[*string] `json:"deviceMac,omitempty"`
	// Device IP address (required if routing_mode=IP)
	DeviceIP graphql.Omittable[*string] `json:"deviceIp,omitempty"`
	// Human-readable device name
	DeviceName graphql.Omittable[*string] `json:"deviceName,omitempty"`
	// Routing mode (MAC or IP matching)
	RoutingMode RoutingMode `json:"routingMode"`
	// Whether to enable kill switch
	KillSwitchEnabled graphql.Omittable[*bool] `json:"killSwitchEnabled,omitempty"`
	// Kill switch behavior mode
	KillSwitchMode graphql.Omittable[*KillSwitchMode] `json:"killSwitchMode,omitempty"`
	// Ordered list of hops (2-5 hops required)
	Hops []*ChainHopInput `json:"hops"`
}

// Input for creating a new routing schedule.
type CreateScheduleInput struct {
	// Device routing ID to schedule
	RoutingID string `json:"routingID"`
	// Days of week (0=Sunday, 6=Saturday)
	Days []int `json:"days"`
	// Start time in HH:MM format (24-hour)
	StartTime string `json:"startTime"`
	// End time in HH:MM format (24-hour)
	EndTime string `json:"endTime"`
	// IANA timezone identifier
	Timezone string `json:"timezone"`
	// Whether schedule is enabled (default: true)
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

// Input for creating a webhook
type CreateWebhookInput struct {
	// Human-readable webhook name
	Name string `json:"name"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Webhook URL endpoint
	URL string `json:"url"`
	// HTTP method (default: POST)
	Method graphql.Omittable[*string] `json:"method,omitempty"`
	// Authentication type (default: NONE)
	AuthType graphql.Omittable[*WebhookAuthType] `json:"authType,omitempty"`
	// Username for Basic auth
	Username graphql.Omittable[*string] `json:"username,omitempty"`
	// Password for Basic auth
	Password graphql.Omittable[*string] `json:"password,omitempty"`
	// Bearer token for Bearer auth
	BearerToken graphql.Omittable[*string] `json:"bearerToken,omitempty"`
	// Custom HTTP headers (as JSON object)
	Headers graphql.Omittable[map[string]any] `json:"headers,omitempty"`
	// Template type for webhook payload (default: GENERIC)
	Template graphql.Omittable[*WebhookTemplate] `json:"template,omitempty"`
	// Custom template body (required if template is CUSTOM)
	CustomTemplate graphql.Omittable[*string] `json:"customTemplate,omitempty"`
	// Signing secret for HMAC signature (optional)
	SigningSecret graphql.Omittable[*string] `json:"signingSecret,omitempty"`
	// Timeout in seconds (default: 10)
	TimeoutSeconds graphql.Omittable[*int] `json:"timeoutSeconds,omitempty"`
	// Whether to retry failed deliveries (default: true)
	RetryEnabled graphql.Omittable[*bool] `json:"retryEnabled,omitempty"`
	// Maximum retry attempts (default: 3)
	MaxRetries graphql.Omittable[*int] `json:"maxRetries,omitempty"`
	// Whether webhook is enabled (default: true)
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

// Result of testing a single router's credentials.
type CredentialTestResult struct {
	// Router ID that was tested
	RouterID string `json:"routerId"`
	// Router name for display
	RouterName string `json:"routerName"`
	// Whether the test was successful
	Success bool `json:"success"`
	// Connection status
	Status CredentialTestStatus `json:"status"`
	// Response time in milliseconds (if successful)
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if test failed
	Error *string `json:"error,omitempty"`
}

// Result of updating router credentials.
type CredentialUpdatePayload struct {
	// Whether the update was successful
	Success bool `json:"success"`
	// Human-readable message about the operation
	Message string `json:"message"`
	// Updated credential info (without password)
	Credentials *RouterCredentials `json:"credentials,omitempty"`
	// Error code if update failed
	ErrorCode *CredentialErrorCode `json:"errorCode,omitempty"`
	// Errors that occurred during update
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating router credentials.
// Both username and password must be provided.
type CredentialsInput struct {
	// Username for router authentication
	Username string `json:"username"`
	// Password for router authentication
	Password string `json:"password"`
}

// Current item information in progress event
type CurrentItemInfo struct {
	ID        string              `json:"id"`
	Name      string              `json:"name"`
	Operation ChangeOperation     `json:"operation"`
	Status    ChangeSetItemStatus `json:"status"`
}

// DHCP Server resource
type DHCPServerResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]any         `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Server name
	Name string `json:"name"`
	// Interface serving DHCP
	Interface string `json:"interface"`
	// Address pool name
	AddressPool string `json:"addressPool"`
	// Lease time
	LeaseTime Duration `json:"leaseTime"`
	// Number of active leases
	ActiveLeases *int `json:"activeLeases,omitempty"`
}

func (DHCPServerResource) IsResource() {}

func (DHCPServerResource) IsNode() {}

// Daily statistics
type DailyStats struct {
	// Date (UTC)
	Date time.Time `json:"date"`
	// Total bytes in
	TotalBytesIn Size `json:"totalBytesIn"`
	// Total bytes out
	TotalBytesOut Size `json:"totalBytesOut"`
	// Uptime percentage (0-100)
	UptimePercent float64 `json:"uptimePercent"`
	// Error count
	ErrorCount int `json:"errorCount"`
	// Peak throughput in (bytes/sec)
	PeakThroughputIn Size `json:"peakThroughputIn"`
	// Peak throughput out (bytes/sec)
	PeakThroughputOut Size `json:"peakThroughputOut"`
}

type DeleteChangeSetPayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for deleting a service instance.
type DeleteInstanceInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Instance ID to delete
	InstanceID string `json:"instanceID"`
}

// Delete operation payload
type DeletePayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// ID of deleted item
	DeletedID *string `json:"deletedId,omitempty"`
	// Errors encountered during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

type DeleteResourcePayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// ID of deleted resource
	DeletedID *string `json:"deletedId,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of a delete operation
type DeleteResult struct {
	// Whether the deletion succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// Errors that occurred during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

type DeleteRouterPayload struct {
	// Whether deletion was successful
	Success bool `json:"success"`
	// ID of the deleted router
	DeletedRouterID *string `json:"deletedRouterId,omitempty"`
	// Errors that occurred during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

// DependencyGraph represents the full dependency graph for visualization.
type DependencyGraph struct {
	Nodes []*DependencyGraphNode `json:"nodes"`
	Edges []*DependencyGraphEdge `json:"edges"`
}

// DependencyGraphEdge represents a dependency relationship edge in the graph.
type DependencyGraphEdge struct {
	FromInstanceID       string         `json:"fromInstanceId"`
	ToInstanceID         string         `json:"toInstanceId"`
	DependencyType       DependencyType `json:"dependencyType"`
	AutoStart            bool           `json:"autoStart"`
	HealthTimeoutSeconds int            `json:"healthTimeoutSeconds"`
}

// DependencyGraphNode represents a service instance node in the graph.
type DependencyGraphNode struct {
	InstanceID   string `json:"instanceId"`
	InstanceName string `json:"instanceName"`
	FeatureID    string `json:"featureId"`
	Status       string `json:"status"`
}

// Status of a required dependency
type DependencyStatus struct {
	// Dependency resource UUID
	ResourceUUID string `json:"resourceUuid"`
	// Dependency resource type
	ResourceType string `json:"resourceType"`
	// Whether the dependency is active
	IsActive bool `json:"isActive"`
	// Current state of the dependency
	State ResourceLifecycleState `json:"state"`
	// Why this dependency is required
	Reason string `json:"reason"`
}

// Layer 3: What's actually on router after Apply-Confirm.
// Includes router-generated fields like IDs and computed values.
type DeploymentState struct {
	// Router-generated resource ID (e.g., '*1A' in MikroTik)
	RouterResourceID *string `json:"routerResourceId,omitempty"`
	// When the resource was applied
	AppliedAt time.Time `json:"appliedAt"`
	// User who applied the resource
	AppliedBy *string `json:"appliedBy,omitempty"`
	// Version number on router
	RouterVersion *int `json:"routerVersion,omitempty"`
	// Router-generated fields (public key, computed values, etc.)
	GeneratedFields map[string]any `json:"generatedFields,omitempty"`
	// Whether deployment matches configuration (no drift)
	IsInSync bool `json:"isInSync"`
	// Detected drift from configuration
	Drift *DriftInfo `json:"drift,omitempty"`
	// Apply operation ID for audit trail
	ApplyOperationID *string `json:"applyOperationId,omitempty"`
}

type DeprecateResourcePayload struct {
	// The deprecated resource
	Resource Resource `json:"resource,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Device (router) for querying resource metrics
type Device struct {
	// Device identifier
	ID string `json:"id"`
	// Current resource utilization metrics
	ResourceMetrics *ResourceMetrics `json:"resourceMetrics"`
}

// Device routing assignment.
// Maps a client device to a service instance via Policy-Based Routing (PBR).
type DeviceRouting struct {
	// Routing assignment ID (ULID)
	ID string `json:"id"`
	// Device identifier
	DeviceID string `json:"deviceID"`
	// Device MAC address
	MacAddress string `json:"macAddress"`
	// Device IP address (optional)
	DeviceIP *string `json:"deviceIP,omitempty"`
	// Device hostname (optional)
	DeviceName *string `json:"deviceName,omitempty"`
	// Service instance ID
	InstanceID string `json:"instanceID"`
	// Virtual interface ID
	InterfaceID string `json:"interfaceID"`
	// Routing mark
	RoutingMark string `json:"routingMark"`
	// Routing mode (MAC-based or IP-based)
	RoutingMode RoutingMode `json:"routingMode"`
	// Whether the assignment is active
	Active bool `json:"active"`
	// RouterOS mangle rule ID (for O(1) removal)
	MangleRuleID string `json:"mangleRuleID"`
	// Whether kill switch is enabled for this routing
	KillSwitchEnabled bool `json:"killSwitchEnabled"`
	// Kill switch behavior mode
	KillSwitchMode KillSwitchMode `json:"killSwitchMode"`
	// Whether kill switch is currently blocking traffic
	KillSwitchActive bool `json:"killSwitchActive"`
	// Timestamp when kill switch was last activated
	KillSwitchActivatedAt *time.Time `json:"killSwitchActivatedAt,omitempty"`
	// Fallback interface ID when kill_switch_mode=FALLBACK_SERVICE
	KillSwitchFallbackInterfaceID *string `json:"killSwitchFallbackInterfaceID,omitempty"`
	// RouterOS filter rule ID for kill switch (for O(1) cleanup)
	KillSwitchRuleID *string `json:"killSwitchRuleID,omitempty"`
	// When the assignment was created
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// All schedules for this device routing
	Schedules []*RoutingSchedule `json:"schedules"`
	// Whether this routing has any active schedules
	HasSchedules bool `json:"hasSchedules"`
}

// Device routing change event for subscriptions.
type DeviceRoutingEvent struct {
	// Event ID
	ID string `json:"id"`
	// Event type (assigned, removed, updated, kill_switch_activated, kill_switch_deactivated)
	EventType string `json:"eventType"`
	// Router ID
	RouterID string `json:"routerID"`
	// Device routing (null if removed)
	Routing *DeviceRouting `json:"routing,omitempty"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// Complete device routing matrix.
// Provides all data needed for the device-to-service routing UI.
type DeviceRoutingMatrix struct {
	// Discovered network devices
	Devices []*NetworkDevice `json:"devices"`
	// Active virtual interfaces available for routing
	Interfaces []*VirtualInterfaceInfo `json:"interfaces"`
	// Current routing assignments
	Routings []*DeviceRouting `json:"routings"`
	// Summary statistics
	Summary *DeviceRoutingMatrixStats `json:"summary"`
}

// Summary statistics for device routing matrix.
type DeviceRoutingMatrixStats struct {
	// Total discovered devices
	TotalDevices int `json:"totalDevices"`
	// Devices with routing assignments
	RoutedDevices int `json:"routedDevices"`
	// Devices without routing assignments
	UnroutedDevices int `json:"unroutedDevices"`
	// Active virtual interfaces
	ActiveInterfaces int `json:"activeInterfaces"`
	// Devices discovered via DHCP
	DhcpDevices int `json:"dhcpDevices"`
	// Devices discovered via ARP only
	ArpOnlyDevices int `json:"arpOnlyDevices"`
	// Active routing assignments
	ActiveRoutings int `json:"activeRoutings"`
}

// Per-device traffic breakdown for a service instance.
// Shows which devices are consuming bandwidth through this service.
type DeviceTrafficBreakdown struct {
	// Device identifier (MAC or IP)
	DeviceID string `json:"deviceID"`
	// Device MAC address
	MacAddress *string `json:"macAddress,omitempty"`
	// Device IP address
	IPAddress *string `json:"ipAddress,omitempty"`
	// Device hostname (if available)
	DeviceName *string `json:"deviceName,omitempty"`
	// Bytes uploaded by this device
	UploadBytes int `json:"uploadBytes"`
	// Bytes downloaded by this device
	DownloadBytes int `json:"downloadBytes"`
	// Total bytes (upload + download)
	TotalBytes int `json:"totalBytes"`
	// Percentage of total service traffic
	PercentOfTotal float64 `json:"percentOfTotal"`
}

// DHCP client configuration for dynamic WAN IP
type DhcpClient struct {
	// Unique identifier
	ID string `json:"id"`
	// Interface name
	Interface string `json:"interface"`
	// Whether DHCP client is disabled
	Disabled bool `json:"disabled"`
	// Add default route from DHCP
	AddDefaultRoute bool `json:"addDefaultRoute"`
	// Use DNS servers from DHCP
	UsePeerDNS bool `json:"usePeerDNS"`
	// Use NTP servers from DHCP
	UsePeerNtp bool `json:"usePeerNTP"`
	// Current DHCP status
	Status string `json:"status"`
	// Assigned IP address
	Address *IPv4 `json:"address,omitempty"`
	// DHCP server address
	DhcpServer *IPv4 `json:"dhcpServer,omitempty"`
	// Gateway from DHCP
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Lease expiry time
	ExpiresAfter *Duration `json:"expiresAfter,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (DhcpClient) IsNode() {}

// Input for creating/updating DHCP client
type DhcpClientInput struct {
	// Interface to enable DHCP client on
	Interface string `json:"interface"`
	// Add default route (default: true)
	AddDefaultRoute graphql.Omittable[*bool] `json:"addDefaultRoute,omitempty"`
	// Use peer DNS (default: true)
	UsePeerDNS graphql.Omittable[*bool] `json:"usePeerDNS,omitempty"`
	// Use peer NTP (default: true)
	UsePeerNtp graphql.Omittable[*bool] `json:"usePeerNTP,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// DHCP server (minimal type for dependencies)
type DhcpServer struct {
	// DHCP server ID
	ID string `json:"id"`
	// DHCP server name
	Name string `json:"name"`
	// Interface the DHCP server is bound to
	Interface *Interface `json:"interface"`
	// Whether the DHCP server is disabled
	Disabled bool `json:"disabled"`
}

// Comprehensive diagnostic report for a router
type DiagnosticReport struct {
	// Router ID being diagnosed
	RouterID string `json:"routerId"`
	// When the diagnostic was run
	Timestamp time.Time `json:"timestamp"`
	// Whether the router is reachable on the network
	NetworkReachable bool `json:"networkReachable"`
	// Status of each checked port
	PortStatus []*PortStatus `json:"portStatus"`
	// TLS certificate status (if TLS ports were checked)
	TLSStatus *TLSStatus `json:"tlsStatus,omitempty"`
	// Authentication test status
	AuthStatus *AuthStatus `json:"authStatus"`
	// Actionable suggestions based on diagnostic results
	Suggestions []*DiagnosticSuggestion `json:"suggestions"`
	// Raw text report for clipboard/export
	RawReport string `json:"rawReport"`
}

// Result of a single diagnostic test.
// Represents the outcome of a health check or connectivity test.
type DiagnosticResult struct {
	// Result ID (ULID)
	ID string `json:"id"`
	// Instance ID this diagnostic belongs to
	InstanceID string `json:"instanceID"`
	// Test name (e.g., 'tor_socks5', 'process_health')
	TestName string `json:"testName"`
	// Test result status
	Status DiagnosticStatus `json:"status"`
	// Short message describing the result
	Message string `json:"message"`
	// Detailed information about the test result
	Details *string `json:"details,omitempty"`
	// Test execution duration in milliseconds
	DurationMs int `json:"durationMs"`
	// ULID for grouping tests run together
	RunGroupID *string `json:"runGroupID,omitempty"`
	// Additional test-specific metadata (JSON)
	Metadata map[string]any `json:"metadata,omitempty"`
	// Error message if test failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Timestamp when test was executed
	CreatedAt time.Time `json:"createdAt"`
}

func (DiagnosticResult) IsNode() {}

// Actionable diagnostic suggestion
type DiagnosticSuggestion struct {
	// Severity level of the issue
	Severity SuggestionSeverity `json:"severity"`
	// Short title describing the issue
	Title string `json:"title"`
	// Detailed description of the issue
	Description string `json:"description"`
	// Recommended action to resolve the issue
	Action string `json:"action"`
	// Link to relevant documentation
	DocsURL *string `json:"docsUrl,omitempty"`
}

// Complete diagnostic suite for a service type.
// Defines all available tests for a service.
type DiagnosticSuite struct {
	// Service name (e.g., 'tor', 'singbox', 'adguard')
	ServiceName string `json:"serviceName"`
	// Available diagnostic tests
	Tests []*DiagnosticTest `json:"tests"`
}

// A single diagnostic test definition.
// Describes a test that can be run against a service.
type DiagnosticTest struct {
	// Unique test identifier
	Name string `json:"name"`
	// Human-readable description
	Description string `json:"description"`
	// Test category (health, connectivity, dns, http, socks5)
	Category string `json:"category"`
}

// Real-time diagnostic progress event for subscriptions.
// Emitted as each test completes during a diagnostic run.
type DiagnosticsProgress struct {
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Run group ID
	RunGroupID string `json:"runGroupID"`
	// Test result that just completed
	Result *DiagnosticResult `json:"result"`
	// Progress (0-100)
	Progress int `json:"progress"`
	// Completed tests count
	CompletedTests int `json:"completedTests"`
	// Total tests count
	TotalTests int `json:"totalTests"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// Email digest configuration (NAS-18.11)
type DigestConfig struct {
	// Whether digest mode is enabled
	Enabled bool `json:"enabled"`
	// Digest interval in minutes (e.g., 60 for hourly, 1440 for daily)
	IntervalMinutes int `json:"intervalMinutes"`
	// Time of day for daily delivery in HH:MM format (optional, for daily digests)
	Time *string `json:"time,omitempty"`
	// Whether critical alerts bypass digest mode and send immediately
	BypassCritical bool `json:"bypassCritical"`
	// Whether to send digest even when no alerts occurred during the period
	SendEmptyDigest bool `json:"sendEmptyDigest"`
}

// Email digest configuration input (NAS-18.11)
type DigestConfigInput struct {
	// Whether digest mode is enabled
	Enabled bool `json:"enabled"`
	// Digest interval in minutes (e.g., 60 for hourly, 1440 for daily)
	IntervalMinutes int `json:"intervalMinutes"`
	// Time of day for daily delivery in HH:MM format (optional, for daily digests)
	Time graphql.Omittable[*string] `json:"time,omitempty"`
	// Whether critical alerts bypass digest mode and send immediately (default: true)
	BypassCritical graphql.Omittable[*bool] `json:"bypassCritical,omitempty"`
	// Whether to send digest even when no alerts occurred during the period (default: false)
	SendEmptyDigest graphql.Omittable[*bool] `json:"sendEmptyDigest,omitempty"`
}

// Digest summary (NAS-18.11)
type DigestSummary struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Channel ID this digest was sent to
	ChannelID string `json:"channelId"`
	// When the digest was delivered
	DeliveredAt time.Time `json:"deliveredAt"`
	// Number of alerts included in the digest
	AlertCount int `json:"alertCount"`
	// Time period covered by the digest (e.g., "Last hour", "Last 24 hours")
	Period string `json:"period"`
}

// Payload for discarding a provisioning session
type DiscardProvisioningSessionPayload struct {
	// Whether discard succeeded
	Success bool `json:"success"`
	// ID of discarded session
	SessionID string `json:"sessionId"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

type DisconnectRouterPayload struct {
	// The router that was disconnected
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during disconnection
	Errors []*MutationError `json:"errors,omitempty"`
}

// A device discovered during a network scan.
// Only confirmed MikroTik devices are returned (confidence >= 40).
type DiscoveredDevice struct {
	// IP address of the discovered device
	IP string `json:"ip"`
	// Hostname (if reverse DNS resolves)
	Hostname *string `json:"hostname,omitempty"`
	// Open ports found on the device
	Ports []int `json:"ports"`
	// Device type classification
	DeviceType string `json:"deviceType"`
	// Device vendor (always 'MikroTik' for returned results)
	Vendor *string `json:"vendor,omitempty"`
	// RouterOS-specific information (version, board, architecture)
	RouterOSInfo *RouterOSInfo `json:"routerOSInfo,omitempty"`
	// Confidence score for RouterOS detection (40-100)
	Confidence int `json:"confidence"`
	// Detected services (mikrotik-api, mikrotik-winbox, mikrotik-rest, etc.)
	Services []string `json:"services"`
}

// Complete benchmark result comparing all configured DNS servers
type DNSBenchmarkResult struct {
	// Test hostname used for benchmarking
	TestHostname string `json:"testHostname"`
	// Results for each tested server, sorted by response time
	ServerResults []*DNSBenchmarkServerResult `json:"serverResults"`
	// Fastest server
	FastestServer *DNSBenchmarkServerResult `json:"fastestServer,omitempty"`
	// When the benchmark was executed
	Timestamp time.Time `json:"timestamp"`
	// Total benchmark execution time in milliseconds
	TotalTimeMs int `json:"totalTimeMs"`
}

// Benchmark result for a single DNS server
type DNSBenchmarkServerResult struct {
	// DNS server IP address
	Server string `json:"server"`
	// Response time in milliseconds (-1 if unreachable)
	ResponseTimeMs int `json:"responseTimeMs"`
	// Server status (Fastest, Good, Slow, Unreachable)
	Status DNSServerStatus `json:"status"`
	// Whether the server responded successfully
	Success bool `json:"success"`
	// Error message (if server failed)
	Error *string `json:"error,omitempty"`
}

// DNS cache statistics for monitoring cache usage
type DNSCacheStats struct {
	// Total number of entries in the DNS cache
	TotalEntries int `json:"totalEntries"`
	// Cache size used in bytes
	CacheUsedBytes Size `json:"cacheUsedBytes"`
	// Maximum cache size in bytes
	CacheMaxBytes Size `json:"cacheMaxBytes"`
	// Cache usage percentage (0-100)
	CacheUsagePercent float64 `json:"cacheUsagePercent"`
	// Cache hit rate percentage (0-100)
	HitRatePercent *float64 `json:"hitRatePercent,omitempty"`
	// Most queried domains (top 10)
	TopDomains []*DNSTopDomain `json:"topDomains"`
	// When the statistics were collected
	Timestamp time.Time `json:"timestamp"`
}

// Input for DNS lookup operation
type DNSLookupInput struct {
	// Device/router ID to run lookup from
	DeviceID string `json:"deviceId"`
	// Hostname or IP address to look up
	Hostname string `json:"hostname"`
	// DNS record type to query
	RecordType DNSRecordType `json:"recordType"`
	// DNS server to use (defaults to router's configured DNS)
	Server graphql.Omittable[*string] `json:"server,omitempty"`
	// Query timeout in seconds (default: 5)
	Timeout graphql.Omittable[*int] `json:"timeout,omitempty"`
}

// Result of a DNS lookup operation
type DNSLookupResult struct {
	// Hostname that was queried
	Hostname string `json:"hostname"`
	// Record type that was queried
	RecordType DNSRecordType `json:"recordType"`
	// Query status
	Status DNSLookupStatus `json:"status"`
	// Resolved records
	Records []*DNSRecord `json:"records"`
	// DNS server used
	Server string `json:"server"`
	// Query time in milliseconds
	QueryTime int `json:"queryTime"`
	// Whether response was authoritative
	Authoritative bool `json:"authoritative"`
	// Error message (if query failed)
	Error *string `json:"error,omitempty"`
	// When the query was executed
	Timestamp time.Time `json:"timestamp"`
}

// Single DNS record
type DNSRecord struct {
	// Record name (query hostname)
	Name string `json:"name"`
	// Record type
	Type DNSRecordType `json:"type"`
	// Time to live in seconds
	TTL int `json:"ttl"`
	// Record data (IP, hostname, text, etc.)
	Data string `json:"data"`
	// Priority (for MX/SRV records)
	Priority *int `json:"priority,omitempty"`
	// Weight (for SRV records)
	Weight *int `json:"weight,omitempty"`
	// Port (for SRV records)
	Port *int `json:"port,omitempty"`
}

// DNS server configuration
type DNSServer struct {
	// Server IP address
	Address string `json:"address"`
	// Whether this is the primary DNS server
	IsPrimary bool `json:"isPrimary"`
	// Whether this is the secondary DNS server
	IsSecondary bool `json:"isSecondary"`
}

// Collection of DNS servers
type DNSServers struct {
	// All configured DNS servers
	Servers []*DNSServer `json:"servers"`
	// Primary DNS server address
	Primary string `json:"primary"`
	// Secondary DNS server address (if configured)
	Secondary *string `json:"secondary,omitempty"`
}

// A frequently queried domain in the DNS cache
type DNSTopDomain struct {
	// Domain name
	Domain string `json:"domain"`
	// Number of queries for this domain
	QueryCount int `json:"queryCount"`
	// Last query time
	LastQueried *time.Time `json:"lastQueried,omitempty"`
}

// A field that has drifted from configuration
type DriftField struct {
	// Field path
	Path string `json:"path"`
	// Expected value (from configuration)
	Expected map[string]any `json:"expected,omitempty"`
	// Actual value (from router)
	Actual map[string]any `json:"actual,omitempty"`
}

// Information about configuration drift
type DriftInfo struct {
	// When drift was detected
	DetectedAt time.Time `json:"detectedAt"`
	// Fields that have drifted
	DriftedFields []*DriftField `json:"driftedFields"`
	// Suggested action to resolve drift
	SuggestedAction DriftAction `json:"suggestedAction"`
}

// Email notification configuration
type EmailConfig struct {
	// Whether email notifications are enabled
	Enabled bool `json:"enabled"`
	// SMTP server hostname
	Host *string `json:"host,omitempty"`
	// SMTP server port
	Port *int `json:"port,omitempty"`
	// SMTP username for authentication
	Username *string `json:"username,omitempty"`
	// Email sender address
	FromAddress *string `json:"fromAddress,omitempty"`
	// Email sender display name
	FromName *string `json:"fromName,omitempty"`
	// Array of recipient email addresses
	ToAddresses []string `json:"toAddresses"`
	// Whether to use TLS/SSL
	UseTLS *bool `json:"useTLS,omitempty"`
	// Skip TLS certificate verification (use with caution)
	SkipVerify *bool `json:"skipVerify,omitempty"`
}

// Email notification configuration input
type EmailConfigInput struct {
	// Whether email notifications are enabled
	Enabled bool `json:"enabled"`
	// SMTP server hostname
	Host graphql.Omittable[*string] `json:"host,omitempty"`
	// SMTP server port
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// SMTP username for authentication
	Username graphql.Omittable[*string] `json:"username,omitempty"`
	// SMTP password for authentication
	Password graphql.Omittable[*string] `json:"password,omitempty"`
	// Email sender address
	FromAddress graphql.Omittable[*string] `json:"fromAddress,omitempty"`
	// Email sender display name
	FromName graphql.Omittable[*string] `json:"fromName,omitempty"`
	// Array of recipient email addresses
	ToAddresses []string `json:"toAddresses"`
	// Whether to use TLS/SSL
	UseTLS graphql.Omittable[*bool] `json:"useTLS,omitempty"`
	// Skip TLS certificate verification (use with caution)
	SkipVerify graphql.Omittable[*bool] `json:"skipVerify,omitempty"`
}

// EoIP Tunnel resource implementing 8-layer model
type EoIPTunnel struct {
	ID             string                 `json:"id"`
	ScopedID       string                 `json:"scopedId"`
	Type           string                 `json:"type"`
	Category       ResourceCategory       `json:"category"`
	Configuration  map[string]any         `json:"configuration,omitempty"`
	Validation     *ValidationResult      `json:"validation,omitempty"`
	Deployment     *DeploymentState       `json:"deployment,omitempty"`
	Runtime        *RuntimeState          `json:"runtime,omitempty"`
	Telemetry      *TelemetryData         `json:"telemetry,omitempty"`
	Metadata       *ResourceMetadata      `json:"metadata"`
	Relationships  *ResourceRelationships `json:"relationships,omitempty"`
	Platform       *PlatformInfo          `json:"platform,omitempty"`
	Config         *EoIPTunnelConfig      `json:"config"`
	EoipDeployment *EoIPTunnelDeployment  `json:"eoipDeployment,omitempty"`
	EoipRuntime    *EoIPTunnelRuntime     `json:"eoipRuntime,omitempty"`
}

func (EoIPTunnel) IsResource() {}

func (EoIPTunnel) IsNode() {}

// EoIP tunnel configuration
type EoIPTunnelConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// Tunnel ID (MikroTik specific)
	TunnelID int `json:"tunnelId"`
	// Remote tunnel endpoint
	RemoteAddress IPv4 `json:"remoteAddress"`
	// Optional comment/description
	Comment *string `json:"comment,omitempty"`
	// Enable tunnel
	Enabled *bool `json:"enabled,omitempty"`
}

// EoIP tunnel deployment state
type EoIPTunnelDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// EoIP tunnel runtime state
type EoIPTunnelRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether tunnel is up
	IsUp bool `json:"isUp"`
	// Current remote address being used
	CurrentRemote *IPv4 `json:"currentRemote,omitempty"`
	// MTU of tunnel
	Mtu *int `json:"mtu,omitempty"`
	// Bytes transmitted through tunnel
	BytesSent Size `json:"bytesSent"`
	// Bytes received through tunnel
	BytesReceived Size `json:"bytesReceived"`
}

// Rich error extensions for detailed error diagnostics.
// Included in GraphQL error responses under the 'extensions' key.
type ErrorExtensions struct {
	// Error code for programmatic handling (e.g., 'V400', 'R200')
	Code string `json:"code"`
	// Error category (validation, protocol, network, auth, resource, internal)
	Category string `json:"category"`
	// Field path that caused the error (e.g., 'input.listenPort')
	Field *string `json:"field,omitempty"`
	// The invalid value (redacted in production for sensitive fields)
	Value map[string]any `json:"value,omitempty"`
	// User-friendly suggestion for fixing the error
	SuggestedFix *string `json:"suggestedFix,omitempty"`
	// Link to relevant documentation
	DocsURL *string `json:"docsUrl,omitempty"`
	// Request correlation ID for support and debugging
	RequestID string `json:"requestId"`
	// Whether the error is recoverable (can be retried)
	Recoverable bool `json:"recoverable"`
	// Additional troubleshooting steps for complex errors
	TroubleshootingSteps []string `json:"troubleshootingSteps,omitempty"`
}

// Escalation configuration for unacknowledged alerts (NAS-18.9)
type EscalationConfig struct {
	// Whether escalation is enabled
	Enabled bool `json:"enabled"`
	// Whether alert must be acknowledged to stop escalation
	RequireAck bool `json:"requireAck"`
	// Delay in seconds before first escalation
	EscalationDelay int `json:"escalationDelay"`
	// Maximum number of escalation levels
	MaxEscalations int `json:"maxEscalations"`
	// Additional notification channels to add during escalation
	AdditionalChannels []string `json:"additionalChannels"`
	// Per-level delay intervals in seconds
	RepeatIntervals []int `json:"repeatIntervals"`
}

// Escalation configuration input (NAS-18.9)
type EscalationConfigInput struct {
	// Whether escalation is enabled (default: false)
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
	// Whether alert must be acknowledged to stop escalation (default: true)
	RequireAck graphql.Omittable[*bool] `json:"requireAck,omitempty"`
	// Delay in seconds before first escalation (default: 900 = 15min)
	EscalationDelay graphql.Omittable[*int] `json:"escalationDelay,omitempty"`
	// Maximum number of escalation levels (default: 3)
	MaxEscalations graphql.Omittable[*int] `json:"maxEscalations,omitempty"`
	// Additional notification channels to add during escalation
	AdditionalChannels graphql.Omittable[[]string] `json:"additionalChannels,omitempty"`
	// Per-level delay intervals in seconds (default: [900, 1800, 3600])
	RepeatIntervals graphql.Omittable[[]int] `json:"repeatIntervals,omitempty"`
}

// Input for exporting services as a template
type ExportAsTemplateInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Instance IDs to export
	InstanceIDs []string `json:"instanceIDs"`
	// Template name
	Name string `json:"name"`
	// Template description
	Description string `json:"description"`
	// Template category
	Category ServiceTemplateCategory `json:"category"`
	// Template scope
	Scope TemplateScope `json:"scope"`
}

// Options for exporting router configuration.
type ExportConfigInput struct {
	// Router ID to export configuration from
	RouterID string `json:"routerId"`
	// Whether to include credentials (requires encryptionKey if true)
	IncludeCredentials graphql.Omittable[*bool] `json:"includeCredentials,omitempty"`
	// User-provided encryption key for credential export (required if includeCredentials is true)
	EncryptionKey graphql.Omittable[*string] `json:"encryptionKey,omitempty"`
}

// Result of exporting router configuration.
type ExportConfigPayload struct {
	// Whether the export was successful
	Success bool `json:"success"`
	// Exported configuration data (JSON format)
	Config map[string]any `json:"config,omitempty"`
	// Security warning message about credential handling
	SecurityWarning *string `json:"securityWarning,omitempty"`
	// Errors that occurred during export
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for exporting a service configuration.
type ExportServiceConfigInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Instance ID to export
	InstanceID string `json:"instanceID"`
	// Whether to redact sensitive fields (passwords, API keys, etc.)
	RedactSecrets bool `json:"redactSecrets"`
	// Whether to include device routing rules
	IncludeRoutingRules bool `json:"includeRoutingRules"`
}

// Payload for export service configuration mutation.
type ExportServiceConfigPayload struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// Exported service package (null if failed)
	Package *ServiceExportPackage `json:"package,omitempty"`
	// Download URL for JSON file (15-minute expiry)
	DownloadURL *string `json:"downloadURL,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Failover configuration for multi-link setup
type FailoverConfig struct {
	// Interval between health checks
	CheckInterval Duration `json:"checkInterval"`
	// Number of failed checks before failover
	FailoverThreshold int `json:"failoverThreshold"`
	// Number of successful checks before recovery
	RecoveryThreshold int `json:"recoveryThreshold"`
	// Host to ping for health check
	CheckHost IPv4 `json:"checkHost"`
	// Timeout for each health check
	CheckTimeout *Duration `json:"checkTimeout,omitempty"`
	// Enable failover
	Enabled bool `json:"enabled"`
}

// Information about a feature in the compatibility matrix
type FeatureCompatibilityInfo struct {
	// Feature identifier
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	Name string `json:"name"`
	// Minimum RouterOS version required
	MinVersion string `json:"minVersion"`
	// Maximum RouterOS version supported (if any)
	MaxVersion *string `json:"maxVersion,omitempty"`
	// Minimum version for CHR (if different)
	MinVersionChr *string `json:"minVersionCHR,omitempty"`
	// Required packages
	RequiredPackages []string `json:"requiredPackages"`
	// Feature dependencies
	DependsOn []string `json:"dependsOn"`
	// URL to MikroTik documentation
	UpgradeURL *string `json:"upgradeUrl,omitempty"`
}

// Input for checking feature compatibility
type FeatureCompatibilityInput struct {
	// Feature identifier to check
	FeatureID string `json:"featureId"`
	// Whether to check for CHR-specific requirements
	IsChr graphql.Omittable[*bool] `json:"isCHR,omitempty"`
}

// Feature deployment state
type FeatureDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Container ID (if containerized)
	ContainerID *string `json:"containerId,omitempty"`
	// Container image used
	ContainerImage *string `json:"containerImage,omitempty"`
	// Assigned ports
	AssignedPorts []Port `json:"assignedPorts,omitempty"`
	// Assigned IP address
	AssignedIP *IPv4 `json:"assignedIP,omitempty"`
}

// Marketplace Feature resource (Tor, AdGuard, sing-box, etc.)
type FeatureResource struct {
	ID                string                 `json:"id"`
	ScopedID          string                 `json:"scopedId"`
	Type              string                 `json:"type"`
	Category          ResourceCategory       `json:"category"`
	Configuration     map[string]any         `json:"configuration,omitempty"`
	Validation        *ValidationResult      `json:"validation,omitempty"`
	Deployment        *DeploymentState       `json:"deployment,omitempty"`
	Runtime           *RuntimeState          `json:"runtime,omitempty"`
	Telemetry         *TelemetryData         `json:"telemetry,omitempty"`
	Metadata          *ResourceMetadata      `json:"metadata"`
	Relationships     *ResourceRelationships `json:"relationships,omitempty"`
	Platform          *PlatformInfo          `json:"platform,omitempty"`
	FeatureDeployment *FeatureDeployment     `json:"featureDeployment,omitempty"`
	FeatureRuntime    *FeatureRuntime        `json:"featureRuntime,omitempty"`
	// Feature identifier
	FeatureID string `json:"featureId"`
	// Feature name
	Name string `json:"name"`
	// Feature version
	Version string `json:"version"`
	// Virtual interface assigned
	VirtualInterface *string `json:"virtualInterface,omitempty"`
}

func (FeatureResource) IsResource() {}

func (FeatureResource) IsNode() {}

// Feature runtime state
type FeatureRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Container status
	ContainerStatus *string `json:"containerStatus,omitempty"`
	// Memory usage
	MemoryUsage *Size `json:"memoryUsage,omitempty"`
	// CPU usage percentage
	CPUUsagePercent *float64 `json:"cpuUsagePercent,omitempty"`
	// Devices routed through this feature
	RoutedDevices *int `json:"routedDevices,omitempty"`
}

// Per-feature storage usage breakdown.
// Shows how much space each feature is consuming and where data is stored.
type FeatureStorageUsage struct {
	// Feature identifier (e.g., 'tor', 'sing-box')
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	FeatureName string `json:"featureName"`
	// Binary size in bytes (serialized uint64)
	BinarySize string `json:"binarySize"`
	// Runtime data size in bytes (serialized uint64)
	DataSize string `json:"dataSize"`
	// Config files size in bytes (serialized uint64)
	ConfigSize string `json:"configSize"`
	// Log files size in bytes (serialized uint64)
	LogsSize string `json:"logsSize"`
	// Total size across all components in bytes (serialized uint64)
	TotalSize string `json:"totalSize"`
	// Primary storage location ('flash' or 'external')
	Location string `json:"location"`
	// Number of instances of this feature
	InstanceCount int `json:"instanceCount"`
}

// Feature support information based on RouterOS version
type FeatureSupport struct {
	// Feature identifier (e.g., 'rest_api', 'container', 'wireguard')
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	Name string `json:"name"`
	// Whether the feature is supported on this router
	Supported bool `json:"supported"`
	// Capability level (none, basic, advanced, full)
	Level CapabilityLevel `json:"level"`
	// Reason why the feature is not supported (if applicable)
	Reason *string `json:"reason,omitempty"`
	// Minimum RouterOS version required for this feature
	RequiredVersion *string `json:"requiredVersion,omitempty"`
	// URL to MikroTik documentation for upgrade guidance
	UpgradeURL *string `json:"upgradeUrl,omitempty"`
	// Required packages that need to be installed
	RequiredPackages []string `json:"requiredPackages,omitempty"`
	// Missing packages (if any)
	MissingPackages []string `json:"missingPackages,omitempty"`
}

// Firewall rule placeholder type.
// TODO: Expand with full filter/NAT/mangle rule types in future stories.
type FirewallRule struct {
	// Rule ID
	ID string `json:"id"`
	// Rule type (filter, nat, mangle)
	Type string `json:"type"`
	// Rule chain (input, forward, output, prerouting, postrouting, etc.)
	Chain string `json:"chain"`
	// Rule action (accept, drop, reject, etc.)
	Action string `json:"action"`
	// Source address list reference
	SrcAddressList *string `json:"srcAddressList,omitempty"`
	// Destination address list reference
	DstAddressList *string `json:"dstAddressList,omitempty"`
	// Optional comment
	Comment *string `json:"comment,omitempty"`
	// Whether rule is disabled
	Disabled bool `json:"disabled"`
}

func (FirewallRule) IsNode() {}

// Firewall rule reference type (lightweight for dependency tracking).
// For full firewall rule management, see FirewallRule type in firewall.graphql.
type FirewallRuleReference struct {
	// Firewall rule ID
	ID string `json:"id"`
	// Rule chain
	Chain string `json:"chain"`
	// Rule action
	Action string `json:"action"`
	// Input interface filter
	InInterface *string `json:"inInterface,omitempty"`
	// Output interface filter
	OutInterface *string `json:"outInterface,omitempty"`
	// Whether the rule is disabled
	Disabled bool `json:"disabled"`
}

// Firewall Rule resource
type FirewallRuleResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]any         `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Rule chain (input, forward, output)
	Chain string `json:"chain"`
	// Rule action (accept, drop, reject)
	Action string `json:"action"`
	// Source address/network
	SrcAddress *string `json:"srcAddress,omitempty"`
	// Destination address/network
	DstAddress *string `json:"dstAddress,omitempty"`
	// Source port(s)
	SrcPort *string `json:"srcPort,omitempty"`
	// Destination port(s)
	DstPort *string `json:"dstPort,omitempty"`
	// Protocol (tcp, udp, icmp, etc.)
	Protocol *string `json:"protocol,omitempty"`
	// Rule comment
	Comment *string `json:"comment,omitempty"`
	// Whether rule is enabled
	Enabled bool `json:"enabled"`
	// Hit counter
	HitCount *int `json:"hitCount,omitempty"`
}

func (FirewallRuleResource) IsResource() {}

func (FirewallRuleResource) IsNode() {}

// Firewall template with pre-configured rule sets.
// Templates allow quick application of common firewall configurations.
type FirewallTemplate struct {
	// Unique template identifier
	ID string `json:"id"`
	// Human-readable template name
	Name string `json:"name"`
	// Detailed description of what this template does
	Description string `json:"description"`
	// Category for organization
	Category TemplateCategory `json:"category"`
	// Complexity level indicator
	Complexity TemplateComplexity `json:"complexity"`
	// Total number of rules in this template
	RuleCount int `json:"ruleCount"`
	// Variables that can be customized before applying
	Variables []*FirewallTemplateVariable `json:"variables"`
	// Rules that will be created
	Rules []*TemplateRule `json:"rules"`
	// Whether this is a built-in template
	IsBuiltIn bool `json:"isBuiltIn"`
	// Template version for compatibility tracking
	Version string `json:"version"`
	// When this template was created (null for built-in)
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	// When this template was last modified (null for built-in)
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// Result of template application.
type FirewallTemplateResult struct {
	// Whether application succeeded
	Success bool `json:"success"`
	// Number of rules successfully applied
	AppliedRulesCount int `json:"appliedRulesCount"`
	// Rollback ID for undo (valid for 5 minutes)
	RollbackID string `json:"rollbackId"`
	// Errors encountered during application
	Errors []string `json:"errors,omitempty"`
}

// Variable definition for template customization.
// Variables allow parameterization of templates for different network configurations.
type FirewallTemplateVariable struct {
	// Variable name (used in rule properties)
	Name string `json:"name"`
	// Human-readable label for UI
	Label string `json:"label"`
	// Variable type for validation
	Type VariableType `json:"type"`
	// Default value if not specified
	DefaultValue *string `json:"defaultValue,omitempty"`
	// Whether this variable is required
	Required bool `json:"required"`
	// Description to help users understand the variable
	Description *string `json:"description,omitempty"`
	// Available options (populated from router for INTERFACE type)
	Options []string `json:"options,omitempty"`
}

// Input for defining a template variable.
type FirewallTemplateVariableInput struct {
	// Variable name
	Name string `json:"name"`
	// Label for UI
	Label string `json:"label"`
	// Variable type
	Type VariableType `json:"type"`
	// Default value
	DefaultValue graphql.Omittable[*string] `json:"defaultValue,omitempty"`
	// Whether required
	Required bool `json:"required"`
	// Description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

// Result of flushing the DNS cache
type FlushDNSCacheResult struct {
	// Whether the cache was flushed successfully
	Success bool `json:"success"`
	// Number of entries removed from the cache
	EntriesRemoved int `json:"entriesRemoved"`
	// Cache statistics before flushing
	BeforeStats *DNSCacheStats `json:"beforeStats"`
	// Cache statistics after flushing
	AfterStats *DNSCacheStats `json:"afterStats"`
	// User-friendly message
	Message string `json:"message"`
	// When the flush was executed
	Timestamp time.Time `json:"timestamp"`
}

// GRE Tunnel resource implementing 8-layer model
type GRETunnel struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]any         `json:"configuration,omitempty"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	Config        *GRETunnelConfig       `json:"config"`
	GreDeployment *GRETunnelDeployment   `json:"greDeployment,omitempty"`
	GreRuntime    *GRETunnelRuntime      `json:"greRuntime,omitempty"`
}

func (GRETunnel) IsResource() {}

func (GRETunnel) IsNode() {}

// GRE tunnel configuration
type GRETunnelConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// Local tunnel address
	LocalAddress IPv4 `json:"localAddress"`
	// Remote tunnel address (other end)
	RemoteAddress IPv4 `json:"remoteAddress"`
	// Optional comment/description
	Comment *string `json:"comment,omitempty"`
	// Keep alive interval
	KeepaliveInterval *Duration `json:"keepaliveInterval,omitempty"`
	// Enable tunnel
	Enabled *bool `json:"enabled,omitempty"`
}

// GRE tunnel deployment state
type GRETunnelDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// GRE tunnel runtime state
type GRETunnelRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether tunnel is up
	IsUp bool `json:"isUp"`
	// MTU of tunnel
	Mtu *int `json:"mtu,omitempty"`
	// Bytes transmitted through tunnel
	BytesSent Size `json:"bytesSent"`
	// Bytes received through tunnel
	BytesReceived Size `json:"bytesReceived"`
	// Packets transmitted
	PacketsSent int `json:"packetsSent"`
	// Packets received
	PacketsReceived int `json:"packetsReceived"`
}

// Gateway monitoring information for SOCKS-to-TUN gateway instances.
// Provides visibility into hev-socks5-tunnel processes.
type GatewayInfo struct {
	// Current gateway state
	State GatewayState `json:"state"`
	// TUN interface name (e.g., tun-tor-usa)
	TunName *string `json:"tunName,omitempty"`
	// Process ID of gateway
	Pid *int `json:"pid,omitempty"`
	// Uptime duration in seconds
	Uptime *int `json:"uptime,omitempty"`
	// Last health check timestamp
	LastHealthCheck *time.Time `json:"lastHealthCheck,omitempty"`
	// Error message if in ERROR state
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// Result of checking gateway reachability
type GatewayReachabilityResult struct {
	// Whether the gateway is reachable
	Reachable bool `json:"reachable"`
	// Ping latency in milliseconds (null if unreachable)
	Latency *int `json:"latency,omitempty"`
	// Interface through which gateway is reachable (null if unreachable)
	Interface *string `json:"interface,omitempty"`
	// Human-readable message about reachability
	Message string `json:"message"`
}

// Input for generating a QR code for service config.
type GenerateConfigQRInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Instance ID to generate QR code for
	InstanceID string `json:"instanceID"`
	// Whether to redact sensitive fields
	RedactSecrets bool `json:"redactSecrets"`
	// Whether to include routing rules
	IncludeRoutingRules bool `json:"includeRoutingRules"`
	// QR code image size in pixels (default 256)
	ImageSize graphql.Omittable[*int] `json:"imageSize,omitempty"`
}

// Payload for generate config QR mutation.
type GenerateConfigQRPayload struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// Base64-encoded PNG image data
	ImageDataBase64 *string `json:"imageDataBase64,omitempty"`
	// Download URL for PNG file (15-minute expiry)
	DownloadURL *string `json:"downloadURL,omitempty"`
	// QR code data size in bytes (before encoding)
	DataSize *int `json:"dataSize,omitempty"`
	// PNG image size in bytes
	ImageSize *int `json:"imageSize,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Hardware information detected from router
type HardwareInfo struct {
	// CPU architecture (arm, arm64, x86_64, etc.)
	Architecture string `json:"architecture"`
	// Router model name
	Model *string `json:"model,omitempty"`
	// Board name
	BoardName *string `json:"boardName,omitempty"`
	// Total RAM in bytes
	TotalMemory Size `json:"totalMemory"`
	// Available storage in bytes
	AvailableStorage Size `json:"availableStorage"`
	// Number of CPU cores
	CPUCount int `json:"cpuCount"`
	// Whether wireless hardware is present
	HasWirelessChip bool `json:"hasWirelessChip"`
	// Whether LTE/cellular hardware is present
	HasLTEModule bool `json:"hasLTEModule"`
}

// Health check result for a router
type HealthCheckResult struct {
	// Router ID
	RouterID string `json:"routerId"`
	// Whether the router is healthy
	Healthy bool `json:"healthy"`
	// When the check was performed
	CheckedAt time.Time `json:"checkedAt"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if unhealthy
	Error *string `json:"error,omitempty"`
}

// Overall system health status
type HealthStatus struct {
	// Service status
	Status ServiceStatus `json:"status"`
	// Service version
	Version string `json:"version"`
	// Server uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Connected router count
	ConnectedRouters int `json:"connectedRouters"`
	// Last health check timestamp
	CheckedAt time.Time `json:"checkedAt"`
}

// A single probe result within a hop
type HopProbe struct {
	// Probe number (1-3 typically)
	ProbeNumber int `json:"probeNumber"`
	// Latency in milliseconds (null for timeout)
	LatencyMs *float64 `json:"latencyMs,omitempty"`
	// Whether the probe succeeded
	Success bool `json:"success"`
	// ICMP error code if probe failed
	ICMPCode *string `json:"icmpCode,omitempty"`
}

// Hourly statistics
type HourlyStats struct {
	// Hour start timestamp
	Hour time.Time `json:"hour"`
	// Total bytes in
	TotalBytesIn Size `json:"totalBytesIn"`
	// Total bytes out
	TotalBytesOut Size `json:"totalBytesOut"`
	// Uptime percentage (0-100)
	UptimePercent float64 `json:"uptimePercent"`
	// Error count
	ErrorCount int `json:"errorCount"`
}

// IKEv2 VPN Client resource implementing 8-layer model
type IKEv2Client struct {
	ID              string                 `json:"id"`
	ScopedID        string                 `json:"scopedId"`
	Type            string                 `json:"type"`
	Category        ResourceCategory       `json:"category"`
	Configuration   map[string]any         `json:"configuration,omitempty"`
	Validation      *ValidationResult      `json:"validation,omitempty"`
	Deployment      *DeploymentState       `json:"deployment,omitempty"`
	Runtime         *RuntimeState          `json:"runtime,omitempty"`
	Telemetry       *TelemetryData         `json:"telemetry,omitempty"`
	Metadata        *ResourceMetadata      `json:"metadata"`
	Relationships   *ResourceRelationships `json:"relationships,omitempty"`
	Platform        *PlatformInfo          `json:"platform,omitempty"`
	Config          *IKEv2ClientConfig     `json:"config"`
	Ikev2Deployment *IKEv2Deployment       `json:"ikev2Deployment,omitempty"`
	Ikev2Runtime    *IKEv2Runtime          `json:"ikev2Runtime,omitempty"`
}

func (IKEv2Client) IsResource() {}

func (IKEv2Client) IsNode() {}

// IKEv2 client configuration
type IKEv2ClientConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// VPN server address
	Server string `json:"server"`
	// VPN server port
	Port *Port `json:"port,omitempty"`
	// Username
	Username string `json:"username"`
	// Password
	Password string `json:"password"`
	// Authentication method
	AuthMethod string `json:"authMethod"`
	// Local identity
	LocalIdentity string `json:"localIdentity"`
	// Remote identity (gateway)
	RemoteIdentity string `json:"remoteIdentity"`
	// Encryption algorithm (aes128, aes192, aes256, etc.)
	EncAlgorithm string `json:"encAlgorithm"`
	// Integrity algorithm (sha1, sha256, sha384, sha512)
	IntAlgorithm string `json:"intAlgorithm"`
	// DH Group (group2, group14, group15, etc.)
	DhGroup string `json:"dhGroup"`
	// WAN interface to use
	WanInterface *string `json:"wanInterface,omitempty"`
}

// IKEv2 deployment state
type IKEv2Deployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// IKEv2 runtime state
type IKEv2Runtime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether connected to VPN
	IsConnected bool `json:"isConnected"`
	// Connection uptime
	ConnectionUptime *Duration `json:"connectionUptime,omitempty"`
	// Tunnel IP address
	TunnelAddress *IPv4 `json:"tunnelAddress,omitempty"`
	// Bytes in
	BytesIn Size `json:"bytesIn"`
	// Bytes out
	BytesOut Size `json:"bytesOut"`
}

// IKEv2 Server resource implementing 8-layer model
type IKEv2Server struct {
	ID                    string                 `json:"id"`
	ScopedID              string                 `json:"scopedId"`
	Type                  string                 `json:"type"`
	Category              ResourceCategory       `json:"category"`
	Configuration         map[string]any         `json:"configuration,omitempty"`
	Validation            *ValidationResult      `json:"validation,omitempty"`
	Deployment            *DeploymentState       `json:"deployment,omitempty"`
	Runtime               *RuntimeState          `json:"runtime,omitempty"`
	Telemetry             *TelemetryData         `json:"telemetry,omitempty"`
	Metadata              *ResourceMetadata      `json:"metadata"`
	Relationships         *ResourceRelationships `json:"relationships,omitempty"`
	Platform              *PlatformInfo          `json:"platform,omitempty"`
	Config                *IKEv2ServerConfig     `json:"config"`
	Ikev2ServerDeployment *IKEv2ServerDeployment `json:"ikev2ServerDeployment,omitempty"`
	Ikev2ServerRuntime    *IKEv2ServerRuntime    `json:"ikev2ServerRuntime,omitempty"`
}

func (IKEv2Server) IsResource() {}

func (IKEv2Server) IsNode() {}

// IKEv2 server configuration
type IKEv2ServerConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// Server profile ID
	Profile string `json:"profile"`
	// Server proposal (encryption/auth)
	Proposal string `json:"proposal"`
	// Peer configuration ID
	Peer string `json:"peer"`
	// Server identity
	Identity string `json:"identity"`
	// Traffic policy ID
	Policy string `json:"policy"`
	// Listen port
	Port Port `json:"port"`
	// Server certificate
	Certificate string `json:"certificate"`
	// Server private key
	PrivateKey string `json:"privateKey"`
	// CA certificate
	CaCertificate *string `json:"caCertificate,omitempty"`
}

// IKEv2 server deployment state
type IKEv2ServerDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
}

// IKEv2 server runtime state
type IKEv2ServerRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether server is accepting connections
	IsAccepting bool `json:"isAccepting"`
	// Number of active SAs
	ActiveSAs int `json:"activeSAs"`
	// Number of connected clients
	ConnectedClients int `json:"connectedClients"`
	// Total bytes received
	BytesReceived Size `json:"bytesReceived"`
	// Total bytes sent
	BytesSent Size `json:"bytesSent"`
}

// IPIP Tunnel resource implementing 8-layer model
type IPIPTunnel struct {
	ID             string                 `json:"id"`
	ScopedID       string                 `json:"scopedId"`
	Type           string                 `json:"type"`
	Category       ResourceCategory       `json:"category"`
	Configuration  map[string]any         `json:"configuration,omitempty"`
	Validation     *ValidationResult      `json:"validation,omitempty"`
	Deployment     *DeploymentState       `json:"deployment,omitempty"`
	Runtime        *RuntimeState          `json:"runtime,omitempty"`
	Telemetry      *TelemetryData         `json:"telemetry,omitempty"`
	Metadata       *ResourceMetadata      `json:"metadata"`
	Relationships  *ResourceRelationships `json:"relationships,omitempty"`
	Platform       *PlatformInfo          `json:"platform,omitempty"`
	Config         *IPIPTunnelConfig      `json:"config"`
	IpipDeployment *IPIPTunnelDeployment  `json:"ipipDeployment,omitempty"`
	IpipRuntime    *IPIPTunnelRuntime     `json:"ipipRuntime,omitempty"`
}

func (IPIPTunnel) IsResource() {}

func (IPIPTunnel) IsNode() {}

// IPIP tunnel configuration
type IPIPTunnelConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// Local tunnel address
	LocalAddress IPv4 `json:"localAddress"`
	// Remote tunnel address (other end)
	RemoteAddress IPv4 `json:"remoteAddress"`
	// Optional comment/description
	Comment *string `json:"comment,omitempty"`
	// Keep alive interval
	KeepaliveInterval *Duration `json:"keepaliveInterval,omitempty"`
	// Enable tunnel
	Enabled *bool `json:"enabled,omitempty"`
}

// IPIP tunnel deployment state
type IPIPTunnelDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// IPIP tunnel runtime state
type IPIPTunnelRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether tunnel is up
	IsUp bool `json:"isUp"`
	// MTU of tunnel
	Mtu *int `json:"mtu,omitempty"`
	// Bytes transmitted through tunnel
	BytesSent Size `json:"bytesSent"`
	// Bytes received through tunnel
	BytesReceived Size `json:"bytesReceived"`
	// Packets transmitted
	PacketsSent int `json:"packetsSent"`
	// Packets received
	PacketsReceived int `json:"packetsReceived"`
}

// ISP contact information
type ISPInfo struct {
	// ISP name
	Name string `json:"name"`
	// ISP support phone number
	Phone *string `json:"phone,omitempty"`
	// ISP support website URL
	URL *string `json:"url,omitempty"`
}

// Analysis of template application impact.
// Provides estimates and warnings before applying.
type ImpactAnalysis struct {
	// Number of new rules that will be created
	NewRulesCount int `json:"newRulesCount"`
	// Chains that will be affected
	AffectedChains []string `json:"affectedChains"`
	// Estimated time to apply (seconds)
	EstimatedApplyTime int `json:"estimatedApplyTime"`
	// Warnings about potential issues
	Warnings []string `json:"warnings"`
}

// Input for importing a service configuration.
// Performs validation only, does not apply changes.
type ImportServiceConfigInput struct {
	// Router ID to import into
	RouterID string `json:"routerID"`
	// Service export package (JSON)
	Package map[string]any `json:"package"`
	// Conflict resolution strategy (required if conflicts exist)
	ConflictResolution graphql.Omittable[*ConflictResolution] `json:"conflictResolution,omitempty"`
	// User-provided values for redacted fields (map of field name to value)
	RedactedFieldValues graphql.Omittable[map[string]any] `json:"redactedFieldValues,omitempty"`
	// Device MAC addresses to filter routing rules (optional)
	DeviceFilter graphql.Omittable[[]string] `json:"deviceFilter,omitempty"`
	// Dry-run mode (validate only, don't create instance)
	DryRun graphql.Omittable[*bool] `json:"dryRun,omitempty"`
}

// Payload for import service configuration mutation.
// Returns validation results without applying changes.
type ImportServiceConfigPayload struct {
	// Whether validation succeeded
	Valid bool `json:"valid"`
	// Validation result
	ValidationResult *ImportValidationResult `json:"validationResult"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for importing a template
type ImportServiceTemplateInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Template JSON data
	TemplateData map[string]any `json:"templateData"`
}

// Input for importing STAR (Setup Template Archive) state
type ImportStarStateInput struct {
	// STAR state JSON - complete router configuration
	StarState map[string]any `json:"starState"`
	// Whether to override existing resources
	OverrideExisting graphql.Omittable[*bool] `json:"overrideExisting,omitempty"`
	// Whether to validate before importing
	ValidateFirst graphql.Omittable[*bool] `json:"validateFirst,omitempty"`
}

// Validation error for service import.
type ImportValidationError struct {
	// Validation stage (schema, syntax, cross-resource, dependency, conflict, capability, dry-run)
	Stage string `json:"stage"`
	// Field name (if applicable)
	Field *string `json:"field,omitempty"`
	// Error code (V400, V403, S600, S602)
	Code string `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
}

// Validation result for service import.
// Contains errors, warnings, and redacted field prompts.
type ImportValidationResult struct {
	// Whether the import package passed validation
	Valid bool `json:"valid"`
	// Validation errors (blocking)
	Errors []*ImportValidationError `json:"errors"`
	// Validation warnings (non-blocking)
	Warnings []*ImportValidationWarning `json:"warnings"`
	// List of fields that were redacted and need user input
	RedactedFields []string `json:"redactedFields,omitempty"`
	// Conflicting service instances (if any)
	ConflictingInstances []*ServiceInstance `json:"conflictingInstances,omitempty"`
	// Whether user input is required to proceed
	RequiresUserInput bool `json:"requiresUserInput"`
}

// Validation warning for service import.
type ImportValidationWarning struct {
	// Validation stage
	Stage string `json:"stage"`
	// Warning message
	Message string `json:"message"`
}

// Installation progress event.
type InstallProgress struct {
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Feature ID
	FeatureID string `json:"featureID"`
	// Bytes downloaded
	BytesDownloaded int `json:"bytesDownloaded"`
	// Total bytes to download
	TotalBytes int `json:"totalBytes"`
	// Download progress percentage (0-100)
	Percent float64 `json:"percent"`
	// Current status (downloading, verifying, completed, failed)
	Status string `json:"status"`
	// Error message if failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// Input for installing a new service instance.
type InstallServiceInput struct {
	// Router ID to install the service on
	RouterID string `json:"routerID"`
	// Feature ID to install (e.g., 'tor', 'sing-box')
	FeatureID string `json:"featureID"`
	// Human-readable instance name
	InstanceName string `json:"instanceName"`
	// Service-specific configuration (JSON)
	Config graphql.Omittable[map[string]any] `json:"config,omitempty"`
	// VLAN ID for network isolation (optional)
	VlanID graphql.Omittable[*int] `json:"vlanID,omitempty"`
	// IP address to bind the service to (optional)
	BindIP graphql.Omittable[*string] `json:"bindIP,omitempty"`
}

// Input for installing a service template
type InstallServiceTemplateInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Template ID to install
	TemplateID string `json:"templateID"`
	// Variable values
	Variables map[string]any `json:"variables"`
	// Dry run (preview only, don't actually install)
	DryRun graphql.Omittable[*bool] `json:"dryRun,omitempty"`
}

// Resource usage details for a single service instance.
// Combines instance metadata with current resource usage.
type InstanceResourceUsage struct {
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Instance name
	InstanceName string `json:"instanceName"`
	// Feature ID
	FeatureID string `json:"featureID"`
	// Current resource usage
	Usage *ResourceUsage `json:"usage"`
	// Resource requirements from manifest
	Requirements *ResourceRequirements `json:"requirements,omitempty"`
}

// Instance status change event.
type InstanceStatusChanged struct {
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Previous status
	PreviousStatus ServiceInstanceStatus `json:"previousStatus"`
	// New status
	NewStatus ServiceInstanceStatus `json:"newStatus"`
	// Timestamp of the change
	Timestamp time.Time `json:"timestamp"`
}

// Integer range for filtering
type IntRange struct {
	// Minimum value (inclusive)
	Min graphql.Omittable[*int] `json:"min,omitempty"`
	// Maximum value (inclusive)
	Max graphql.Omittable[*int] `json:"max,omitempty"`
}

// A network interface on a router
type Interface struct {
	// Unique interface identifier
	ID string `json:"id"`
	// Interface name (e.g., ether1, wlan1)
	Name string `json:"name"`
	// Interface type
	Type InterfaceType `json:"type"`
	// Whether the interface is enabled
	Enabled bool `json:"enabled"`
	// Whether the interface is running (link up)
	Running bool `json:"running"`
	// MAC address
	MacAddress *MAC `json:"macAddress,omitempty"`
	// MTU setting
	Mtu *int `json:"mtu,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// TX bytes
	TxBytes *Size `json:"txBytes,omitempty"`
	// RX bytes
	RxBytes *Size `json:"rxBytes,omitempty"`
	// IP address assigned to this interface
	IP *IPv4 `json:"ip,omitempty"`
	// Operational status of the interface
	Status InterfaceStatus `json:"status"`
	// Current transmit rate in bytes per second
	TxRate *Size `json:"txRate,omitempty"`
	// Current receive rate in bytes per second
	RxRate *Size `json:"rxRate,omitempty"`
	// Link speed (e.g., 1Gbps, 100Mbps)
	LinkSpeed *string `json:"linkSpeed,omitempty"`
	// Last time this interface was seen/queried
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// Connected device information from LLDP
	LinkPartner *string `json:"linkPartner,omitempty"`
	// Services using this interface (bridge, VPN, etc.)
	UsedBy []string `json:"usedBy,omitempty"`
}

func (Interface) IsNode() {}

type InterfaceConnection struct {
	Edges      []*InterfaceEdge `json:"edges"`
	PageInfo   *PageInfo        `json:"pageInfo"`
	TotalCount *int             `json:"totalCount,omitempty"`
}

func (InterfaceConnection) IsConnection() {}

type InterfaceEdge struct {
	Node   *Interface `json:"node"`
	Cursor string     `json:"cursor"`
}

func (InterfaceEdge) IsEdge() {}

// Error information for a single interface operation in a batch
type InterfaceOperationError struct {
	// Interface ID that failed
	InterfaceID string `json:"interfaceId"`
	// Interface name
	InterfaceName string `json:"interfaceName"`
	// Error message describing why the operation failed
	Error string `json:"error"`
}

// Interface traffic statistics
type InterfaceStats struct {
	// Total bytes transmitted
	TxBytes Size `json:"txBytes"`
	// Total bytes received
	RxBytes Size `json:"rxBytes"`
	// Total packets transmitted
	TxPackets Size `json:"txPackets"`
	// Total packets received
	RxPackets Size `json:"rxPackets"`
	// Transmission errors
	TxErrors int `json:"txErrors"`
	// Receive errors
	RxErrors int `json:"rxErrors"`
	// Transmission drops
	TxDrops int `json:"txDrops"`
	// Receive drops
	RxDrops int `json:"rxDrops"`
}

// Historical interface statistics with time-series data
type InterfaceStatsHistory struct {
	// Interface ID
	InterfaceID string `json:"interfaceId"`
	// Time-series data points
	DataPoints []*StatsDataPoint `json:"dataPoints"`
	// Aggregation interval (e.g., 5m, 1h)
	Interval Duration `json:"interval"`
	// Start of the time range
	StartTime time.Time `json:"startTime"`
	// End of the time range
	EndTime time.Time `json:"endTime"`
}

// Event emitted when an interface status changes
type InterfaceStatusEvent struct {
	// Interface ID
	InterfaceID string `json:"interfaceId"`
	// Interface name
	InterfaceName string `json:"interfaceName"`
	// New status
	Status InterfaceStatus `json:"status"`
	// Previous status
	PreviousStatus InterfaceStatus `json:"previousStatus"`
	// Event timestamp
	Timestamp time.Time `json:"timestamp"`
}

type InterfaceTrafficEvent struct {
	// Interface ID
	InterfaceID string `json:"interfaceId"`
	// Interface name
	InterfaceName string `json:"interfaceName"`
	// TX rate in bytes per second
	TxRate Size `json:"txRate"`
	// RX rate in bytes per second
	RxRate Size `json:"rxRate"`
	// Total TX bytes
	TxTotal Size `json:"txTotal"`
	// Total RX bytes
	RxTotal Size `json:"rxTotal"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// An IP address assigned to an interface
type IPAddress struct {
	// Unique IP address identifier
	ID string `json:"id"`
	// IP address with CIDR notation (e.g., 192.168.10.1/24)
	Address string `json:"address"`
	// Network address (calculated from address and netmask)
	Network *string `json:"network,omitempty"`
	// Broadcast address (calculated from address and netmask)
	Broadcast *string `json:"broadcast,omitempty"`
	// Interface this IP is assigned to
	Interface *Interface `json:"interface"`
	// Whether this IP is disabled
	Disabled bool `json:"disabled"`
	// Whether this IP was dynamically assigned (via DHCP client)
	Dynamic bool `json:"dynamic"`
	// Whether this IP is invalid (conflicting or error state)
	Invalid bool `json:"invalid"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (IPAddress) IsNode() {}

// Event emitted when an IP address changes
type IPAddressChangeEvent struct {
	// Type of change (CREATED, UPDATED, DELETED)
	ChangeType ChangeType `json:"changeType"`
	// The IP address that changed
	IPAddress *IPAddress `json:"ipAddress,omitempty"`
	// IP address ID (for deletions)
	IPAddressID string `json:"ipAddressId"`
	// Timestamp of the change
	Timestamp time.Time `json:"timestamp"`
}

// Result of an IP address deletion with dependency checking
type IPAddressDeleteResult struct {
	// Whether the deletion succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// Impact analysis for this IP address deletion
	ImpactAnalysis *IPAddressImpactAnalysis `json:"impactAnalysis,omitempty"`
	// Errors that occurred during deletion
	Errors []*MutationError `json:"errors,omitempty"`
}

// Dependencies for an IP address
type IPAddressDependencies struct {
	// IP address ID
	IPAddressID string `json:"ipAddressId"`
	// DHCP servers using this IP as gateway
	DhcpServers []*DhcpServer `json:"dhcpServers"`
	// Static routes using this IP
	Routes []*Route `json:"routes"`
	// NAT rules referencing this IP
	NatRules []*NatRuleReference `json:"natRules"`
	// Firewall rules referencing this IP
	FirewallRules []*FirewallRuleReference `json:"firewallRules"`
	// Whether the IP has any dependencies
	HasDependencies bool `json:"hasDependencies"`
}

// Analysis of the impact of deleting an IP address
type IPAddressImpactAnalysis struct {
	// Whether this IP is used as a gateway by DHCP servers
	UsedByDhcpServers []*DhcpServer `json:"usedByDhcpServers"`
	// Whether this IP is referenced in firewall rules
	UsedInFirewallRules []*FirewallRuleReference `json:"usedInFirewallRules"`
	// Whether this IP is used in NAT rules
	UsedInNatRules []*NatRuleReference `json:"usedInNatRules"`
	// Number of active connections using this IP
	ActiveConnections int `json:"activeConnections"`
	// Severity of the deletion
	Severity ConfirmationSeverity `json:"severity"`
	// Human-readable impact message
	Message string `json:"message"`
	// List of consequences of deleting this IP
	Consequences []string `json:"consequences"`
	// Whether the IP can be safely deleted
	CanDelete bool `json:"canDelete"`
}

// Input for creating or updating an IP address
type IPAddressInput struct {
	// IP address with CIDR notation (e.g., 192.168.10.1/24)
	Address string `json:"address"`
	// Interface ID to assign this IP to
	InterfaceID string `json:"interfaceId"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
	// Whether this IP is disabled
	Disabled graphql.Omittable[*bool] `json:"disabled,omitempty"`
}

// Result of an IP address mutation (create, update)
type IPAddressMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The created or updated IP address (if successful)
	IPAddress *IPAddress `json:"ipAddress,omitempty"`
	// Configuration preview (RouterOS commands)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Errors that occurred during the operation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Details about an IP address conflict
type IPConflict struct {
	// Conflicting IP address ID
	ID string `json:"id"`
	// Conflicting IP address
	Address string `json:"address"`
	// Interface where conflict exists
	Interface *Interface `json:"interface"`
	// Type of conflict
	ConflictType IPConflictType `json:"conflictType"`
	// Explanation of the conflict
	Explanation string `json:"explanation"`
}

// Result of checking IP address conflicts
type IPConflictResult struct {
	// Whether the IP conflicts with existing assignments
	HasConflict bool `json:"hasConflict"`
	// List of conflicting IP addresses
	Conflicts []*IPConflict `json:"conflicts"`
	// Human-readable message
	Message string `json:"message"`
}

// IPsec profile for GRE tunnel encryption
type IpsecProfile struct {
	// IPsec profile ID
	ID string `json:"id"`
	// Profile name
	Name string `json:"name"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

// Complete isolation status for a service instance.
// Includes violations and resource limits.
type IsolationStatus struct {
	// List of isolation violations (empty if all checks passed)
	Violations []*IsolationViolation `json:"violations"`
	// Resource limits applied to the instance
	ResourceLimits *ResourceLimits `json:"resourceLimits,omitempty"`
	// Timestamp of the last isolation verification check
	LastVerified *time.Time `json:"lastVerified,omitempty"`
}

// An isolation violation detected during pre-start checks.
// Represents a failure in one of the 4 isolation layers.
type IsolationViolation struct {
	// Which isolation layer failed (IP Binding, Directory, Port Registry, Process Binding)
	Layer string `json:"layer"`
	// Severity level of the violation
	Severity IsolationSeverity `json:"severity"`
	// Human-readable description of the violation
	Message string `json:"message"`
	// Timestamp when the violation was detected
	Timestamp time.Time `json:"timestamp"`
}

// Kill switch status information for monitoring.
// Provides visibility into kill switch state and activation history.
type KillSwitchStatus struct {
	// Whether kill switch is enabled
	Enabled bool `json:"enabled"`
	// Kill switch behavior mode
	Mode KillSwitchMode `json:"mode"`
	// Whether kill switch is currently active (blocking traffic)
	Active bool `json:"active"`
	// Timestamp when kill switch was last activated
	LastActivatedAt *time.Time `json:"lastActivatedAt,omitempty"`
	// Timestamp when kill switch was last deactivated
	LastDeactivatedAt *time.Time `json:"lastDeactivatedAt,omitempty"`
	// Fallback interface ID (if mode=FALLBACK_SERVICE)
	FallbackInterfaceID *string `json:"fallbackInterfaceID,omitempty"`
	// Number of times kill switch has been activated
	ActivationCount int `json:"activationCount"`
	// Reason for most recent activation (service_down, health_check_failed, etc.)
	LastActivationReason *string `json:"lastActivationReason,omitempty"`
}

// Single knock port in sequence.
type KnockPort struct {
	// Port number (1-65535)
	Port int `json:"port"`
	// Protocol for this knock port
	Protocol KnockProtocol `json:"protocol"`
	// Position in sequence (1-based)
	Order int `json:"order"`
}

// Input for knock port.
type KnockPortInput struct {
	// Port number
	Port int `json:"port"`
	// Protocol
	Protocol KnockProtocol `json:"protocol"`
	// Order in sequence
	Order int `json:"order"`
}

// L2TP VPN Client resource implementing 8-layer model
type L2TPClient struct {
	ID             string                 `json:"id"`
	ScopedID       string                 `json:"scopedId"`
	Type           string                 `json:"type"`
	Category       ResourceCategory       `json:"category"`
	Configuration  map[string]any         `json:"configuration,omitempty"`
	Validation     *ValidationResult      `json:"validation,omitempty"`
	Deployment     *DeploymentState       `json:"deployment,omitempty"`
	Runtime        *RuntimeState          `json:"runtime,omitempty"`
	Telemetry      *TelemetryData         `json:"telemetry,omitempty"`
	Metadata       *ResourceMetadata      `json:"metadata"`
	Relationships  *ResourceRelationships `json:"relationships,omitempty"`
	Platform       *PlatformInfo          `json:"platform,omitempty"`
	Config         *L2TPClientConfig      `json:"config"`
	L2tpDeployment *L2TPDeployment        `json:"l2tpDeployment,omitempty"`
	L2tpRuntime    *L2TPRuntime           `json:"l2tpRuntime,omitempty"`
}

func (L2TPClient) IsResource() {}

func (L2TPClient) IsNode() {}

// L2TP client configuration
type L2TPClientConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// VPN server address
	Server string `json:"server"`
	// VPN server port
	Port *Port `json:"port,omitempty"`
	// Username
	Username string `json:"username"`
	// Password
	Password string `json:"password"`
	// Use IPSec encryption
	UseIpsec *bool `json:"useIpsec,omitempty"`
	// IPSec shared secret
	IpsecSecret *string `json:"ipsecSecret,omitempty"`
	// Authentication method
	AuthMethod string `json:"authMethod"`
	// L2TP protocol version
	ProtoVersion *string `json:"protoVersion,omitempty"`
	// WAN interface to use
	WanInterface *string `json:"wanInterface,omitempty"`
}

// L2TP deployment state
type L2TPDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// L2TP runtime state
type L2TPRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether connected to VPN
	IsConnected bool `json:"isConnected"`
	// Connection uptime
	ConnectionUptime *Duration `json:"connectionUptime,omitempty"`
	// Tunnel IP address
	TunnelAddress *IPv4 `json:"tunnelAddress,omitempty"`
	// Bytes in
	BytesIn Size `json:"bytesIn"`
	// Bytes out
	BytesOut Size `json:"bytesOut"`
}

// LAN Network composite resource - groups bridge, DHCP, firewall, routing
type LANNetwork struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]any         `json:"configuration,omitempty"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	Config        *LANNetworkConfig      `json:"config"`
	LanDeployment *LANNetworkDeployment  `json:"lanDeployment,omitempty"`
	LanRuntime    *LANNetworkRuntime     `json:"lanRuntime,omitempty"`
	// Bridge interface
	Bridge *BridgeResource `json:"bridge,omitempty"`
	// DHCP server configuration
	DhcpServer *DHCPServerResource `json:"dhcpServer,omitempty"`
	// Firewall rules for this LAN
	FirewallRules []*FirewallRuleResource `json:"firewallRules"`
	// Static routes
	Routes []*RouteResource `json:"routes"`
}

func (LANNetwork) IsResource() {}

func (LANNetwork) IsNode() {}

// LAN Network configuration
type LANNetworkConfig struct {
	// Network name
	Name string `json:"name"`
	// IP address for the LAN
	IPAddress IPv4 `json:"ipAddress"`
	// Subnet mask in CIDR notation
	SubnetMask int `json:"subnetMask"`
	// Interfaces to include in bridge
	Interfaces []string `json:"interfaces"`
	// Enable DHCP server
	DhcpEnabled bool `json:"dhcpEnabled"`
	// DHCP pool start
	DhcpPoolStart *IPv4 `json:"dhcpPoolStart,omitempty"`
	// DHCP pool end
	DhcpPoolEnd *IPv4 `json:"dhcpPoolEnd,omitempty"`
	// DHCP lease time
	DhcpLeaseTime *Duration `json:"dhcpLeaseTime,omitempty"`
	// DNS servers for DHCP
	DNSServers []IPv4 `json:"dnsServers,omitempty"`
	// Enable NAT masquerading
	EnableNat bool `json:"enableNat"`
	// VLAN ID (optional)
	VlanID *int `json:"vlanId,omitempty"`
}

// LAN Network deployment state
type LANNetworkDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Bridge interface ID on router
	BridgeID *string `json:"bridgeId,omitempty"`
	// DHCP server ID on router
	DhcpServerID *string `json:"dhcpServerId,omitempty"`
	// IP address ID on router
	IPAddressID *string `json:"ipAddressId,omitempty"`
}

// LAN Network runtime state
type LANNetworkRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Number of active clients
	ActiveClients int `json:"activeClients"`
	// Active DHCP leases
	DhcpLeases int `json:"dhcpLeases"`
	// Total traffic in
	TotalBytesIn Size `json:"totalBytesIn"`
	// Total traffic out
	TotalBytesOut Size `json:"totalBytesOut"`
}

// A single log entry from a service instance.
// Represents one line of stdout/stderr output with parsed metadata.
type LogEntry struct {
	// Timestamp when the log was generated
	Timestamp time.Time `json:"timestamp"`
	// Log severity level
	Level LogLevel `json:"level"`
	// Log message
	Message string `json:"message"`
	// Service source (e.g., 'tor', 'singbox', 'adguard')
	Source string `json:"source"`
	// Original raw log line
	RawLine string `json:"rawLine"`
	// Additional parsed metadata (JSON)
	Metadata map[string]any `json:"metadata,omitempty"`
}

// LTE/cellular modem configuration
type LteModem struct {
	// Unique identifier
	ID string `json:"id"`
	// LTE interface name
	Name string `json:"name"`
	// APN (Access Point Name)
	Apn string `json:"apn"`
	// Signal strength (RSSI in dBm)
	SignalStrength *int `json:"signalStrength,omitempty"`
	// Connection status
	Running bool `json:"running"`
	// Operator name
	Operator *string `json:"operator,omitempty"`
	// Network type (LTE, 3G, etc.)
	NetworkType *string `json:"networkType,omitempty"`
	// PIN code configured
	PinConfigured bool `json:"pinConfigured"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (LteModem) IsNode() {}

// Input for configuring LTE modem
type LteModemInput struct {
	// LTE interface name
	Name string `json:"name"`
	// APN (Access Point Name)
	Apn string `json:"apn"`
	// PIN code (optional, for SIM card)
	Pin graphql.Omittable[*string] `json:"pin,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Memory utilization metrics
type MemoryMetrics struct {
	// Used memory in bytes
	Used float64 `json:"used"`
	// Total memory in bytes
	Total float64 `json:"total"`
	// Memory usage percentage (0-100)
	Percentage float64 `json:"percentage"`
}

// Missing dependency information
type MissingDependency struct {
	// Item ID with missing dependency
	ItemID string `json:"itemId"`
	// Missing resource type
	MissingResourceType string `json:"missingResourceType"`
	// Missing resource ID
	MissingResourceID string `json:"missingResourceId"`
}

// MTU guidance for tunnel configuration
type MtuGuidance struct {
	// Tunnel type this guidance applies to
	TunnelType TunnelType `json:"tunnelType"`
	// Protocol overhead in bytes
	Overhead int `json:"overhead"`
	// Recommended MTU based on base MTU (typically 1500)
	RecommendedMtu int `json:"recommendedMtu"`
	// Human-readable explanation of the overhead
	Explanation string `json:"explanation"`
}

// Multi-link configuration for load balancing and failover
type MultiLinkConfig struct {
	// Configuration name
	Name string `json:"name"`
	// Load balancing strategy
	Strategy MultiLinkStrategy `json:"strategy"`
	// WAN links to manage
	Links []string `json:"links"`
	// Link-specific configurations
	LinkConfigs []*MultiLinkLinkConfig `json:"linkConfigs,omitempty"`
	// Failover configuration
	FailoverConfig *FailoverConfig `json:"failoverConfig,omitempty"`
	// Bonding/Aggregation configuration
	BondingConfig *BondingConfig `json:"bondingConfig,omitempty"`
	// Enable multi-link
	Enabled bool `json:"enabled"`
	// Optional comment
	Comment *string `json:"comment,omitempty"`
}

// Per-link configuration in multi-link setup
type MultiLinkLinkConfig struct {
	// Link ID
	LinkID string `json:"linkId"`
	// Weight/priority for this link
	Weight *int `json:"weight,omitempty"`
	// Enabled in multi-link
	Enabled *bool `json:"enabled,omitempty"`
}

type Mutation struct {
}

// Standard error type for mutations
type MutationError struct {
	// Error code for programmatic handling
	Code string `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Field that caused the error (if applicable)
	Field *string `json:"field,omitempty"`
}

// NAT rule configuration for network address translation.
// Handles both source NAT (masquerade) and destination NAT (port forwarding).
type NatRule struct {
	// MikroTik internal ID
	ID string `json:"id"`
	// NAT chain (srcnat or dstnat)
	Chain NatChain `json:"chain"`
	// NAT action
	Action NatAction `json:"action"`
	// Source address or CIDR
	SrcAddress *string `json:"srcAddress,omitempty"`
	// Destination address or CIDR
	DstAddress *string `json:"dstAddress,omitempty"`
	// Source port or port range
	SrcPort *string `json:"srcPort,omitempty"`
	// Destination port or port range
	DstPort *string `json:"dstPort,omitempty"`
	// Protocol (TCP, UDP)
	Protocol *TransportProtocol `json:"protocol,omitempty"`
	// Target address for NAT
	ToAddresses *string `json:"toAddresses,omitempty"`
	// Target port(s) for NAT
	ToPorts *string `json:"toPorts,omitempty"`
	// Incoming interface
	InInterface *string `json:"inInterface,omitempty"`
	// Outgoing interface
	OutInterface *string `json:"outInterface,omitempty"`
	// Optional comment
	Comment *string `json:"comment,omitempty"`
	// Whether rule is disabled
	Disabled bool `json:"disabled"`
	// Bytes processed by this rule
	Bytes int `json:"bytes"`
	// Packets processed by this rule
	Packets int `json:"packets"`
	// Rule position in chain
	Position int `json:"position"`
}

func (NatRule) IsNode() {}

// NAT rule reference type (lightweight for dependency tracking).
// For full NAT rule management, see NatRule type in firewall.graphql.
type NatRuleReference struct {
	// NAT rule ID
	ID string `json:"id"`
	// Rule chain (srcnat, dstnat)
	Chain string `json:"chain"`
	// Action (masquerade, dst-nat, src-nat)
	Action string `json:"action"`
	// Source address
	SrcAddress *string `json:"srcAddress,omitempty"`
	// Destination address
	DstAddress *string `json:"dstAddress,omitempty"`
	// To address (for dst-nat)
	ToAddress *string `json:"toAddress,omitempty"`
	// Whether the rule is disabled
	Disabled bool `json:"disabled"`
}

// Network configuration detection result
type NetworkConfigDetection struct {
	// Detected WAN interface name
	WanInterface string `json:"wanInterface"`
	// Detected default gateway IP
	Gateway *string `json:"gateway,omitempty"`
	// Detected ISP information
	IspInfo *ISPInfo `json:"ispInfo,omitempty"`
}

// Network device discovered via DHCP and ARP.
// Represents a client device on the network that can be routed through service instances.
type NetworkDevice struct {
	// Device identifier (generated from MAC address)
	DeviceID string `json:"deviceID"`
	// MAC address of the device
	MacAddress string `json:"macAddress"`
	// IP address of the device (optional, may change)
	IPAddress *string `json:"ipAddress,omitempty"`
	// Hostname from DHCP (optional)
	Hostname *string `json:"hostname,omitempty"`
	// Source of device discovery (dhcp, arp, or both)
	Source string `json:"source"`
	// Whether the device is currently active
	Active bool `json:"active"`
	// Whether device has a DHCP lease
	DhcpLease bool `json:"dhcpLease"`
	// Whether device has an ARP entry
	ArpEntry bool `json:"arpEntry"`
	// Whether device has a routing assignment
	IsRouted bool `json:"isRouted"`
	// Current routing mark (if routed)
	RoutingMark *string `json:"routingMark,omitempty"`
}

// Notification channel configuration with encrypted credentials
type NotificationChannelConfig struct {
	// Unique configuration ID
	ID string `json:"id"`
	// Type of notification channel
	ChannelType ChannelType `json:"channelType"`
	// Human-readable name for this configuration
	Name string `json:"name"`
	// Optional description
	Description *string `json:"description,omitempty"`
	// Whether this configuration is enabled
	Enabled bool `json:"enabled"`
	// Whether this is the default configuration for this channel type
	IsDefault bool `json:"isDefault"`
	// Masked configuration (sensitive fields redacted)
	// For Pushover: {"device": "iphone", "baseURL": "...", "userKey": "******", "apiToken": "******"}
	// For Email: {"host": "smtp.gmail.com", "port": 587, "from": "...", "password": "******"}
	ConfigMasked map[string]any `json:"configMasked"`
	// When this configuration was created
	CreatedAt time.Time `json:"createdAt"`
	// When this configuration was last updated
	UpdatedAt time.Time `json:"updatedAt"`
	// User ID who created this configuration
	CreatedBy *string `json:"createdBy,omitempty"`
	// User ID who last updated this configuration
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// Notification delivery log entry
type NotificationLog struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Alert that triggered this notification
	AlertID string `json:"alertId"`
	// Notification channel type (email, telegram, pushover, webhook)
	Channel string `json:"channel"`
	// Webhook ID (if channel is webhook)
	WebhookID *string `json:"webhookId,omitempty"`
	// Delivery status
	Status NotificationStatus `json:"status"`
	// HTTP status code (for webhooks)
	StatusCode *int `json:"statusCode,omitempty"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if delivery failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Number of retry attempts
	RetryCount int `json:"retryCount"`
	// Request payload sent
	RequestPayload map[string]any `json:"requestPayload,omitempty"`
	// Response body received
	ResponseBody *string `json:"responseBody,omitempty"`
	// When delivery was attempted
	AttemptedAt time.Time `json:"attemptedAt"`
	// When delivery was completed (success or final failure)
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

func (NotificationLog) IsNode() {}

// Notification template preview result
// Simplified preview output for template customization
type NotificationTemplatePreview struct {
	// Rendered subject line (empty if channel doesn't use subjects)
	Subject *string `json:"subject,omitempty"`
	// Rendered body content
	Body string `json:"body"`
	// Validation errors (empty array if valid)
	Errors []string `json:"errors"`
}

// Ntfy.sh notification configuration input
type NtfyChannelInput struct {
	// Whether ntfy notifications are enabled
	Enabled bool `json:"enabled"`
	// Ntfy server URL (e.g., https://ntfy.sh or self-hosted)
	ServerURL string `json:"serverUrl"`
	// Topic to publish to
	Topic string `json:"topic"`
	// Optional username for authentication
	Username graphql.Omittable[*string] `json:"username,omitempty"`
	// Optional password for authentication
	Password graphql.Omittable[*string] `json:"password,omitempty"`
	// Message priority (1-5, default: 3)
	Priority graphql.Omittable[*int] `json:"priority,omitempty"`
	// Optional tags for categorization
	Tags graphql.Omittable[[]string] `json:"tags,omitempty"`
}

// OpenVPN VPN Client resource implementing 8-layer model
type OpenVPNClient struct {
	ID             string                 `json:"id"`
	ScopedID       string                 `json:"scopedId"`
	Type           string                 `json:"type"`
	Category       ResourceCategory       `json:"category"`
	Configuration  map[string]any         `json:"configuration,omitempty"`
	Validation     *ValidationResult      `json:"validation,omitempty"`
	Deployment     *DeploymentState       `json:"deployment,omitempty"`
	Runtime        *RuntimeState          `json:"runtime,omitempty"`
	Telemetry      *TelemetryData         `json:"telemetry,omitempty"`
	Metadata       *ResourceMetadata      `json:"metadata"`
	Relationships  *ResourceRelationships `json:"relationships,omitempty"`
	Platform       *PlatformInfo          `json:"platform,omitempty"`
	Config         *OpenVPNClientConfig   `json:"config"`
	OvpnDeployment *OpenVPNDeployment     `json:"ovpnDeployment,omitempty"`
	OvpnRuntime    *OpenVPNRuntime        `json:"ovpnRuntime,omitempty"`
}

func (OpenVPNClient) IsResource() {}

func (OpenVPNClient) IsNode() {}

// OpenVPN client configuration
type OpenVPNClientConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// VPN server address
	Server string `json:"server"`
	// VPN server port
	Port Port `json:"port"`
	// Connection mode: tcp or udp
	Protocol string `json:"protocol"`
	// Authentication mode: user/pass, certificate, or both
	AuthType string `json:"authType"`
	// Username (if using user/pass auth)
	Username *string `json:"username,omitempty"`
	// Password (if using user/pass auth)
	Password *string `json:"password,omitempty"`
	// CA certificate PEM
	CaCert string `json:"caCert"`
	// Client certificate PEM
	ClientCert string `json:"clientCert"`
	// Client key PEM
	ClientKey string `json:"clientKey"`
	// Encryption cipher
	Cipher *string `json:"cipher,omitempty"`
	// TLS version (e.g., 1.2, 1.3)
	TLSVersion *string `json:"tlsVersion,omitempty"`
	// Verify server certificate
	VerifyServerCert *bool `json:"verifyServerCert,omitempty"`
	// Route all traffic through VPN (kill switch)
	RouteAllTraffic *bool `json:"routeAllTraffic,omitempty"`
	// Do not pull default route from server
	RouteNoPull *bool `json:"routeNoPull,omitempty"`
	// Custom DNS servers
	DNSServers []IPv4 `json:"dnsServers,omitempty"`
	// WAN interface to use
	WanInterface *string `json:"wanInterface,omitempty"`
}

// OpenVPN deployment state (router-generated)
type OpenVPNDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
	// Generated client profile
	ProfilePath *string `json:"profilePath,omitempty"`
}

// OpenVPN runtime state
type OpenVPNRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether connected to VPN server
	IsConnected bool `json:"isConnected"`
	// Time of last successful connection
	LastConnectTime *time.Time `json:"lastConnectTime,omitempty"`
	// Connection uptime
	ConnectionUptime *Duration `json:"connectionUptime,omitempty"`
	// Current tunnel IP
	TunnelAddress *IPv4 `json:"tunnelAddress,omitempty"`
	// Server endpoint currently connected to
	ConnectedEndpoint *string `json:"connectedEndpoint,omitempty"`
	// Bytes transferred in
	BytesIn Size `json:"bytesIn"`
	// Bytes transferred out
	BytesOut Size `json:"bytesOut"`
}

// Operation counts by type
type OperationCounts struct {
	Create int `json:"create"`
	Update int `json:"update"`
	Delete int `json:"delete"`
}

// Payload for orphan cleanup mutation.
type OrphanCleanupPayload struct {
	// Number of orphaned allocations cleaned up
	CleanedCount int `json:"cleanedCount"`
	// List of allocation IDs that were deleted
	DeletedAllocationIDs []string `json:"deletedAllocationIDs"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Orphaned port allocation that references a non-existent service instance.
type OrphanedPort struct {
	// Port allocation record
	Allocation *PortAllocation `json:"allocation"`
	// Reason why this allocation is orphaned
	Reason string `json:"reason"`
}

// PPP Server resource (covers PPTP, L2TP, SSTP, OpenVPN servers)
// Implementing 8-layer model
type PPPServer struct {
	ID                  string                 `json:"id"`
	ScopedID            string                 `json:"scopedId"`
	Type                string                 `json:"type"`
	Category            ResourceCategory       `json:"category"`
	Configuration       map[string]any         `json:"configuration,omitempty"`
	Validation          *ValidationResult      `json:"validation,omitempty"`
	Deployment          *DeploymentState       `json:"deployment,omitempty"`
	Runtime             *RuntimeState          `json:"runtime,omitempty"`
	Telemetry           *TelemetryData         `json:"telemetry,omitempty"`
	Metadata            *ResourceMetadata      `json:"metadata"`
	Relationships       *ResourceRelationships `json:"relationships,omitempty"`
	Platform            *PlatformInfo          `json:"platform,omitempty"`
	Config              *PPPServerConfig       `json:"config"`
	PppServerDeployment *PPPServerDeployment   `json:"pppServerDeployment,omitempty"`
	PppServerRuntime    *PPPServerRuntime      `json:"pppServerRuntime,omitempty"`
}

func (PPPServer) IsResource() {}

func (PPPServer) IsNode() {}

// PPP server configuration
type PPPServerConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// Server type (pptp, l2tp, sstp, ovpn)
	ServerType string `json:"serverType"`
	// Listen port
	Port Port `json:"port"`
	// Server address range
	AddressPool string `json:"addressPool"`
	// Authentication type
	AuthType string `json:"authType"`
	// Certificate (for SSTP, OpenVPN)
	Certificate *string `json:"certificate,omitempty"`
	// Private key (for SSTP, OpenVPN)
	PrivateKey *string `json:"privateKey,omitempty"`
	// Enable encryption
	Encryption *bool `json:"encryption,omitempty"`
	// Encryption cipher
	Cipher *string `json:"cipher,omitempty"`
}

// PPP server deployment state
type PPPServerDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Server interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// PPP server runtime state
type PPPServerRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether server is accepting connections
	IsAccepting bool `json:"isAccepting"`
	// Number of connected clients
	ConnectedClients int `json:"connectedClients"`
	// Total bytes received
	BytesReceived Size `json:"bytesReceived"`
	// Total bytes sent
	BytesSent Size `json:"bytesSent"`
}

// PPTP VPN Client resource implementing 8-layer model
type PPTPClient struct {
	ID             string                 `json:"id"`
	ScopedID       string                 `json:"scopedId"`
	Type           string                 `json:"type"`
	Category       ResourceCategory       `json:"category"`
	Configuration  map[string]any         `json:"configuration,omitempty"`
	Validation     *ValidationResult      `json:"validation,omitempty"`
	Deployment     *DeploymentState       `json:"deployment,omitempty"`
	Runtime        *RuntimeState          `json:"runtime,omitempty"`
	Telemetry      *TelemetryData         `json:"telemetry,omitempty"`
	Metadata       *ResourceMetadata      `json:"metadata"`
	Relationships  *ResourceRelationships `json:"relationships,omitempty"`
	Platform       *PlatformInfo          `json:"platform,omitempty"`
	Config         *PPTPClientConfig      `json:"config"`
	PptpDeployment *PPTPDeployment        `json:"pptpDeployment,omitempty"`
	PptpRuntime    *PPTPRuntime           `json:"pptpRuntime,omitempty"`
}

func (PPTPClient) IsResource() {}

func (PPTPClient) IsNode() {}

// PPTP client configuration
type PPTPClientConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// VPN server address
	ConnectTo string `json:"connectTo"`
	// VPN server port
	Port *Port `json:"port,omitempty"`
	// Username
	Username string `json:"username"`
	// Password
	Password string `json:"password"`
	// Authentication method (pap, chap, mschap, mschap2)
	AuthMethod string `json:"authMethod"`
	// Keep alive timeout
	KeepaliveTimeout *Duration `json:"keepaliveTimeout,omitempty"`
	// Enable on-demand dialing
	DialOnDemand *bool `json:"dialOnDemand,omitempty"`
	// WAN interface to use
	WanInterface *string `json:"wanInterface,omitempty"`
}

// PPTP deployment state
type PPTPDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// PPTP runtime state
type PPTPRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether connected to VPN
	IsConnected bool `json:"isConnected"`
	// Connection uptime
	ConnectionUptime *Duration `json:"connectionUptime,omitempty"`
	// Tunnel IP address
	TunnelAddress *IPv4 `json:"tunnelAddress,omitempty"`
	// Bytes in
	BytesIn Size `json:"bytesIn"`
	// Bytes out
	BytesOut Size `json:"bytesOut"`
}

// Information about pagination in a connection
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// Cursor for the first edge
	StartCursor *string `json:"startCursor,omitempty"`
	// Cursor for the last edge
	EndCursor *string `json:"endCursor,omitempty"`
}

// Standard pagination input arguments
type PaginationInput struct {
	// Number of items to fetch
	First graphql.Omittable[*int] `json:"first,omitempty"`
	// Cursor to fetch items after
	After graphql.Omittable[*string] `json:"after,omitempty"`
	// Number of items to fetch from the end
	Last graphql.Omittable[*int] `json:"last,omitempty"`
	// Cursor to fetch items before
	Before graphql.Omittable[*string] `json:"before,omitempty"`
}

// Platform capabilities for a resource type
type PlatformCapabilities struct {
	// Whether this resource type is supported
	IsSupported bool `json:"isSupported"`
	// Capability level
	Level CapabilityLevel `json:"level"`
	// Minimum platform version required
	MinVersion *string `json:"minVersion,omitempty"`
	// Required packages
	RequiredPackages []string `json:"requiredPackages,omitempty"`
	// Capability-specific details
	Details map[string]any `json:"details,omitempty"`
}

// A platform-specific feature
type PlatformFeature struct {
	// Feature identifier
	ID string `json:"id"`
	// Feature name
	Name string `json:"name"`
	// Whether feature is enabled
	Enabled bool `json:"enabled"`
	// Feature description
	Description *string `json:"description,omitempty"`
}

// Layer 8: Platform-specific capabilities and field mappings.
// From platform adapter (MikroTik, OpenWrt, VyOS).
type PlatformInfo struct {
	// Current platform
	Current RouterPlatform `json:"current"`
	// Platform-specific capabilities for this resource type
	Capabilities *PlatformCapabilities `json:"capabilities"`
	// Field mappings between GraphQL and platform-native names
	FieldMappings map[string]any `json:"fieldMappings,omitempty"`
	// Platform-specific limitations or constraints
	Limitations []*PlatformLimitation `json:"limitations,omitempty"`
	// Platform-specific features available
	Features []*PlatformFeature `json:"features,omitempty"`
}

// A platform-specific limitation
type PlatformLimitation struct {
	// Limitation identifier
	Code string `json:"code"`
	// Human-readable description
	Description string `json:"description"`
	// Affected fields
	AffectedFields []string `json:"affectedFields,omitempty"`
	// Workaround if available
	Workaround *string `json:"workaround,omitempty"`
}

// A port allocation record tracking which ports are in use by service instances.
// Prevents port conflicts and enables centralized port management.
type PortAllocation struct {
	// ULID primary key
	ID string `json:"id"`
	// Router ID where this port is allocated
	RouterID string `json:"routerID"`
	// Port number (1-65535)
	Port int `json:"port"`
	// Transport protocol (TCP or UDP)
	Protocol PortProtocol `json:"protocol"`
	// Service instance ID that owns this allocation
	InstanceID string `json:"instanceID"`
	// Service type (e.g., 'tor', 'xray-core', 'adguard-home')
	ServiceType string `json:"serviceType"`
	// Optional notes about this port allocation
	Notes *string `json:"notes,omitempty"`
	// Allocation timestamp
	AllocatedAt time.Time `json:"allocatedAt"`
	// The router where this port is allocated
	Router *Router `json:"router,omitempty"`
	// The service instance that owns this port allocation
	ServiceInstance *ServiceInstance `json:"serviceInstance,omitempty"`
}

func (PortAllocation) IsNode() {}

// Port availability check result.
type PortAvailability struct {
	// Port number checked
	Port int `json:"port"`
	// Protocol checked
	Protocol PortProtocol `json:"protocol"`
	// Whether the port is available for allocation
	Available bool `json:"available"`
	// Reason why port is unavailable (if applicable)
	Reason *string `json:"reason,omitempty"`
}

// Port forward configuration (high-level view).
// Represents both the NAT rule and corresponding filter rule.
type PortForward struct {
	// Unique identifier
	ID string `json:"id"`
	// Optional name/description
	Name *string `json:"name,omitempty"`
	// Protocol (TCP, UDP)
	Protocol TransportProtocol `json:"protocol"`
	// External port
	ExternalPort int `json:"externalPort"`
	// Internal target IP
	InternalIP string `json:"internalIP"`
	// Internal target port
	InternalPort int `json:"internalPort"`
	// Current status
	Status PortForwardStatus `json:"status"`
	// ID of the associated NAT rule
	NatRuleID string `json:"natRuleId"`
	// ID of the associated filter rule (if created)
	FilterRuleID *string `json:"filterRuleId,omitempty"`
}

func (PortForward) IsNode() {}

// Input for creating a port forward (simplified wizard).
// Creates both NAT and filter rules automatically.
type PortForwardInput struct {
	// Protocol (TCP, UDP)
	Protocol TransportProtocol `json:"protocol"`
	// External port (1-65535)
	ExternalPort int `json:"externalPort"`
	// Internal target IP address
	InternalIP string `json:"internalIP"`
	// Internal target port (defaults to external port if not specified)
	InternalPort graphql.Omittable[*int] `json:"internalPort,omitempty"`
	// Optional name/description for this port forward
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// WAN interface name (optional, auto-detected if not specified)
	WanInterface graphql.Omittable[*string] `json:"wanInterface,omitempty"`
}

// Port knock attempt log entry.
type PortKnockAttempt struct {
	// Attempt ID
	ID string `json:"id"`
	// Sequence ID
	SequenceID string `json:"sequenceId"`
	// Sequence name
	SequenceName string `json:"sequenceName"`
	// Source IP address
	SourceIP string `json:"sourceIP"`
	// Attempt timestamp
	Timestamp time.Time `json:"timestamp"`
	// Attempt status
	Status KnockStatus `json:"status"`
	// Ports hit in order
	PortsHit []int `json:"portsHit"`
	// Protected service port
	ProtectedPort int `json:"protectedPort"`
	// Progress indicator (e.g., "2/4")
	Progress string `json:"progress"`
}

func (PortKnockAttempt) IsNode() {}

// Connection type for paginated knock attempts.
type PortKnockAttemptConnection struct {
	Edges      []*PortKnockAttemptEdge `json:"edges"`
	PageInfo   *PageInfo               `json:"pageInfo"`
	TotalCount *int                    `json:"totalCount,omitempty"`
}

func (PortKnockAttemptConnection) IsConnection() {}

// Edge type for knock attempt connections.
type PortKnockAttemptEdge struct {
	Cursor string            `json:"cursor"`
	Node   *PortKnockAttempt `json:"node"`
}

func (PortKnockAttemptEdge) IsEdge() {}

// Filters for knock attempt log.
type PortKnockLogFilters struct {
	// Filter by status
	Status graphql.Omittable[*KnockStatus] `json:"status,omitempty"`
	// Filter by source IP
	SourceIP graphql.Omittable[*string] `json:"sourceIP,omitempty"`
	// Filter by sequence ID
	SequenceID graphql.Omittable[*string] `json:"sequenceId,omitempty"`
	// Start date
	StartDate graphql.Omittable[*time.Time] `json:"startDate,omitempty"`
	// End date
	EndDate graphql.Omittable[*time.Time] `json:"endDate,omitempty"`
}

// Port knocking sequence configuration.
// Implements stage-based address list progression for hiding services.
type PortKnockSequence struct {
	// Unique sequence identifier
	ID string `json:"id"`
	// Sequence name (alphanumeric, underscores, hyphens)
	Name string `json:"name"`
	// Ordered list of knock ports (2-8 ports)
	KnockPorts []*KnockPort `json:"knockPorts"`
	// Protected service port
	ProtectedPort int `json:"protectedPort"`
	// Protected service protocol
	ProtectedProtocol TransportProtocol `json:"protectedProtocol"`
	// Access timeout after successful knock
	AccessTimeout string `json:"accessTimeout"`
	// Max time between knocks
	KnockTimeout string `json:"knockTimeout"`
	// Whether sequence is enabled
	Enabled bool `json:"enabled"`
	// Router ID
	RouterID string `json:"routerId"`
	// When sequence was created
	CreatedAt time.Time `json:"createdAt"`
	// When sequence was last updated
	UpdatedAt time.Time `json:"updatedAt"`
	// Successful knocks in last 24h
	RecentAccessCount int `json:"recentAccessCount"`
	// Generated firewall rule IDs
	GeneratedRuleIds []string `json:"generatedRuleIds"`
}

func (PortKnockSequence) IsNode() {}

// Input for creating/updating port knock sequence.
type PortKnockSequenceInput struct {
	// Sequence name
	Name string `json:"name"`
	// Ordered knock ports (2-8)
	KnockPorts []*KnockPortInput `json:"knockPorts"`
	// Protected service port
	ProtectedPort int `json:"protectedPort"`
	// Protected service protocol
	ProtectedProtocol TransportProtocol `json:"protectedProtocol"`
	// Access timeout (e.g., "5m", "1h")
	AccessTimeout string `json:"accessTimeout"`
	// Knock timeout (e.g., "15s", "30s")
	KnockTimeout string `json:"knockTimeout"`
	// Whether enabled
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

// Port mapping specification
type PortMapping struct {
	// Container port
	Internal int `json:"internal"`
	// Host port (0 = auto-allocate)
	External int `json:"external"`
	// Protocol (tcp/udp)
	Protocol string `json:"protocol"`
	// Purpose description
	Purpose *string `json:"purpose,omitempty"`
}

// A port mirror configuration for traffic monitoring and analysis
type PortMirror struct {
	// Unique port mirror identifier
	ID string `json:"id"`
	// Descriptive name for the mirror configuration
	Name string `json:"name"`
	// Source interfaces being mirrored
	SourceInterfaces []*Interface `json:"sourceInterfaces"`
	// Destination interface where mirrored traffic is sent
	DestinationInterface *Interface `json:"destinationInterface"`
	// Direction of traffic to mirror
	Direction MirrorDirection `json:"direction"`
	// Whether the mirror is enabled
	Enabled bool `json:"enabled"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// Statistics for the destination interface
	Statistics *PortMirrorStats `json:"statistics,omitempty"`
}

func (PortMirror) IsNode() {}

// Result of a port mirror mutation (create, update)
type PortMirrorMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The created or updated port mirror (if successful)
	PortMirror *PortMirror `json:"portMirror,omitempty"`
	// Configuration preview (RouterOS commands)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Errors that occurred during the operation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Statistics for a port mirror destination interface
type PortMirrorStats struct {
	// Total mirrored packets
	MirroredPackets Size `json:"mirroredPackets"`
	// Total mirrored bytes
	MirroredBytes Size `json:"mirroredBytes"`
	// Destination interface current load
	DestinationLoad float64 `json:"destinationLoad"`
	// Whether the destination is saturated (dropping packets)
	IsSaturated bool `json:"isSaturated"`
}

// Status of a single port check
type PortStatus struct {
	// Port number checked
	Port int `json:"port"`
	// Service name (API, API-SSL, SSH, Telnet, HTTP, HTTPS)
	Service string `json:"service"`
	// Whether the port is open and accepting connections
	Open bool `json:"open"`
	// Response time in milliseconds (if port is open)
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message (if port is closed)
	Error *string `json:"error,omitempty"`
}

// PPPoE client configuration for dial-up WAN
type PppoeClient struct {
	// Unique identifier
	ID string `json:"id"`
	// PPPoE interface name
	Name string `json:"name"`
	// Underlying interface (ethernet/bridge)
	Interface string `json:"interface"`
	// Whether PPPoE is disabled
	Disabled bool `json:"disabled"`
	// Username for authentication
	Username string `json:"username"`
	// Service name (optional)
	ServiceName *string `json:"serviceName,omitempty"`
	// Add default route
	AddDefaultRoute bool `json:"addDefaultRoute"`
	// Use peer DNS
	UsePeerDNS bool `json:"usePeerDNS"`
	// Current connection status
	Running bool `json:"running"`
	// MTU setting
	Mtu *int `json:"mtu,omitempty"`
	// MRU setting
	Mru *int `json:"mru,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (PppoeClient) IsNode() {}

// Input for creating/updating PPPoE client
type PppoeClientInput struct {
	// PPPoE interface name
	Name string `json:"name"`
	// Physical interface (ether1, bridge, etc.)
	Interface string `json:"interface"`
	// Username for ISP authentication
	Username string `json:"username"`
	// Password for ISP authentication
	Password string `json:"password"`
	// Service name (optional, ISP-specific)
	ServiceName graphql.Omittable[*string] `json:"serviceName,omitempty"`
	// Add default route (default: true)
	AddDefaultRoute graphql.Omittable[*bool] `json:"addDefaultRoute,omitempty"`
	// Use peer DNS (default: true)
	UsePeerDNS graphql.Omittable[*bool] `json:"usePeerDNS,omitempty"`
	// MTU (default: auto)
	Mtu graphql.Omittable[*int] `json:"mtu,omitempty"`
	// MRU (default: auto)
	Mru graphql.Omittable[*int] `json:"mru,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Input for previewing a notification template
// Simpler input for template customization workflow
type PreviewNotificationTemplateInput struct {
	// Event type for sample data generation
	EventType string `json:"eventType"`
	// Notification channel
	Channel NotificationChannel `json:"channel"`
	// Subject template (optional, not all channels use subjects)
	SubjectTemplate graphql.Omittable[*string] `json:"subjectTemplate,omitempty"`
	// Body template with Go template syntax
	BodyTemplate string `json:"bodyTemplate"`
}

// Progress event for provisioning operations (validation, apply, etc.)
// Emitted via subscription during long-running operations.
type ProvisioningProgressEvent struct {
	// Session ID this event is for
	SessionID string `json:"sessionId"`
	// Current phase name (e.g., "validating_resources", "applying_config", "verifying_deployment")
	Phase string `json:"phase"`
	// Current step number (0-indexed)
	Step int `json:"step"`
	// Total number of steps in this phase
	TotalSteps int `json:"totalSteps"`
	// Human-readable progress message
	Message string `json:"message"`
	// Overall operation status
	Status ProvisioningApplyStatus `json:"status"`
	// Resource being processed (if applicable)
	ResourceID *string `json:"resourceId,omitempty"`
	// Type of resource being processed
	ResourceType *string `json:"resourceType,omitempty"`
	// Percentage complete (0-100)
	PercentComplete int `json:"percentComplete"`
	// Timestamp of this event
	Timestamp time.Time `json:"timestamp"`
}

// Resource relationships for provisioning context
type ProvisioningRelationshipsInput struct {
	// IDs of resources this resource depends on
	DependsOn graphql.Omittable[[]string] `json:"dependsOn,omitempty"`
	// IDs of resources that depend on this resource
	Dependents graphql.Omittable[[]string] `json:"dependents,omitempty"`
	// Associated network interfaces (LAN, WAN, etc.)
	Networks graphql.Omittable[[]string] `json:"networks,omitempty"`
	// Associated firewall rules or policies
	FirewallRules graphql.Omittable[[]string] `json:"firewallRules,omitempty"`
	// Associated routing rules
	RoutingRules graphql.Omittable[[]string] `json:"routingRules,omitempty"`
}

// Provisioning session encapsulates the entire setup workflow for a router.
// Manages state transitions from initial setup through resource configuration
// to final apply on the router.
type ProvisioningSession struct {
	// Unique session identifier
	ID string `json:"id"`
	// Router being provisioned
	RouterID string `json:"routerId"`
	// Provisioning mode (EASY or ADVANCE)
	Mode ProvisioningMode `json:"mode"`
	// Target firmware
	Firmware ProvisioningFirmware `json:"firmware"`
	// Router operational mode
	RouterMode ProvisioningRouterMode `json:"routerMode"`
	// WAN link type for this provisioning
	WanLinkType ProvisioningWANLinkType `json:"wanLinkType"`
	// List of resource IDs included in this session
	// (VPN clients, tunnels, extra features, etc.)
	ResourceIds []string `json:"resourceIds"`
	// Networks configuration JSON (LAN, guest networks, etc.)
	NetworksConfig map[string]any `json:"networksConfig"`
	// Current step in the wizard workflow
	CurrentStep WizardStep `json:"currentStep"`
	// Current status of session apply operation
	ApplyStatus ProvisioningApplyStatus `json:"applyStatus"`
	// Associated changeset ID (created when moving to APPLY)
	ChangesetID *string `json:"changesetId,omitempty"`
	// Error message if apply failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// User who created this session
	CreatedBy string `json:"createdBy"`
	// Session creation time
	CreatedAt time.Time `json:"createdAt"`
	// Last update time
	UpdatedAt time.Time `json:"updatedAt"`
	// Session expiration time (for cleanup of abandoned sessions)
	ExpiresAt time.Time `json:"expiresAt"`
}

// Connection type for paginated provisioning sessions
type ProvisioningSessionConnection struct {
	// Edges contain provisioning session nodes
	Edges []*ProvisioningSessionEdge `json:"edges"`
	// Page information for pagination
	PageInfo *PageInfo `json:"pageInfo"`
	// Total count of provisioning sessions
	TotalCount int `json:"totalCount"`
}

// Edge in provisioning session connection
type ProvisioningSessionEdge struct {
	// Cursor for pagination
	Cursor string `json:"cursor"`
	// Provisioning session node
	Node *ProvisioningSession `json:"node"`
}

// Payload for provisioning session mutations
type ProvisioningSessionPayload struct {
	// The provisioning session (null if operation failed)
	Session *ProvisioningSession `json:"session,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Pushover API usage statistics
type PushoverUsage struct {
	// Number of messages used this month
	Used int `json:"used"`
	// Number of messages remaining this month
	Remaining int `json:"remaining"`
	// Monthly message limit
	Limit int `json:"limit"`
	// When the usage counter resets
	ResetAt time.Time `json:"resetAt"`
}

type Query struct {
}

// Quiet hours configuration
type QuietHoursConfig struct {
	// Start time in HH:MM format
	StartTime string `json:"startTime"`
	// End time in HH:MM format
	EndTime string `json:"endTime"`
	// Timezone (IANA timezone database name)
	Timezone string `json:"timezone"`
	// Whether critical alerts bypass quiet hours
	BypassCritical bool `json:"bypassCritical"`
	// Days of week when quiet hours apply (0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday). Empty array means all days.
	DaysOfWeek []int `json:"daysOfWeek"`
}

// Quiet hours configuration input
type QuietHoursConfigInput struct {
	// Start time in HH:MM format
	StartTime string `json:"startTime"`
	// End time in HH:MM format
	EndTime string `json:"endTime"`
	// Timezone (default: UTC)
	Timezone graphql.Omittable[*string] `json:"timezone,omitempty"`
	// Whether critical alerts bypass quiet hours (default: true)
	BypassCritical graphql.Omittable[*bool] `json:"bypassCritical,omitempty"`
	// Days of week when quiet hours apply (0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday). Empty array means all days.
	DaysOfWeek graphql.Omittable[[]int] `json:"daysOfWeek,omitempty"`
}

type ReconnectRouterPayload struct {
	// The router being reconnected
	Router *Router `json:"router,omitempty"`
	// Updated connection details
	ConnectionDetails *ConnectionDetails `json:"connectionDetails,omitempty"`
	// Whether reconnection was initiated
	Initiated bool `json:"initiated"`
	// Rate limit wait time if rate limited
	WaitTimeMs *int `json:"waitTimeMs,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Payload for refreshCapabilities mutation
type RefreshCapabilitiesPayload struct {
	// Updated capabilities after refresh
	Capabilities *RouterCapabilities `json:"capabilities,omitempty"`
	// Errors during refresh
	Errors []*MutationError `json:"errors,omitempty"`
}

type RemoveChangeSetItemPayload struct {
	// The updated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// RemoveDependencyInput contains parameters for removing a dependency relationship.
type RemoveDependencyInput struct {
	DependencyID string `json:"dependencyId"`
}

// Input for resetting external storage configuration.
type ResetExternalStorageInput struct {
	// Whether to move existing binaries back to flash (default: false)
	MigrateToFlash graphql.Omittable[*bool] `json:"migrateToFlash,omitempty"`
}

// Payload for resetExternalStorage mutation.
type ResetExternalStoragePayload struct {
	// Whether reset was successful
	Success bool `json:"success"`
	// Number of features migrated to flash (if requested)
	FeaturesMigrated int `json:"featuresMigrated"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Conflict with another resource
type ResourceConflict struct {
	// Type of conflict
	Type ConflictType `json:"type"`
	// The conflicting resource
	ConflictingResource Resource `json:"conflictingResource,omitempty"`
	// Conflicting resource UUID (if resource is not loaded)
	ConflictingResourceUUID string `json:"conflictingResourceUuid"`
	// Description of the conflict
	Description string `json:"description"`
	// Suggested resolution
	Resolution *string `json:"resolution,omitempty"`
}

type ResourceConnection struct {
	Edges      []*ResourceEdge `json:"edges"`
	PageInfo   *PageInfo       `json:"pageInfo"`
	TotalCount *int            `json:"totalCount,omitempty"`
}

func (ResourceConnection) IsConnection() {}

type ResourceEdge struct {
	Cursor string   `json:"cursor"`
	Node   Resource `json:"node"`
}

func (ResourceEdge) IsEdge() {}

// Resource usage estimate
type ResourceEstimate struct {
	// Total estimated memory in MB
	TotalMemoryMb int `json:"totalMemoryMB"`
	// Total CPU shares
	TotalCPUShares int `json:"totalCPUShares"`
	// Disk space needed in MB
	DiskSpaceMb int `json:"diskSpaceMB"`
	// Number of network ports
	NetworkPorts int `json:"networkPorts"`
	// Number of VLANs required
	VlansRequired int `json:"vlansRequired"`
}

// Resource limits applied to a service instance via cgroups v2.
type ResourceLimits struct {
	// Memory limit in megabytes (minimum 16MB)
	MemoryMb int `json:"memoryMB"`
	// CPU usage percentage (0-100)
	CPUPercent *int `json:"cpuPercent,omitempty"`
	// Whether resource limits are currently applied (cgroups available)
	Applied bool `json:"applied"`
}

// Payload for resource limits mutation.
type ResourceLimitsPayload struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// Updated resource limits (null if operation failed)
	ResourceLimits *ResourceLimits `json:"resourceLimits,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Layer 6: Resource lifecycle info, tags, ownership.
// System-managed with some user-editable fields.
type ResourceMetadata struct {
	// Resource creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// User who created the resource
	CreatedBy string `json:"createdBy"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// User who last updated the resource
	UpdatedBy *string `json:"updatedBy,omitempty"`
	// Current lifecycle state
	State ResourceLifecycleState `json:"state"`
	// Optimistic locking version
	Version int `json:"version"`
	// User-defined tags for organization
	Tags []string `json:"tags"`
	// Resource description
	Description *string `json:"description,omitempty"`
	// Whether resource is marked as favorite
	IsFavorite bool `json:"isFavorite"`
	// Whether resource is pinned
	IsPinned bool `json:"isPinned"`
	// Custom user notes
	Notes *string `json:"notes,omitempty"`
	// Audit trail of recent changes
	RecentChanges []*ChangeLogEntry `json:"recentChanges,omitempty"`
}

// Real-time resource utilization metrics for a device
type ResourceMetrics struct {
	// CPU utilization metrics
	CPU *CPUMetrics `json:"cpu"`
	// Memory utilization metrics
	Memory *MemoryMetrics `json:"memory"`
	// Storage utilization metrics
	Storage *StorageMetrics `json:"storage"`
	// Temperature in Celsius (null if not supported)
	Temperature *float64 `json:"temperature,omitempty"`
	// Timestamp when metrics were collected
	Timestamp time.Time `json:"timestamp"`
}

// Reference to another resource
type ResourceReference struct {
	// Resource UUID
	UUID string `json:"uuid"`
	// Resource scoped ID
	ID string `json:"id"`
	// Resource type
	Type string `json:"type"`
	// Resource category
	Category ResourceCategory `json:"category"`
	// Current lifecycle state
	State ResourceLifecycleState `json:"state"`
}

// Edge in the resource relationship graph
type ResourceRelationshipEdge struct {
	// Source resource ID
	From string `json:"from"`
	// Target resource ID
	To string `json:"to"`
	// Relationship type
	Type ResourceRelationshipType `json:"type"`
}

// Layer 7: Dependencies and relationships between resources.
// Combines user-defined relationships and system-discovered dependencies.
type ResourceRelationships struct {
	// Resources this resource depends on
	DependsOn []*ResourceReference `json:"dependsOn"`
	// Resources that depend on this resource
	Dependents []*ResourceReference `json:"dependents"`
	// Resource this routes traffic via
	RoutesVia *ResourceReference `json:"routesVia,omitempty"`
	// Resources that route traffic via this resource
	RoutedBy []*ResourceReference `json:"routedBy"`
	// Parent resource (for hierarchical resources)
	Parent *ResourceReference `json:"parent,omitempty"`
	// Child resources (for hierarchical resources)
	Children []*ResourceReference `json:"children"`
	// Custom relationships
	Custom map[string]any `json:"custom,omitempty"`
}

// Input for resource relationships
type ResourceRelationshipsInput struct {
	// Resources this resource depends on (IDs)
	DependsOn graphql.Omittable[[]string] `json:"dependsOn,omitempty"`
	// Resources that route traffic via this resource (ID)
	RoutesVia graphql.Omittable[*string] `json:"routesVia,omitempty"`
	// Parent resource ID (for hierarchical resources)
	Parent graphql.Omittable[*string] `json:"parent,omitempty"`
	// Custom relationship data
	Custom graphql.Omittable[map[string]any] `json:"custom,omitempty"`
}

// Resource requirements for a service feature (from manifest).
// Defines the minimum and recommended resources for a service.
type ResourceRequirements struct {
	// Minimum RAM required in megabytes
	MinRAM int `json:"minRAM"`
	// Recommended RAM for optimal performance in megabytes
	RecommendedRAM int `json:"recommendedRAM"`
	// CPU weight (priority) for scheduling (0-100)
	CPUWeight int `json:"cpuWeight"`
}

// Runtime update event for a resource
type ResourceRuntimeEvent struct {
	// Resource ID (ULID)
	ID string `json:"id"`
	// Resource type
	Type string `json:"type"`
	// Updated runtime state
	Runtime *RuntimeState `json:"runtime"`
	// Timestamp of update
	Timestamp time.Time `json:"timestamp"`
}

// Lifecycle state change event
type ResourceStateEvent struct {
	// Resource ID (ULID)
	ID string `json:"id"`
	// Resource type
	Type string `json:"type"`
	// Previous state
	PreviousState ResourceLifecycleState `json:"previousState"`
	// New state
	NewState ResourceLifecycleState `json:"newState"`
	// Error message if state is ERROR
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Timestamp of change
	Timestamp time.Time `json:"timestamp"`
}

// Event emitted when a router resource is updated
type ResourceUpdatedEvent struct {
	// Unique resource identifier
	ResourceID string `json:"resourceId"`
	// Type of resource (interface, firewall-rule, dhcp-lease, etc.)
	ResourceType string `json:"resourceType"`
	// Router this resource belongs to
	RouterID string `json:"routerId"`
	// New version number after update
	Version int `json:"version"`
	// Fields that were changed
	ChangedFields []string `json:"changedFields"`
	// Type of change (create, update, delete)
	ChangeType ChangeType `json:"changeType"`
	// Timestamp of the update
	Timestamp time.Time `json:"timestamp"`
}

// Current resource usage for a service instance.
// Provides real-time memory usage statistics.
type ResourceUsage struct {
	// Current memory usage in megabytes
	CurrentMb int `json:"currentMB"`
	// Memory limit in megabytes
	LimitMb int `json:"limitMB"`
	// Usage as a percentage of the limit (0-100)
	UsagePercent float64 `json:"usagePercent"`
	// Resource status (ok, warning, critical)
	Status ResourceStatus `json:"status"`
}

// Validation result for a single resource in provisioning session
type ResourceValidationResult struct {
	// Resource ID
	ResourceID string `json:"resourceId"`
	// Resource type
	ResourceType string `json:"resourceType"`
	// Whether resource passed validation
	IsValid bool `json:"isValid"`
	// Validation errors (if any)
	Errors []string `json:"errors,omitempty"`
	// Validation warnings (non-blocking)
	Warnings []string `json:"warnings,omitempty"`
	// Additional validation metadata
	Metadata map[string]any `json:"metadata,omitempty"`
}

// Input for restarting a service instance.
type RestartInstanceInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Instance ID to restart
	InstanceID string `json:"instanceID"`
}

// Payload for reverification mutation.
type ReverifyPayload struct {
	// Instance ID that was reverified
	InstanceID string `json:"instanceID"`
	// Whether reverification passed
	Success bool `json:"success"`
	// Current binary hash
	CurrentHash *string `json:"currentHash,omitempty"`
	// Expected binary hash (from install-time)
	ExpectedHash *string `json:"expectedHash,omitempty"`
	// Error message if verification failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

type RollbackChangeSetPayload struct {
	// The rolled back change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Whether rollback was successful
	Success bool `json:"success"`
	// Items that failed to rollback
	FailedItems []string `json:"failedItems,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Rollback step for recovery
type RollbackStep struct {
	// Item ID being rolled back
	ItemID string `json:"itemId"`
	// Rollback operation
	Operation RollbackOperation `json:"operation"`
	// State to restore
	RestoreState map[string]any `json:"restoreState,omitempty"`
	// Resource UUID on router
	ResourceUUID *string `json:"resourceUuid,omitempty"`
	// Whether rollback succeeded
	Success bool `json:"success"`
	// Error message if failed
	Error *string `json:"error,omitempty"`
	// Order in rollback sequence
	RollbackOrder int `json:"rollbackOrder"`
}

// Route type for static and dynamic routing
type Route struct {
	// Route ID
	ID string `json:"id"`
	// Destination network in CIDR notation
	Destination CIDR `json:"destination"`
	// Gateway address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Interface used for this route
	Interface *string `json:"interface,omitempty"`
	// Route distance/metric (1-255)
	Distance int `json:"distance"`
	// Routing mark for policy routing
	RoutingMark *string `json:"routingMark,omitempty"`
	// Routing table name (main, vpn, etc.)
	RoutingTable *string `json:"routingTable,omitempty"`
	// Route type (static, connected, dynamic, BGP, OSPF)
	Type RouteType `json:"type"`
	// Route scope
	Scope RouteScope `json:"scope"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// Whether the route is active
	Active bool `json:"active"`
	// Whether the route is disabled
	Disabled *bool `json:"disabled,omitempty"`
}

func (Route) IsNode() {}

// Result of a route deletion with impact analysis
type RouteDeleteResult struct {
	// Whether the deletion succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// Impact analysis for this route deletion
	ImpactAnalysis *RouteImpactAnalysis `json:"impactAnalysis"`
}

// Analysis of the impact of deleting a route
type RouteImpactAnalysis struct {
	// Whether this is the default route (0.0.0.0/0)
	IsDefaultRoute bool `json:"isDefaultRoute"`
	// Description of affected traffic
	AffectedTraffic string `json:"affectedTraffic"`
	// Severity of the deletion (CRITICAL for default route, STANDARD for others)
	Severity ConfirmationSeverity `json:"severity"`
	// Human-readable message about the impact
	Message string `json:"message"`
	// List of consequences of deleting this route
	Consequences []string `json:"consequences"`
}

// Input for creating or updating a route
type RouteInput struct {
	// Destination network in CIDR notation
	Destination CIDR `json:"destination"`
	// Gateway address (optional if interface is provided)
	Gateway graphql.Omittable[*IPv4] `json:"gateway,omitempty"`
	// Interface used for this route (optional if gateway is provided)
	Interface graphql.Omittable[*string] `json:"interface,omitempty"`
	// Route distance/metric (1-255, default: 1)
	Distance graphql.Omittable[*int] `json:"distance,omitempty"`
	// Routing mark for policy routing
	RoutingMark graphql.Omittable[*string] `json:"routingMark,omitempty"`
	// Routing table name (default: main)
	RoutingTable graphql.Omittable[*string] `json:"routingTable,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// A candidate route that matches the destination
type RouteLookupCandidate struct {
	// The route object
	Route *Route `json:"route"`
	// Prefix length (24 for /24, 8 for /8)
	PrefixLength int `json:"prefixLength"`
	// Administrative distance
	Distance int `json:"distance"`
	// Whether this route was selected
	Selected bool `json:"selected"`
	// Reason for selection or non-selection
	SelectionReason *string `json:"selectionReason,omitempty"`
}

// Result of a route lookup operation
type RouteLookupResult struct {
	// Destination IP that was looked up
	Destination string `json:"destination"`
	// The selected route (null if no route found)
	MatchedRoute *Route `json:"matchedRoute,omitempty"`
	// Gateway IP for the selected route
	Gateway *string `json:"gateway,omitempty"`
	// Outgoing interface for the selected route
	Interface *string `json:"interface,omitempty"`
	// Administrative distance of selected route
	Distance *int `json:"distance,omitempty"`
	// Route type (STATIC, CONNECTED, DYNAMIC, BGP, OSPF)
	RouteType RouteType `json:"routeType"`
	// Whether this is the default route (0.0.0.0/0)
	IsDefaultRoute bool `json:"isDefaultRoute"`
	// All candidate routes that match destination
	CandidateRoutes []*RouteLookupCandidate `json:"candidateRoutes"`
	// Human-readable explanation of route selection
	Explanation string `json:"explanation"`
	// VPN tunnel info if route goes through VPN
	VpnTunnel *VPNTunnelInfo `json:"vpnTunnel,omitempty"`
}

// Result of a route mutation (create, update)
type RouteMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// Success or error message
	Message *string `json:"message,omitempty"`
	// The created or updated route (if successful)
	Route *Route `json:"route,omitempty"`
}

// Route resource
type RouteResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]any         `json:"configuration"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	// Destination network
	DstAddress CIDR `json:"dstAddress"`
	// Gateway address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Outgoing interface
	Interface *string `json:"interface,omitempty"`
	// Route distance/metric
	Distance *int `json:"distance,omitempty"`
	// Whether route is active
	Active bool `json:"active"`
}

func (RouteResource) IsResource() {}

func (RouteResource) IsNode() {}

// A managed router device
type Router struct {
	// Unique router identifier
	ID string `json:"id"`
	// User-friendly display name
	Name string `json:"name"`
	// Router hostname or IP address
	Host string `json:"host"`
	// Connection port
	Port int `json:"port"`
	// Current connection status
	Status ConnectionStatus `json:"status"`
	// Router platform type
	Platform RouterPlatform `json:"platform"`
	// RouterOS version (if connected)
	Version *string `json:"version,omitempty"`
	// Router model
	Model *string `json:"model,omitempty"`
	// System uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Last successful connection time
	LastConnected *time.Time `json:"lastConnected,omitempty"`
	// When the router was added to NasNet
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// Detected router capabilities (requires connection)
	Capabilities *RouterCapabilities `json:"capabilities,omitempty"`
}

func (Router) IsNode() {}

// Event emitted when a new router is added.
type RouterAddedEvent struct {
	// The newly added router
	Router *Router `json:"router"`
	// Protocol used for initial connection
	ProtocolUsed Protocol `json:"protocolUsed"`
	// User who added the router (if authenticated)
	AddedBy *string `json:"addedBy,omitempty"`
	// Timestamp of addition
	Timestamp time.Time `json:"timestamp"`
}

// Complete router capabilities detected from system inspection
type RouterCapabilities struct {
	// Hardware information
	Hardware *HardwareInfo `json:"hardware"`
	// Software information
	Software *SoftwareInfo `json:"software"`
	// Container-specific capabilities
	Container *ContainerInfo `json:"container"`
	// Capability entries with support levels
	Capabilities []*CapabilityEntry `json:"capabilities"`
	// VIF requirements check
	VifRequirements *VIFRequirements `json:"vifRequirements"`
	// Features supported by this router's version and configuration
	SupportedFeatures []*FeatureSupport `json:"supportedFeatures"`
	// Features not supported by this router (with upgrade guidance)
	UnsupportedFeatures []*FeatureSupport `json:"unsupportedFeatures"`
	// Parsed RouterOS version with comparison helpers
	RouterOSVersion *RouterOSVersion `json:"routerOSVersion"`
	// When capabilities were detected
	DetectedAt time.Time `json:"detectedAt"`
	// When cache expires (24h TTL)
	ExpiresAt time.Time `json:"expiresAt"`
	// Whether cache is stale and refresh is in progress
	IsRefreshing bool `json:"isRefreshing"`
}

type RouterConnection struct {
	Edges      []*RouterEdge `json:"edges"`
	PageInfo   *PageInfo     `json:"pageInfo"`
	TotalCount *int          `json:"totalCount,omitempty"`
}

func (RouterConnection) IsConnection() {}

// Router credential information (non-sensitive).
// Password is never included - only metadata about credentials.
type RouterCredentials struct {
	// Router ID these credentials belong to
	RouterID string `json:"routerId"`
	// Username for router authentication
	Username string `json:"username"`
	// Whether a password is stored
	HasPassword bool `json:"hasPassword"`
	// Encryption algorithm used (always 'AES-256-GCM')
	EncryptionStatus string `json:"encryptionStatus"`
	// Encryption key version (for rotation tracking)
	KeyVersion int `json:"keyVersion"`
	// When credentials were last updated
	LastUpdated time.Time `json:"lastUpdated"`
	// When credentials were first created
	CreatedAt time.Time `json:"createdAt"`
}

type RouterEdge struct {
	Node   *Router `json:"node"`
	Cursor string  `json:"cursor"`
}

func (RouterEdge) IsEdge() {}

// Information about a discovered RouterOS device
type RouterOSInfo struct {
	// RouterOS version string (e.g., '7.12', '6.49.8')
	Version *string `json:"version,omitempty"`
	// Router board name (e.g., 'hAP ac3', 'CCR2004-1G-12S+2XS')
	BoardName *string `json:"boardName,omitempty"`
	// CPU architecture (e.g., 'arm', 'x86', 'mips')
	Architecture *string `json:"architecture,omitempty"`
	// Platform identifier
	Platform *string `json:"platform,omitempty"`
}

// Parsed RouterOS version with semantic versioning
type RouterOSVersion struct {
	// Full version string (e.g., '7.13.2')
	Raw string `json:"raw"`
	// Major version number
	Major int `json:"major"`
	// Minor version number
	Minor int `json:"minor"`
	// Patch version number
	Patch int `json:"patch"`
	// Version channel (stable, beta, rc, long-term)
	Channel *string `json:"channel,omitempty"`
	// Whether this is a Cloud Hosted Router (CHR)
	IsChr bool `json:"isCHR"`
	// Check if this version supports a specific feature
	SupportsFeature bool `json:"supportsFeature"`
	// Check if version is at least the given version (e.g., '7.1')
	IsAtLeast bool `json:"isAtLeast"`
}

type RouterStatusEvent struct {
	// The router whose status changed
	Router *Router `json:"router"`
	// Previous status
	PreviousStatus ConnectionStatus `json:"previousStatus"`
	// New status
	NewStatus ConnectionStatus `json:"newStatus"`
	// Timestamp of the change
	Timestamp time.Time `json:"timestamp"`
}

// A multi-hop routing chain that routes device traffic through multiple services sequentially.
// Example: Device -> VPN -> Tor -> Internet for layered privacy.
type RoutingChain struct {
	// Chain ID (ULID)
	ID string `json:"id"`
	// Target device identifier
	DeviceID string `json:"deviceId"`
	// Device MAC address (when routing_mode=MAC)
	DeviceMac *string `json:"deviceMac,omitempty"`
	// Device IP address (when routing_mode=IP)
	DeviceIP *string `json:"deviceIp,omitempty"`
	// Human-readable device name
	DeviceName *string `json:"deviceName,omitempty"`
	// Ordered list of service hops in this chain
	Hops []*ChainHop `json:"hops"`
	// Whether this chain is currently active
	Active bool `json:"active"`
	// Routing mode (MAC or IP matching)
	RoutingMode RoutingMode `json:"routingMode"`
	// Whether kill switch is enabled for this chain
	KillSwitchEnabled bool `json:"killSwitchEnabled"`
	// Kill switch behavior mode
	KillSwitchMode KillSwitchMode `json:"killSwitchMode"`
	// Whether kill switch is currently blocking traffic
	KillSwitchActive bool `json:"killSwitchActive"`
	// Timestamp when kill switch was last activated
	KillSwitchActivatedAt *time.Time `json:"killSwitchActivatedAt,omitempty"`
	// Total latency across all hops in milliseconds
	TotalLatencyMs *float64 `json:"totalLatencyMs,omitempty"`
	// Chain creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (RoutingChain) IsNode() {}

// Result of a routing chain mutation.
type RoutingChainMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// Human-readable message
	Message *string `json:"message,omitempty"`
	// The created or updated chain (null if failed)
	Chain *RoutingChain `json:"chain,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// A single routing rule for device-to-service routing.
// Represents a MikroTik firewall mangle rule.
type RoutingRule struct {
	// Mangle chain (e.g., 'prerouting')
	Chain string `json:"chain"`
	// Action (e.g., 'mark-routing')
	Action string `json:"action"`
	// Source address (MAC or IP)
	SrcAddress *string `json:"srcAddress,omitempty"`
	// Destination address
	DstAddress *string `json:"dstAddress,omitempty"`
	// Protocol (tcp, udp, icmp, etc.)
	Protocol *string `json:"protocol,omitempty"`
	// Comment for rule identification
	Comment *string `json:"comment,omitempty"`
	// Routing mark to match
	RoutingMark *string `json:"routingMark,omitempty"`
	// New routing mark to set
	NewRoutingMark *string `json:"newRoutingMark,omitempty"`
}

// Time-based schedule for activating/deactivating device routing rules.
// Enables features like parental controls, time-based VPN routing, etc.
type RoutingSchedule struct {
	// Schedule ID (ULID)
	ID string `json:"id"`
	// Device routing ID this schedule controls
	RoutingID string `json:"routingID"`
	// Days of week when schedule is active (0=Sunday, 6=Saturday)
	Days []int `json:"days"`
	// Start time in HH:MM format (24-hour)
	StartTime string `json:"startTime"`
	// End time in HH:MM format (24-hour)
	EndTime string `json:"endTime"`
	// IANA timezone identifier (e.g., 'America/New_York', 'UTC')
	Timezone string `json:"timezone"`
	// Whether this schedule is enabled
	Enabled bool `json:"enabled"`
	// Timestamp when routing was last activated by this schedule
	LastActivated *time.Time `json:"lastActivated,omitempty"`
	// Timestamp when routing was last deactivated by this schedule
	LastDeactivated *time.Time `json:"lastDeactivated,omitempty"`
	// Whether the schedule window is currently active (computed field)
	IsActive bool `json:"isActive"`
	// When the schedule was created
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (RoutingSchedule) IsNode() {}

// Input for running diagnostics on a service instance.
type RunDiagnosticsInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Instance ID to run diagnostics on
	InstanceID string `json:"instanceID"`
	// Specific test names to run (empty = run all tests)
	TestNames graphql.Omittable[[]string] `json:"testNames,omitempty"`
}

// Payload for run diagnostics mutation.
type RunDiagnosticsPayload struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// Diagnostic results
	Results []*DiagnosticResult `json:"results,omitempty"`
	// Run group ID linking these results together
	RunGroupID *string `json:"runGroupID,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of running a diagnostic step
type RunTroubleshootStepPayload struct {
	// Updated step with result
	Step *TroubleshootStep `json:"step"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Resource-specific runtime metrics
type RuntimeMetrics struct {
	// Bytes received
	BytesIn *Size `json:"bytesIn,omitempty"`
	// Bytes transmitted
	BytesOut *Size `json:"bytesOut,omitempty"`
	// Packets received
	PacketsIn *int `json:"packetsIn,omitempty"`
	// Packets transmitted
	PacketsOut *int `json:"packetsOut,omitempty"`
	// Error count
	Errors *int `json:"errors,omitempty"`
	// Drops count
	Drops *int `json:"drops,omitempty"`
	// Current throughput in (bytes/sec)
	ThroughputIn *Size `json:"throughputIn,omitempty"`
	// Current throughput out (bytes/sec)
	ThroughputOut *Size `json:"throughputOut,omitempty"`
	// Resource-specific custom metrics
	Custom map[string]any `json:"custom,omitempty"`
}

// Layer 4: Live operational state polled/streamed from router.
// Updated via polling (5-60s interval) or WebSocket push.
type RuntimeState struct {
	// Whether the resource is currently running/active
	IsRunning bool `json:"isRunning"`
	// Health status of the resource
	Health RuntimeHealth `json:"health"`
	// Error message if resource is unhealthy
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Resource-specific runtime metrics
	Metrics *RuntimeMetrics `json:"metrics,omitempty"`
	// Last time runtime was updated
	LastUpdated time.Time `json:"lastUpdated"`
	// Time since last successful operation
	LastSuccessfulOperation *time.Time `json:"lastSuccessfulOperation,omitempty"`
	// Current peers/connections (for VPN, etc.)
	ActiveConnections *int `json:"activeConnections,omitempty"`
	// Resource uptime
	Uptime *Duration `json:"uptime,omitempty"`
}

// SSTP VPN Client resource implementing 8-layer model
type SSTPClient struct {
	ID             string                 `json:"id"`
	ScopedID       string                 `json:"scopedId"`
	Type           string                 `json:"type"`
	Category       ResourceCategory       `json:"category"`
	Configuration  map[string]any         `json:"configuration,omitempty"`
	Validation     *ValidationResult      `json:"validation,omitempty"`
	Deployment     *DeploymentState       `json:"deployment,omitempty"`
	Runtime        *RuntimeState          `json:"runtime,omitempty"`
	Telemetry      *TelemetryData         `json:"telemetry,omitempty"`
	Metadata       *ResourceMetadata      `json:"metadata"`
	Relationships  *ResourceRelationships `json:"relationships,omitempty"`
	Platform       *PlatformInfo          `json:"platform,omitempty"`
	Config         *SSTPClientConfig      `json:"config"`
	SstpDeployment *SSTPDeployment        `json:"sstpDeployment,omitempty"`
	SstpRuntime    *SSTPRuntime           `json:"sstpRuntime,omitempty"`
}

func (SSTPClient) IsResource() {}

func (SSTPClient) IsNode() {}

// SSTP client configuration
type SSTPClientConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// VPN server address
	Server string `json:"server"`
	// VPN server port
	Port *Port `json:"port,omitempty"`
	// Username
	Username string `json:"username"`
	// Password
	Password string `json:"password"`
	// Authentication method
	AuthMethod string `json:"authMethod"`
	// TLS version
	TLSVersion *string `json:"tlsVersion,omitempty"`
	// Verify server certificate
	VerifyServerCert *bool `json:"verifyServerCert,omitempty"`
	// Server Name Indication (SNI)
	Sni *string `json:"sni,omitempty"`
	// WAN interface to use
	WanInterface *string `json:"wanInterface,omitempty"`
}

// SSTP deployment state
type SSTPDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// SSTP runtime state
type SSTPRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether connected to VPN
	IsConnected bool `json:"isConnected"`
	// Connection uptime
	ConnectionUptime *Duration `json:"connectionUptime,omitempty"`
	// Tunnel IP address
	TunnelAddress *IPv4 `json:"tunnelAddress,omitempty"`
	// Bytes in
	BytesIn Size `json:"bytesIn"`
	// Bytes out
	BytesOut Size `json:"bytesOut"`
}

// Input for saving custom alert rule template
type SaveAlertRuleTemplateInput struct {
	// Template name
	Name string `json:"name"`
	// Template description
	Description string `json:"description"`
	// Template category
	Category AlertRuleTemplateCategory `json:"category"`
	// Alert severity
	Severity AlertSeverity `json:"severity"`
	// Event type
	EventType string `json:"eventType"`
	// Alert conditions
	Conditions []*AlertConditionInput `json:"conditions"`
	// Throttle configuration
	Throttle graphql.Omittable[*ThrottleConfigInput] `json:"throttle,omitempty"`
	// Notification channels
	Channels []string `json:"channels"`
	// Template variables
	Variables graphql.Omittable[[]*AlertRuleAlertTemplateVariableInput] `json:"variables,omitempty"`
}

// Input for saving a custom alert template
type SaveAlertTemplateInput struct {
	// Template name
	Name string `json:"name"`
	// Template description
	Description string `json:"description"`
	// Event type
	EventType string `json:"eventType"`
	// Notification channel
	Channel NotificationChannel `json:"channel"`
	// Subject template
	SubjectTemplate graphql.Omittable[*string] `json:"subjectTemplate,omitempty"`
	// Body template
	BodyTemplate string `json:"bodyTemplate"`
	// Template variables
	Variables []*AlertAlertTemplateVariableInput `json:"variables"`
	// Tags
	Tags graphql.Omittable[[]string] `json:"tags,omitempty"`
	// Metadata
	Metadata graphql.Omittable[map[string]any] `json:"metadata,omitempty"`
}

// Input for saving a custom template.
type SaveTemplateInput struct {
	// Template name
	Name string `json:"name"`
	// Template description
	Description string `json:"description"`
	// Category
	Category TemplateCategory `json:"category"`
	// Variable definitions
	Variables []*FirewallTemplateVariableInput `json:"variables"`
	// Rule definitions
	Rules []*TemplateRuleInput `json:"rules"`
}

// Input for starting a network scan
type ScanNetworkInput struct {
	// Target subnet in CIDR notation (e.g., '192.168.88.0/24') or IP range (e.g., '192.168.1.1-192.168.1.100')
	Subnet string `json:"subnet"`
}

type ScanNetworkPayload struct {
	// The created scan task
	Task *ScanTask `json:"task,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Real-time progress event for scan subscriptions
type ScanProgressEvent struct {
	// Task ID this event belongs to
	TaskID string `json:"taskId"`
	// Current progress percentage (0-100)
	Progress int `json:"progress"`
	// Number of MikroTik devices found so far
	DevicesFound int `json:"devicesFound"`
	// IP address currently being scanned
	CurrentIP *string `json:"currentIP,omitempty"`
	// Current scan status
	Status ScanStatus `json:"status"`
	// Timestamp of this progress update
	Timestamp time.Time `json:"timestamp"`
}

// Payload for scanStorage mutation.
type ScanStoragePayload struct {
	// Detected storage locations
	StorageInfo []*StorageInfo `json:"storageInfo"`
	// Number of new storage locations detected
	NewStorageCount int `json:"newStorageCount"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// A network scan task that tracks scan progress and results.
// Scans are asynchronous - start with mutation, poll/subscribe for progress.
type ScanTask struct {
	// Unique task identifier
	ID string `json:"id"`
	// Target subnet (CIDR notation, IP range, or gateway scan indicator)
	Subnet string `json:"subnet"`
	// Current scan status
	Status ScanStatus `json:"status"`
	// Scan progress percentage (0-100)
	Progress int `json:"progress"`
	// Discovered devices (populated as scan progresses)
	Results []*DiscoveredDevice `json:"results"`
	// When the scan was started
	StartTime time.Time `json:"startTime"`
	// When the scan completed (null if still running)
	EndTime *time.Time `json:"endTime,omitempty"`
	// Error message if scan failed
	Error *string `json:"error,omitempty"`
	// Total IPs to scan (for progress calculation)
	TotalIPs *int `json:"totalIPs,omitempty"`
	// Number of IPs scanned so far
	ScannedIPs *int `json:"scannedIPs,omitempty"`
}

// Schedule event for subscriptions.
// Emitted when schedules are created, updated, deleted, or when activation state changes.
type ScheduleEvent struct {
	// Event ID
	ID string `json:"id"`
	// Event type (created, updated, deleted, activated, deactivated)
	EventType string `json:"eventType"`
	// Schedule that changed
	Schedule *RoutingSchedule `json:"schedule,omitempty"`
	// Routing ID (for deleted schedules)
	RoutingID *string `json:"routingID,omitempty"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// Service configuration sharing event for subscriptions.
// Emitted when configs are exported, imported, or QR codes generated.
type ServiceConfigSharedEvent struct {
	// Event ID
	ID string `json:"id"`
	// Event type (exported, imported, qr_generated)
	EventType string `json:"eventType"`
	// Router ID
	RouterID string `json:"routerID"`
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Service type
	ServiceType string `json:"serviceType"`
	// Service name
	ServiceName string `json:"serviceName"`
	// User who performed the action
	UserID *string `json:"userID,omitempty"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// ServiceDependency represents a dependency relationship between two service instances.
// Example: A VPN-over-Tor instance depends on a Tor instance being running.
type ServiceDependency struct {
	ID                   string           `json:"id"`
	FromInstance         *ServiceInstance `json:"fromInstance"`
	ToInstance           *ServiceInstance `json:"toInstance"`
	DependencyType       DependencyType   `json:"dependencyType"`
	AutoStart            bool             `json:"autoStart"`
	HealthTimeoutSeconds int              `json:"healthTimeoutSeconds"`
	CreatedAt            time.Time        `json:"createdAt"`
	UpdatedAt            time.Time        `json:"updatedAt"`
}

// Export package containing service configuration.
// Used for sharing service configs via JSON or QR code.
type ServiceExportPackage struct {
	// Schema version (e.g., "1.0")
	SchemaVersion string `json:"schemaVersion"`
	// Timestamp when the export was created
	ExportedAt time.Time `json:"exportedAt"`
	// Service type identifier (e.g., 'tor', 'mtproxy')
	ServiceType string `json:"serviceType"`
	// Service instance name
	ServiceName string `json:"serviceName"`
	// Binary version
	BinaryVersion string `json:"binaryVersion"`
	// Service configuration (JSON)
	Config map[string]any `json:"config"`
	// Optional routing rules for device routing
	RoutingRules []*RoutingRule `json:"routingRules,omitempty"`
	// Whether secrets are included (not redacted)
	IncludesSecrets bool `json:"includesSecrets"`
	// User who exported this configuration
	ExportedByUserID *string `json:"exportedByUserID,omitempty"`
}

// Service instance running on a router.
// Represents an installed and potentially running service instance.
type ServiceInstance struct {
	// Instance ID (ULID)
	ID string `json:"id"`
	// Feature identifier (e.g., 'tor', 'sing-box')
	FeatureID string `json:"featureID"`
	// Human-readable instance name
	InstanceName string `json:"instanceName"`
	// Router ID this instance belongs to
	RouterID string `json:"routerID"`
	// Current lifecycle status
	Status ServiceInstanceStatus `json:"status"`
	// VLAN ID for network isolation
	VlanID *int `json:"vlanID,omitempty"`
	// IP address to bind the service to
	BindIP *string `json:"bindIP,omitempty"`
	// Ports used by this service instance
	Ports []int `json:"ports"`
	// Service-specific configuration (JSON)
	Config map[string]any `json:"config,omitempty"`
	// Path to the service binary
	BinaryPath *string `json:"binaryPath,omitempty"`
	// Version of the service binary
	BinaryVersion *string `json:"binaryVersion,omitempty"`
	// SHA256 checksum of the binary
	BinaryChecksum *string `json:"binaryChecksum,omitempty"`
	// Binary verification information (null if verification not enabled)
	Verification *BinaryVerification `json:"verification,omitempty"`
	// When the instance was created
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// The router this instance belongs to
	Router *Router `json:"router,omitempty"`
}

func (ServiceInstance) IsNode() {}

// Comprehensive health status for a service instance
// Combines process liveness, connection status, and latency metrics
type ServiceInstanceHealth struct {
	// Current health state of the instance
	Status InstanceHealthState `json:"status"`
	// Whether the service process is alive (PID check)
	ProcessAlive bool `json:"processAlive"`
	// Connection status from TCP/HTTP health probe
	ConnectionStatus HealthConnectionState `json:"connectionStatus"`
	// Health probe round-trip latency in milliseconds (null if probe hasn't run)
	LatencyMs *int `json:"latencyMs,omitempty"`
	// Timestamp of when the instance was last healthy (null if never healthy)
	LastHealthy *time.Time `json:"lastHealthy,omitempty"`
	// Number of consecutive health check failures
	ConsecutiveFails int `json:"consecutiveFails"`
	// Instance uptime in seconds (null if not running)
	UptimeSeconds *int `json:"uptimeSeconds,omitempty"`
}

// Health check configuration for a service instance
type ServiceInstanceHealthConfig struct {
	// Health check interval in seconds (10-300, default: 30)
	IntervalSeconds int `json:"intervalSeconds"`
	// Consecutive failures before marking unhealthy (1-10, default: 3)
	FailureThreshold int `json:"failureThreshold"`
	// Whether to auto-restart on health check failure (default: true)
	AutoRestart bool `json:"autoRestart"`
}

// Payload for service instance mutations.
type ServiceInstancePayload struct {
	// The service instance (null if operation failed)
	Instance *ServiceInstance `json:"instance,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Service log file with metadata.
// Represents captured logs from a service instance.
type ServiceLogFile struct {
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Service name
	ServiceName string `json:"serviceName"`
	// Log file path on router filesystem
	FilePath string `json:"filePath"`
	// Current log file size in bytes
	SizeBytes int `json:"sizeBytes"`
	// Number of log lines available
	LineCount int `json:"lineCount"`
	// Recent log entries (last N lines)
	Entries []*LogEntry `json:"entries"`
	// Timestamp when log file was created
	CreatedAt time.Time `json:"createdAt"`
	// Timestamp when log file was last updated
	LastUpdated time.Time `json:"lastUpdated"`
}

// Service result from template installation
type ServiceResult struct {
	// Service name from template
	ServiceName string `json:"serviceName"`
	// Created instance ID
	InstanceID *string `json:"instanceID,omitempty"`
	// Status (success/failed/skipped)
	Status string `json:"status"`
	// Error message if failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Creation timestamp
	CreatedAt time.Time `json:"createdAt"`
}

// Service specification within a template
type ServiceSpec struct {
	// Service type (feature ID like 'tor', 'xray-core')
	ServiceType string `json:"serviceType"`
	// Instance name template (supports variables)
	Name string `json:"name"`
	// Service-specific configuration overrides
	ConfigOverrides map[string]any `json:"configOverrides,omitempty"`
	// Service dependencies (references other services in template)
	DependsOn []string `json:"dependsOn,omitempty"`
	// Memory limit in MB
	MemoryLimitMb *int `json:"memoryLimitMB,omitempty"`
	// CPU shares
	CPUShares *int `json:"cpuShares,omitempty"`
	// Whether this service needs Virtual Interface Factory
	RequiresBridge *bool `json:"requiresBridge,omitempty"`
	// VLAN ID (null = auto-allocate)
	VlanID *int `json:"vlanID,omitempty"`
	// Port mappings
	PortMappings []*PortMapping `json:"portMappings,omitempty"`
}

// Service template
type ServiceTemplate struct {
	// Template ID (ULID)
	ID string `json:"id"`
	// Template name
	Name string `json:"name"`
	// Detailed description
	Description string `json:"description"`
	// Template category
	Category ServiceTemplateCategory `json:"category"`
	// Deployment scope
	Scope TemplateScope `json:"scope"`
	// Template version
	Version string `json:"version"`
	// Whether this is a built-in template
	IsBuiltIn bool `json:"isBuiltIn"`
	// Template author
	Author *string `json:"author,omitempty"`
	// Router ID (null for built-in templates)
	RouterID *string `json:"routerID,omitempty"`
	// Services to deploy
	Services []*ServiceSpec `json:"services"`
	// Configuration variables
	ConfigVariables []*TemplateVariable `json:"configVariables"`
	// Routing suggestions
	SuggestedRouting []*SuggestedRoutingRule `json:"suggestedRouting,omitempty"`
	// Resource estimates
	EstimatedResources *ResourceEstimate `json:"estimatedResources,omitempty"`
	// Search tags
	Tags []string `json:"tags,omitempty"`
	// Prerequisites
	Prerequisites []string `json:"prerequisites,omitempty"`
	// Documentation
	Documentation *string `json:"documentation,omitempty"`
	// Usage examples
	Examples []string `json:"examples,omitempty"`
	// Creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

func (ServiceTemplate) IsNode() {}

// Traffic statistics for a service instance.
// Tracks uploaded/downloaded bytes with historical data retention.
type ServiceTrafficStats struct {
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Total bytes uploaded (transmitted)
	TotalUploadBytes int `json:"totalUploadBytes"`
	// Total bytes downloaded (received)
	TotalDownloadBytes int `json:"totalDownloadBytes"`
	// Upload bytes in current period (day/week/month)
	CurrentPeriodUpload int `json:"currentPeriodUpload"`
	// Download bytes in current period (day/week/month)
	CurrentPeriodDownload int `json:"currentPeriodDownload"`
	// Historical data points for chart visualization
	History []*TrafficDataPoint `json:"history"`
	// Per-device breakdown (if available)
	DeviceBreakdown []*DeviceTrafficBreakdown `json:"deviceBreakdown"`
	// Traffic quota configuration (if set)
	Quota *TrafficQuota `json:"quota,omitempty"`
	// Timestamp of last statistics update
	LastUpdated time.Time `json:"lastUpdated"`
}

// Input for setting kill switch on a device routing.
type SetKillSwitchInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Device ID whose routing should have kill switch
	DeviceID string `json:"deviceID"`
	// Whether to enable kill switch
	Enabled bool `json:"enabled"`
	// Kill switch behavior mode
	Mode KillSwitchMode `json:"mode"`
	// Fallback interface ID (required if mode=FALLBACK_SERVICE)
	FallbackInterfaceID graphql.Omittable[*string] `json:"fallbackInterfaceID,omitempty"`
}

type SetPreferredProtocolPayload struct {
	// The updated router
	Router *Router `json:"router,omitempty"`
	// Updated connection details
	ConnectionDetails *ConnectionDetails `json:"connectionDetails,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for setting resource limits on a service instance.
type SetResourceLimitsInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Memory limit in megabytes (minimum 16MB)
	MemoryMb int `json:"memoryMB"`
	// CPU weight for scheduling (0-100, optional)
	CPUWeight graphql.Omittable[*int] `json:"cpuWeight,omitempty"`
}

// Input for setting a traffic quota on a service instance.
type SetTrafficQuotaInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Instance ID to set quota on
	InstanceID string `json:"instanceID"`
	// Maximum bytes allowed per period (0 = unlimited)
	LimitBytes int `json:"limitBytes"`
	// Quota period
	Period QuotaPeriod `json:"period"`
	// Action to take when quota is reached
	Action QuotaAction `json:"action"`
	// Warning threshold percentage (0-100, default 80)
	WarningThreshold graphql.Omittable[*int] `json:"warningThreshold,omitempty"`
}

// Single device routing assignment for bulk operations.
type SingleDeviceRoutingInput struct {
	// Device ID
	DeviceID string `json:"deviceID"`
	// Device MAC address
	MacAddress string `json:"macAddress"`
	// Device IP (optional)
	DeviceIP graphql.Omittable[*string] `json:"deviceIP,omitempty"`
	// Device name (optional)
	DeviceName graphql.Omittable[*string] `json:"deviceName,omitempty"`
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Interface ID
	InterfaceID string `json:"interfaceID"`
	// Routing mark
	RoutingMark string `json:"routingMark"`
	// Routing mode
	RoutingMode RoutingMode `json:"routingMode"`
}

// Software information detected from router
type SoftwareInfo struct {
	// RouterOS version string
	Version string `json:"version"`
	// Parsed major version number
	VersionMajor int `json:"versionMajor"`
	// Parsed minor version number
	VersionMinor int `json:"versionMinor"`
	// Parsed patch version number
	VersionPatch *int `json:"versionPatch,omitempty"`
	// List of installed packages
	InstalledPackages []string `json:"installedPackages"`
	// License level (0-6)
	LicenseLevel int `json:"licenseLevel"`
	// Update channel (stable, testing, development)
	UpdateChannel *string `json:"updateChannel,omitempty"`
}

// Input for starting a service instance.
type StartInstanceInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Instance ID to start
	InstanceID string `json:"instanceID"`
}

// Input for starting a new provisioning session
type StartProvisioningSessionInput struct {
	// Provisioning mode (EASY or ADVANCE)
	Mode ProvisioningMode `json:"mode"`
	// Target firmware
	Firmware ProvisioningFirmware `json:"firmware"`
	// Router operational mode
	RouterMode ProvisioningRouterMode `json:"routerMode"`
	// WAN link type
	WanLinkType ProvisioningWANLinkType `json:"wanLinkType"`
	// Initial networks configuration (LAN, DHCP, etc.)
	// JSON structure varies by router mode and firmware
	Networks map[string]any `json:"networks"`
}

// Result of starting a troubleshooting session
type StartTroubleshootPayload struct {
	// The created session
	Session *TroubleshootSession `json:"session,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Startup diagnostic results collected during instance boot.
// Automatically run when a service starts.
type StartupDiagnostics struct {
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Run group ID linking these results together
	RunGroupID string `json:"runGroupID"`
	// Test results
	Results []*DiagnosticResult `json:"results"`
	// Overall health status (pass if all tests passed)
	OverallStatus DiagnosticStatus `json:"overallStatus"`
	// Number of tests that passed
	PassedCount int `json:"passedCount"`
	// Number of tests that failed
	FailedCount int `json:"failedCount"`
	// Number of tests with warnings
	WarningCount int `json:"warningCount"`
	// Total number of tests run
	TotalTests int `json:"totalTests"`
	// Timestamp when diagnostics were run
	Timestamp time.Time `json:"timestamp"`
}

// Static IP WAN configuration
type StaticIPConfig struct {
	// Unique identifier
	ID string `json:"id"`
	// Interface name
	Interface string `json:"interface"`
	// Static IP address with CIDR
	Address CIDR `json:"address"`
	// Gateway IP address
	Gateway IPv4 `json:"gateway"`
	// Primary DNS server
	PrimaryDNS *IPv4 `json:"primaryDNS,omitempty"`
	// Secondary DNS server
	SecondaryDNS *IPv4 `json:"secondaryDNS,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
}

func (StaticIPConfig) IsNode() {}

// Input for configuring static IP WAN
type StaticIPInput struct {
	// Interface to configure
	Interface string `json:"interface"`
	// Static IP address with CIDR (e.g., 203.0.113.5/30)
	Address CIDR `json:"address"`
	// Gateway IP address
	Gateway IPv4 `json:"gateway"`
	// Primary DNS server
	PrimaryDNS graphql.Omittable[*IPv4] `json:"primaryDNS,omitempty"`
	// Secondary DNS server
	SecondaryDNS graphql.Omittable[*IPv4] `json:"secondaryDNS,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// A single data point in interface statistics history
type StatsDataPoint struct {
	// Timestamp of the data point
	Timestamp time.Time `json:"timestamp"`
	// Transmit rate in bytes per second
	TxBytesPerSec float64 `json:"txBytesPerSec"`
	// Receive rate in bytes per second
	RxBytesPerSec float64 `json:"rxBytesPerSec"`
	// Transmit rate in packets per second
	TxPacketsPerSec float64 `json:"txPacketsPerSec"`
	// Receive rate in packets per second
	RxPacketsPerSec float64 `json:"rxPacketsPerSec"`
	// Transmission errors in this interval
	TxErrors int `json:"txErrors"`
	// Receive errors in this interval
	RxErrors int `json:"rxErrors"`
}

// Input for specifying a time range
type StatsTimeRangeInput struct {
	// Start of the time range
	Start time.Time `json:"start"`
	// End of the time range
	End time.Time `json:"end"`
}

// Input for stopping a service instance.
type StopInstanceInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Instance ID to stop
	InstanceID string `json:"instanceID"`
}

// Storage breakdown for a specific location (flash or external).
// Shows what types of data are stored and capacity metrics.
type StorageBreakdown struct {
	// Total capacity in bytes (serialized uint64)
	TotalBytes string `json:"totalBytes"`
	// Used space in bytes (serialized uint64)
	UsedBytes string `json:"usedBytes"`
	// Available free space in bytes (serialized uint64)
	AvailableBytes string `json:"availableBytes"`
	// Human-readable description of contents (e.g., 'Configs, DB' or 'Binaries, data')
	Contents string `json:"contents"`
	// Usage percentage (0-100)
	UsagePercent float64 `json:"usagePercent"`
	// Storage location type
	LocationType StorageLocationType `json:"locationType"`
	// Space threshold status
	ThresholdStatus StorageThresholdStatus `json:"thresholdStatus"`
}

// Storage configuration state.
// Represents the current external storage configuration.
type StorageConfig struct {
	// Whether external storage is enabled and configured
	Enabled bool `json:"enabled"`
	// Configured external storage path (null if not configured)
	Path *string `json:"path,omitempty"`
	// Storage info for configured path (null if not mounted)
	StorageInfo *StorageInfo `json:"storageInfo,omitempty"`
	// When the configuration was last updated
	UpdatedAt time.Time `json:"updatedAt"`
	// Whether configured storage is currently available
	IsAvailable bool `json:"isAvailable"`
}

// Information about a storage location (flash or external).
// Represents a detected mount point with capacity and filesystem information.
type StorageInfo struct {
	// Absolute path to the mount point (e.g., '/data', '/usb1', '/disk1')
	Path string `json:"path"`
	// Total capacity in bytes (serialized uint64)
	TotalBytes string `json:"totalBytes"`
	// Available free space in bytes (serialized uint64)
	AvailableBytes string `json:"availableBytes"`
	// Used space in bytes (serialized uint64)
	UsedBytes string `json:"usedBytes"`
	// Filesystem type (e.g., 'ext4', 'vfat', 'ntfs')
	Filesystem string `json:"filesystem"`
	// Whether the storage is currently mounted and accessible
	Mounted bool `json:"mounted"`
	// Usage percentage (0-100, calculated from used/total)
	UsagePercent float64 `json:"usagePercent"`
	// Storage location type
	LocationType StorageLocationType `json:"locationType"`
}

// Storage utilization metrics
type StorageMetrics struct {
	// Used storage in bytes
	Used float64 `json:"used"`
	// Total storage in bytes
	Total float64 `json:"total"`
	// Storage usage percentage (0-100)
	Percentage float64 `json:"percentage"`
}

// Event emitted when storage is mounted or becomes available.
type StorageMountedEvent struct {
	// Storage path that was mounted
	Path string `json:"path"`
	// Storage information
	StorageInfo *StorageInfo `json:"storageInfo"`
	// Number of features restored (if reconnection)
	FeaturesRestored int `json:"featuresRestored"`
	// Timestamp of the event
	Timestamp time.Time `json:"timestamp"`
}

func (StorageMountedEvent) IsStorageMountEvent() {}

// Event emitted when storage space crosses a threshold.
type StorageSpaceEvent struct {
	// Storage path
	Path string `json:"path"`
	// Current threshold status
	Status StorageThresholdStatus `json:"status"`
	// Previous threshold status
	PreviousStatus StorageThresholdStatus `json:"previousStatus"`
	// Current usage percentage
	UsagePercent float64 `json:"usagePercent"`
	// Available bytes remaining (serialized uint64)
	AvailableBytes string `json:"availableBytes"`
	// Timestamp of the event
	Timestamp time.Time `json:"timestamp"`
}

// Event emitted when storage is unmounted or becomes unavailable.
type StorageUnmountedEvent struct {
	// Storage path that was unmounted
	Path string `json:"path"`
	// Number of features affected (stopped)
	FeaturesAffected int `json:"featuresAffected"`
	// List of affected feature IDs
	AffectedFeatureIds []string `json:"affectedFeatureIds"`
	// Timestamp of the event
	Timestamp time.Time `json:"timestamp"`
}

func (StorageUnmountedEvent) IsStorageMountEvent() {}

// Comprehensive storage usage breakdown across flash and external locations.
// Shows how storage is allocated across configs, binaries, data, and per-feature.
type StorageUsage struct {
	// Flash memory usage breakdown
	Flash *StorageBreakdown `json:"flash"`
	// External storage usage breakdown (null if not configured)
	External *StorageBreakdown `json:"external,omitempty"`
	// Per-feature storage usage details
	Features []*FeatureStorageUsage `json:"features"`
	// Total storage usage across all locations in bytes (serialized uint64)
	TotalUsedBytes string `json:"totalUsedBytes"`
	// Total available capacity across all locations in bytes (serialized uint64)
	TotalCapacityBytes string `json:"totalCapacityBytes"`
	// Timestamp when usage was calculated
	CalculatedAt time.Time `json:"calculatedAt"`
}

// Alert rule contribution to storm detection
type StormRuleContribution struct {
	// Alert rule ID
	RuleID string `json:"ruleId"`
	// Alert rule name
	RuleName string `json:"ruleName"`
	// Number of alerts from this rule in current window
	AlertCount int `json:"alertCount"`
	// Percentage of total alerts
	Percentage float64 `json:"percentage"`
}

// Storm detection status
// Shows if alert storm is detected and current metrics
type StormStatus struct {
	// Whether storm is currently detected
	IsStormDetected bool `json:"isStormDetected"`
	// Number of alerts in current window
	AlertCount int `json:"alertCount"`
	// Storm detection threshold
	Threshold int `json:"threshold"`
	// Window duration in seconds
	WindowSeconds int `json:"windowSeconds"`
	// When storm detection started
	StormStartedAt *time.Time `json:"stormStartedAt,omitempty"`
	// When current window started
	WindowStart time.Time `json:"windowStart"`
	// When current window ends
	WindowEnd time.Time `json:"windowEnd"`
	// Top alert rules contributing to the storm
	TopRules []*StormRuleContribution `json:"topRules"`
}

type Subscription struct {
}

// Routing suggestion for a template
type SuggestedRoutingRule struct {
	// Device name pattern (e.g., 'all', 'phone-*')
	DevicePattern string `json:"devicePattern"`
	// Target service name from template
	TargetService string `json:"targetService"`
	// Protocol filter
	Protocol *string `json:"protocol,omitempty"`
	// Destination port filter
	DestinationPort *int `json:"destinationPort,omitempty"`
	// Rule description
	Description string `json:"description"`
}

// System-wide resource overview for a router.
// Shows total resources, available resources, and per-instance allocations.
type SystemResources struct {
	// Total RAM available on the router in megabytes
	TotalRAM int `json:"totalRAM"`
	// Available (unallocated) RAM in megabytes
	AvailableRAM int `json:"availableRAM"`
	// Total allocated RAM across all instances in megabytes
	AllocatedRAM int `json:"allocatedRAM"`
	// Per-instance resource usage details
	Instances []*InstanceResourceUsage `json:"instances"`
}

// TLS certificate status for secure connections
type TLSStatus struct {
	// Whether the certificate is valid
	Valid bool `json:"valid"`
	// Certificate issuer
	Issuer *string `json:"issuer,omitempty"`
	// Certificate subject
	Subject *string `json:"subject,omitempty"`
	// Certificate expiration date
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// Error message (if certificate is invalid)
	Error *string `json:"error,omitempty"`
}

// Layer 5: Time-series metrics and historical data.
// Collected over time for analytics and trending.
type TelemetryData struct {
	// Bandwidth history (last 24h)
	BandwidthHistory []*BandwidthDataPoint `json:"bandwidthHistory,omitempty"`
	// Uptime history (availability)
	UptimeHistory []*UptimeDataPoint `json:"uptimeHistory,omitempty"`
	// Hourly statistics
	HourlyStats []*HourlyStats `json:"hourlyStats,omitempty"`
	// Daily statistics
	DailyStats []*DailyStats `json:"dailyStats,omitempty"`
	// First data point timestamp
	DataStartedAt *time.Time `json:"dataStartedAt,omitempty"`
	// Last data point timestamp
	LastUpdatedAt *time.Time `json:"lastUpdatedAt,omitempty"`
	// Data retention period
	RetentionDays int `json:"retentionDays"`
}

// Detected conflict between template and existing configuration.
type TemplateConflict struct {
	// Type of conflict
	Type TemplateConflictType `json:"type"`
	// Human-readable conflict description
	Message string `json:"message"`
	// Existing rule ID that conflicts (if applicable)
	ExistingRuleID *string `json:"existingRuleId,omitempty"`
	// Proposed template rule that conflicts
	ProposedRule *TemplateRule `json:"proposedRule"`
}

// Template installation progress
type TemplateInstallProgress struct {
	// Template ID being installed
	TemplateID string `json:"templateID"`
	// Total number of services
	TotalServices int `json:"totalServices"`
	// Number of services installed
	InstalledCount int `json:"installedCount"`
	// Current service being installed
	CurrentService *string `json:"currentService,omitempty"`
	// Installation status
	Status TemplateInstallationStatus `json:"status"`
	// Error message if failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Installation start time
	StartedAt time.Time `json:"startedAt"`
	// Installation completion time
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	// Individual service results
	ServiceResults []*ServiceResult `json:"serviceResults"`
}

// Template installation result
type TemplateInstallResult struct {
	// Whether installation was successful
	Success bool `json:"success"`
	// Created instance IDs
	InstanceIDs []string `json:"instanceIDs"`
	// Map of service names to instance IDs
	ServiceMapping map[string]any `json:"serviceMapping"`
	// Errors encountered
	Errors []string `json:"errors,omitempty"`
	// Installation progress
	Progress *TemplateInstallProgress `json:"progress,omitempty"`
}

// Template preview result
type TemplatePreview struct {
	// The template that was previewed
	Template *AlertTemplate `json:"template"`
	// Rendered subject after variable substitution
	RenderedSubject string `json:"renderedSubject"`
	// Rendered body after variable substitution
	RenderedBody string `json:"renderedBody"`
	// Variables used in preview
	Variables map[string]any `json:"variables"`
	// Validation information
	ValidationInfo *TemplateValidationInfo `json:"validationInfo"`
}

// Template preview payload
type TemplatePreviewPayload struct {
	// Preview result
	Preview *TemplatePreview `json:"preview,omitempty"`
	// Errors encountered during preview
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of template preview operation.
// Shows what will happen when template is applied.
type TemplatePreviewResult struct {
	// The template being previewed
	Template *FirewallTemplate `json:"template"`
	// Rules with variables resolved
	ResolvedRules []*TemplateRule `json:"resolvedRules"`
	// Detected conflicts with existing rules
	Conflicts []*TemplateConflict `json:"conflicts"`
	// Impact analysis
	ImpactAnalysis *ImpactAnalysis `json:"impactAnalysis"`
}

// Template rule definition.
// Represents a firewall rule that will be created when template is applied.
type TemplateRule struct {
	// Firewall table (filter, nat, mangle, raw)
	Table FirewallTable `json:"table"`
	// Chain name
	Chain string `json:"chain"`
	// Action to perform
	Action string `json:"action"`
	// Optional comment (can include template metadata)
	Comment *string `json:"comment,omitempty"`
	// Position in the chain (null = append to end)
	Position *int `json:"position,omitempty"`
	// Rule properties as JSON (can include variable references like {{LAN_INTERFACE}})
	Properties map[string]any `json:"properties"`
}

// Input for defining a template rule.
type TemplateRuleInput struct {
	// Firewall table
	Table FirewallTable `json:"table"`
	// Chain name
	Chain string `json:"chain"`
	// Action
	Action string `json:"action"`
	// Comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
	// Position
	Position graphql.Omittable[*int] `json:"position,omitempty"`
	// Rule properties as JSON
	Properties map[string]any `json:"properties"`
}

// Template validation information
type TemplateValidationInfo struct {
	// Whether the template is valid with provided variables
	IsValid bool `json:"isValid"`
	// Missing required variables
	MissingVariables []string `json:"missingVariables"`
	// Validation warnings
	Warnings []string `json:"warnings"`
}

// Configuration variable for a template
type TemplateVariable struct {
	// Variable name (e.g., 'TOR_NAME')
	Name string `json:"name"`
	// Variable type
	Type TemplateVariableType `json:"type"`
	// Whether the variable is required
	Required bool `json:"required"`
	// Default value (can be null)
	Default map[string]any `json:"default,omitempty"`
	// Human-readable description
	Description string `json:"description"`
	// Display label for UI
	Label string `json:"label"`
	// Regex pattern for validation
	ValidationPattern *string `json:"validationPattern,omitempty"`
	// Minimum value for number types
	MinValue *float64 `json:"minValue,omitempty"`
	// Maximum value for number types
	MaxValue *float64 `json:"maxValue,omitempty"`
	// Allowed values for enum types
	EnumValues []map[string]any `json:"enumValues,omitempty"`
}

// Result of testing all router credentials.
type TestAllCredentialsPayload struct {
	// Total number of routers tested
	TotalRouters int `json:"totalRouters"`
	// Number of successful credential tests
	SuccessCount int `json:"successCount"`
	// Number of failed credential tests
	FailureCount int `json:"failureCount"`
	// Per-router test results
	Results []*CredentialTestResult `json:"results"`
}

type TestConnectionPayload struct {
	// Whether the connection test succeeded
	Success bool `json:"success"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Router version if connection succeeded
	Version *string `json:"version,omitempty"`
	// Error message if connection failed
	Error *string `json:"error,omitempty"`
}

// Test notification payload
type TestNotificationPayload struct {
	// Whether test was successful
	Success bool `json:"success"`
	// Test result message
	Message *string `json:"message,omitempty"`
	// Errors encountered during test
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of test port knock operation.
type TestPortKnockResult struct {
	// Whether test rules were created successfully
	Success bool `json:"success"`
	// Test instructions for user
	TestInstructions string `json:"testInstructions"`
	// Message
	Message string `json:"message"`
	// Test rule IDs (will auto-expire)
	TestRuleIds []string `json:"testRuleIds"`
}

// Throttle configuration to prevent alert spam
type ThrottleConfig struct {
	// Maximum number of alerts allowed
	MaxAlerts int `json:"maxAlerts"`
	// Time period in seconds
	PeriodSeconds int `json:"periodSeconds"`
	// Optional field to group alerts by
	GroupByField *string `json:"groupByField,omitempty"`
}

// Throttle configuration input
type ThrottleConfigInput struct {
	// Maximum number of alerts allowed
	MaxAlerts int `json:"maxAlerts"`
	// Time period in seconds
	PeriodSeconds int `json:"periodSeconds"`
	// Optional field to group alerts by
	GroupByField graphql.Omittable[*string] `json:"groupByField,omitempty"`
}

// Throttle status for a specific group (when groupByField is used)
type ThrottleGroupStatus struct {
	// Group identifier (value of groupByField)
	GroupKey string `json:"groupKey"`
	// Whether this group is currently throttled
	IsThrottled bool `json:"isThrottled"`
	// Number of alerts suppressed for this group
	SuppressedCount int `json:"suppressedCount"`
	// When the throttle window for this group started
	WindowStart time.Time `json:"windowStart"`
	// When the throttle window for this group ends
	WindowEnd time.Time `json:"windowEnd"`
}

// Throttle status for an alert rule
// Shows current throttling state and suppressed alert counts
type ThrottleStatus struct {
	// Alert rule ID
	RuleID string `json:"ruleId"`
	// Whether the rule is currently throttled
	IsThrottled bool `json:"isThrottled"`
	// Number of alerts suppressed in current throttle window
	SuppressedCount int `json:"suppressedCount"`
	// When the current throttle window started
	WindowStart *time.Time `json:"windowStart,omitempty"`
	// When the current throttle window ends
	WindowEnd *time.Time `json:"windowEnd,omitempty"`
	// Throttle groups (if groupByField is configured)
	Groups []*ThrottleGroupStatus `json:"groups"`
}

// Edge connecting nodes in a topology
type TopologyEdge struct {
	// Edge ID
	ID string `json:"id"`
	// Source node ID
	Source string `json:"source"`
	// Target node ID
	Target string `json:"target"`
	// Edge label (optional)
	Label *string `json:"label,omitempty"`
	// Additional edge data
	Data map[string]any `json:"data,omitempty"`
	// Edge styling
	Style *TopologyEdgeStyle `json:"style,omitempty"`
}

// Styling for topology edges
type TopologyEdgeStyle struct {
	// Stroke color (CSS color)
	Stroke *string `json:"stroke,omitempty"`
	// Stroke width in pixels
	StrokeWidth *float64 `json:"strokeWidth,omitempty"`
	// Stroke dash array (for dashed lines)
	StrokeDasharray *string `json:"strokeDasharray,omitempty"`
}

// Node in a VLAN network topology diagram
type TopologyNode struct {
	// Node ID
	ID string `json:"id"`
	// Node type (bridge, vlan, port)
	Type TopologyNodeType `json:"type"`
	// Display label
	Label string `json:"label"`
	// Sub-label (optional)
	Sublabel *string `json:"sublabel,omitempty"`
	// Node position in the diagram
	Position *TopologyPosition `json:"position"`
	// Additional node data
	Data map[string]any `json:"data,omitempty"`
	// Node styling
	Style *TopologyNodeStyle `json:"style,omitempty"`
}

// Styling for topology nodes
type TopologyNodeStyle struct {
	// Fill color (CSS color)
	Fill *string `json:"fill,omitempty"`
	// Stroke color (CSS color)
	Stroke *string `json:"stroke,omitempty"`
	// Stroke width in pixels
	StrokeWidth *float64 `json:"strokeWidth,omitempty"`
}

// Position of a node in the topology
type TopologyPosition struct {
	// X coordinate
	X float64 `json:"x"`
	// Y coordinate
	Y float64 `json:"y"`
}

// A single hop in the traceroute path
type TracerouteHop struct {
	// Hop number (1-based)
	HopNumber int `json:"hopNumber"`
	// IP address of the hop (null for timeout)
	Address *string `json:"address,omitempty"`
	// Reverse DNS hostname (if available)
	Hostname *string `json:"hostname,omitempty"`
	// Individual probe results for this hop
	Probes []*HopProbe `json:"probes"`
	// Status of this hop
	Status HopStatus `json:"status"`
	// Average latency across successful probes
	AvgLatencyMs *float64 `json:"avgLatencyMs,omitempty"`
	// Packet loss percentage for this hop (0-100)
	PacketLoss float64 `json:"packetLoss"`
}

// Input parameters for starting a traceroute
type TracerouteInput struct {
	// Target hostname or IP address
	Target string `json:"target"`
	// Maximum number of hops (default: 30, max: 64)
	MaxHops graphql.Omittable[*int] `json:"maxHops,omitempty"`
	// Timeout per hop in milliseconds (default: 3000)
	Timeout graphql.Omittable[*int] `json:"timeout,omitempty"`
	// Number of probes per hop (default: 3)
	ProbeCount graphql.Omittable[*int] `json:"probeCount,omitempty"`
	// Protocol to use for probes (default: ICMP)
	Protocol graphql.Omittable[*TracerouteProtocol] `json:"protocol,omitempty"`
}

// Traceroute job reference for subscription tracking
type TracerouteJob struct {
	// Unique job identifier
	JobID string `json:"jobId"`
	// Current job status
	Status JobStatus `json:"status"`
}

// Progress event emitted during traceroute execution
type TracerouteProgressEvent struct {
	// Job identifier
	JobID string `json:"jobId"`
	// Type of event
	EventType TracerouteEventType `json:"eventType"`
	// Newly discovered hop (for HOP_DISCOVERED events)
	Hop *TracerouteHop `json:"hop,omitempty"`
	// Final result (for COMPLETE events)
	Result *TracerouteResult `json:"result,omitempty"`
	// Error message (for ERROR events)
	Error *string `json:"error,omitempty"`
}

// Complete traceroute result
type TracerouteResult struct {
	// Target hostname or IP address
	Target string `json:"target"`
	// Resolved target IP address
	TargetIP string `json:"targetIp"`
	// Protocol used for probes
	Protocol TracerouteProtocol `json:"protocol"`
	// Maximum hops configured
	MaxHops int `json:"maxHops"`
	// Discovered hops in order
	Hops []*TracerouteHop `json:"hops"`
	// Whether traceroute completed
	Completed bool `json:"completed"`
	// Whether destination was reached
	ReachedDestination bool `json:"reachedDestination"`
	// Total time from start to completion (ms)
	TotalTimeMs float64 `json:"totalTimeMs"`
	// When the traceroute started
	StartedAt time.Time `json:"startedAt"`
	// When the traceroute completed (if finished)
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

// A single traffic data point for time-series visualization.
// Represents traffic volume at a specific timestamp.
type TrafficDataPoint struct {
	// Timestamp of this data point
	Timestamp time.Time `json:"timestamp"`
	// Bytes uploaded in this interval
	UploadBytes int `json:"uploadBytes"`
	// Bytes downloaded in this interval
	DownloadBytes int `json:"downloadBytes"`
	// Total bytes (upload + download)
	TotalBytes int `json:"totalBytes"`
}

// Traffic quota configuration for a service instance.
// Allows setting bandwidth limits with automated warnings and actions.
type TrafficQuota struct {
	// Quota ID
	ID string `json:"id"`
	// Instance ID this quota applies to
	InstanceID string `json:"instanceID"`
	// Maximum bytes allowed per period (0 = unlimited)
	LimitBytes int `json:"limitBytes"`
	// Quota period (daily, weekly, monthly)
	Period QuotaPeriod `json:"period"`
	// Action to take when quota is reached
	Action QuotaAction `json:"action"`
	// Bytes consumed in current period
	ConsumedBytes int `json:"consumedBytes"`
	// Remaining bytes in current period
	RemainingBytes int `json:"remainingBytes"`
	// Usage percentage (0-100)
	UsagePercent float64 `json:"usagePercent"`
	// Whether quota limit has been reached
	LimitReached bool `json:"limitReached"`
	// Warning threshold percentage (0-100, triggers warning alert)
	WarningThreshold int `json:"warningThreshold"`
	// Whether warning threshold has been exceeded
	WarningTriggered bool `json:"warningTriggered"`
	// When the current period started
	PeriodStartedAt time.Time `json:"periodStartedAt"`
	// When the current period will reset
	PeriodEndsAt time.Time `json:"periodEndsAt"`
	// Timestamp when quota was created
	CreatedAt time.Time `json:"createdAt"`
	// Timestamp when quota was last updated
	UpdatedAt time.Time `json:"updatedAt"`
}

// Payload for traffic quota mutation.
type TrafficQuotaPayload struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// Updated or created quota (null if failed)
	Quota *TrafficQuota `json:"quota,omitempty"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

// Traffic statistics update event for subscriptions.
// Emitted when traffic stats are updated (every 10 seconds).
type TrafficStatsEvent struct {
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Router ID
	RouterID string `json:"routerID"`
	// Total bytes uploaded
	TotalUploadBytes int `json:"totalUploadBytes"`
	// Total bytes downloaded
	TotalDownloadBytes int `json:"totalDownloadBytes"`
	// Upload bytes since last update
	DeltaUploadBytes int `json:"deltaUploadBytes"`
	// Download bytes since last update
	DeltaDownloadBytes int `json:"deltaDownloadBytes"`
	// Whether quota warning was triggered
	QuotaWarning bool `json:"quotaWarning"`
	// Whether quota limit was reached
	QuotaLimitReached bool `json:"quotaLimitReached"`
	// Timestamp of this update
	Timestamp time.Time `json:"timestamp"`
}

// Suggested fix for a failed diagnostic step
type TroubleshootFixSuggestion struct {
	// Unique issue code (e.g., WAN_DISABLED, NO_DEFAULT_ROUTE)
	IssueCode string `json:"issueCode"`
	// User-friendly fix title
	Title string `json:"title"`
	// Detailed explanation of what will be fixed
	Explanation string `json:"explanation"`
	// Confidence level for this fix
	Confidence FixConfidence `json:"confidence"`
	// Whether user confirmation is required before applying
	RequiresConfirmation bool `json:"requiresConfirmation"`
	// Whether this is a manual fix (requires user action)
	IsManualFix bool `json:"isManualFix"`
	// Manual steps if this cannot be automated
	ManualSteps []string `json:"manualSteps,omitempty"`
	// RouterOS command that will be executed
	Command *string `json:"command,omitempty"`
	// Rollback command if fix needs to be reverted
	RollbackCommand *string `json:"rollbackCommand,omitempty"`
}

// Complete troubleshooting session
type TroubleshootSession struct {
	// Unique session identifier
	ID string `json:"id"`
	// Router being diagnosed
	RouterID string `json:"routerId"`
	// All diagnostic steps
	Steps []*TroubleshootStep `json:"steps"`
	// Current step index (0-based)
	CurrentStepIndex int `json:"currentStepIndex"`
	// Overall session status
	Status TroubleshootSessionStatus `json:"status"`
	// Detected WAN interface name
	WanInterface *string `json:"wanInterface,omitempty"`
	// Detected default gateway IP
	Gateway *string `json:"gateway,omitempty"`
	// Detected ISP information
	IspInfo *ISPInfo `json:"ispInfo,omitempty"`
	// Fixes that have been applied
	AppliedFixes []string `json:"appliedFixes"`
	// When the session started
	StartedAt time.Time `json:"startedAt"`
	// When the session completed
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

// A single step in the troubleshooting wizard
type TroubleshootStep struct {
	// Step type/ID
	ID TroubleshootStepType `json:"id"`
	// Step display name
	Name string `json:"name"`
	// Step description
	Description string `json:"description"`
	// Current status of this step
	Status TroubleshootStepStatus `json:"status"`
	// Result of executing this step
	Result *TroubleshootStepResult `json:"result,omitempty"`
	// Suggested fix if step failed
	Fix *TroubleshootFixSuggestion `json:"fix,omitempty"`
	// When the step started
	StartedAt *time.Time `json:"startedAt,omitempty"`
	// When the step completed
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

// Result of a single diagnostic step
type TroubleshootStepResult struct {
	// Whether the check passed
	Success bool `json:"success"`
	// User-friendly message about the result
	Message string `json:"message"`
	// Technical details for debugging
	Details *string `json:"details,omitempty"`
	// Execution time in milliseconds
	ExecutionTimeMs int `json:"executionTimeMs"`
	// Detected error code
	IssueCode *string `json:"issueCode,omitempty"`
	// Target that was checked (IP, interface name, etc.)
	Target *string `json:"target,omitempty"`
}

// A network tunnel interface for connecting remote networks
type Tunnel struct {
	// Unique tunnel identifier
	ID string `json:"id"`
	// Tunnel interface name
	Name string `json:"name"`
	// Tunnel protocol type
	Type TunnelType `json:"type"`
	// Local endpoint IP address
	LocalAddress string `json:"localAddress"`
	// Remote endpoint IP address
	RemoteAddress string `json:"remoteAddress"`
	// Operational status of the tunnel
	Status InterfaceStatus `json:"status"`
	// MTU setting for the tunnel interface
	Mtu *int `json:"mtu,omitempty"`
	// IPsec profile name (GRE tunnels only)
	IpsecProfile *string `json:"ipsecProfile,omitempty"`
	// Tunnel ID (EoIP tunnels only, must be unique per remote address pair)
	TunnelID *int `json:"tunnelId,omitempty"`
	// VXLAN Network Identifier (VXLAN tunnels only)
	Vni *int `json:"vni,omitempty"`
	// VXLAN port (default 4789)
	Port *int `json:"port,omitempty"`
	// VTEP peer addresses (VXLAN tunnels only)
	VtepPeers []string `json:"vtepPeers,omitempty"`
	// Traffic statistics for this tunnel
	Statistics *InterfaceStats `json:"statistics,omitempty"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// Whether the tunnel is disabled
	Disabled *bool `json:"disabled,omitempty"`
}

func (Tunnel) IsNode() {}

// Input for creating or updating a tunnel
type TunnelInput struct {
	// Tunnel interface name (alphanumeric, hyphens, underscores)
	Name string `json:"name"`
	// Tunnel protocol type
	Type TunnelType `json:"type"`
	// Local endpoint IP address
	LocalAddress string `json:"localAddress"`
	// Remote endpoint IP address
	RemoteAddress string `json:"remoteAddress"`
	// MTU setting (optional, default calculated based on tunnel type)
	Mtu graphql.Omittable[*int] `json:"mtu,omitempty"`
	// IPsec profile name (GRE tunnels only)
	IpsecProfile graphql.Omittable[*string] `json:"ipsecProfile,omitempty"`
	// Tunnel ID (EoIP tunnels only, 0-65535)
	TunnelID graphql.Omittable[*int] `json:"tunnelId,omitempty"`
	// VXLAN Network Identifier (VXLAN tunnels only, 1-16777215)
	Vni graphql.Omittable[*int] `json:"vni,omitempty"`
	// VXLAN port (default 4789)
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// VTEP peer addresses (VXLAN tunnels only)
	VtepPeers graphql.Omittable[[]string] `json:"vtepPeers,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Result of a tunnel mutation (create, update)
type TunnelMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The created or updated tunnel (if successful)
	Tunnel *Tunnel `json:"tunnel,omitempty"`
	// Configuration preview (RouterOS commands)
	Preview *string `json:"preview,omitempty"`
	// MTU guidance for the tunnel type
	MtuGuidance *MtuGuidance `json:"mtuGuidance,omitempty"`
	// Errors that occurred during the operation
	Errors []string `json:"errors"`
}

// Result of a tunnel connectivity test
type TunnelTestResult struct {
	// Whether the remote endpoint is reachable
	Reachable bool `json:"reachable"`
	// Average ping latency in milliseconds (null if unreachable)
	Latency *float64 `json:"latency,omitempty"`
	// Throughput in Mbps (null if iperf not available)
	Throughput *float64 `json:"throughput,omitempty"`
	// Path MTU discovered (null if not tested)
	MtuPath *int `json:"mtuPath,omitempty"`
	// Suggestions for common connectivity issues
	Suggestions []string `json:"suggestions"`
}

// Input for updating an alert rule
type UpdateAlertRuleInput struct {
	// Human-readable alert rule name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Event type to match
	EventType graphql.Omittable[*string] `json:"eventType,omitempty"`
	// Array of conditions
	Conditions graphql.Omittable[[]*AlertConditionInput] `json:"conditions,omitempty"`
	// Alert severity level
	Severity graphql.Omittable[*AlertSeverity] `json:"severity,omitempty"`
	// Notification channels
	Channels graphql.Omittable[[]string] `json:"channels,omitempty"`
	// Throttle configuration
	Throttle graphql.Omittable[*ThrottleConfigInput] `json:"throttle,omitempty"`
	// Quiet hours configuration
	QuietHours graphql.Omittable[*QuietHoursConfigInput] `json:"quietHours,omitempty"`
	// Escalation configuration (NAS-18.9)
	Escalation graphql.Omittable[*EscalationConfigInput] `json:"escalation,omitempty"`
	// Optional device ID filter
	DeviceID graphql.Omittable[*string] `json:"deviceId,omitempty"`
	// Whether rule is enabled
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

type UpdateBridgeInput struct {
	Comment       graphql.Omittable[*string]      `json:"comment,omitempty"`
	Protocol      graphql.Omittable[*StpProtocol] `json:"protocol,omitempty"`
	Priority      graphql.Omittable[*int]         `json:"priority,omitempty"`
	VlanFiltering graphql.Omittable[*bool]        `json:"vlanFiltering,omitempty"`
	Pvid          graphql.Omittable[*int]         `json:"pvid,omitempty"`
	Mtu           graphql.Omittable[*int]         `json:"mtu,omitempty"`
	Disabled      graphql.Omittable[*bool]        `json:"disabled,omitempty"`
}

type UpdateBridgePortInput struct {
	Pvid             graphql.Omittable[*int]        `json:"pvid,omitempty"`
	FrameTypes       graphql.Omittable[*FrameTypes] `json:"frameTypes,omitempty"`
	IngressFiltering graphql.Omittable[*bool]       `json:"ingressFiltering,omitempty"`
	TaggedVlans      graphql.Omittable[[]int]       `json:"taggedVlans,omitempty"`
	UntaggedVlans    graphql.Omittable[[]int]       `json:"untaggedVlans,omitempty"`
	Edge             graphql.Omittable[*bool]       `json:"edge,omitempty"`
	PathCost         graphql.Omittable[*int]        `json:"pathCost,omitempty"`
}

// Input for updating an item in a change set
type UpdateChangeSetItemInput struct {
	// Updated name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Updated description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Updated configuration
	Configuration graphql.Omittable[map[string]any] `json:"configuration,omitempty"`
	// Updated dependencies
	Dependencies graphql.Omittable[[]string] `json:"dependencies,omitempty"`
}

type UpdateChangeSetItemPayload struct {
	// The updated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for configuring update check schedule for an instance.
type UpdateCheckScheduleInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Update check schedule (e.g., '6h', '12h', '24h', 'manual')
	CheckSchedule string `json:"checkSchedule"`
	// Minimum severity to auto-apply (CRITICAL, MAJOR, MINOR, PATCH, MANUAL)
	AutoApplyThreshold string `json:"autoApplyThreshold"`
}

// Available update information for a service instance.
type UpdateInfo struct {
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Feature ID
	FeatureID string `json:"featureID"`
	// Current installed version
	CurrentVersion string `json:"currentVersion"`
	// Available update version
	AvailableVersion string `json:"availableVersion"`
	// Update severity
	Severity UpdateSeverity `json:"severity"`
	// Release notes/changelog
	ReleaseNotes string `json:"releaseNotes"`
	// When the update was published
	PublishedAt time.Time `json:"publishedAt"`
	// Download URL for the new binary
	DownloadURL string `json:"downloadURL"`
	// Checksum URL for verification
	ChecksumURL *string `json:"checksumURL,omitempty"`
	// Binary size in bytes
	SizeBytes int `json:"sizeBytes"`
	// Target architecture
	Architecture string `json:"architecture"`
}

// Input for updating interface settings
type UpdateInterfaceInput struct {
	// Enable or disable the interface
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
	// MTU size (68-9000 bytes)
	Mtu graphql.Omittable[*int] `json:"mtu,omitempty"`
	// Interface comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Payload returned by updateInterface, enableInterface, and disableInterface mutations
type UpdateInterfacePayload struct {
	// Updated interface
	Interface *Interface `json:"interface,omitempty"`
	// Errors that occurred during the operation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating an existing notification channel configuration
type UpdateNotificationChannelConfigInput struct {
	// New name (optional)
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// New description (optional)
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Enable/disable configuration (optional)
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
	// Set as default (optional)
	IsDefault graphql.Omittable[*bool] `json:"isDefault,omitempty"`
	// New configuration (optional, replaces entire config if provided)
	Config graphql.Omittable[map[string]any] `json:"config,omitempty"`
}

// Input for updating an existing port mirror configuration
type UpdatePortMirrorInput struct {
	// Updated name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Updated source interface IDs (must be bridge members)
	SourceInterfaceIds graphql.Omittable[[]string] `json:"sourceInterfaceIds,omitempty"`
	// Updated destination interface ID
	DestinationInterfaceID graphql.Omittable[*string] `json:"destinationInterfaceId,omitempty"`
	// Updated direction of traffic to mirror
	Direction graphql.Omittable[*MirrorDirection] `json:"direction,omitempty"`
	// Updated comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Update progress during atomic update process.
type UpdateProgress struct {
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Feature ID
	FeatureID string `json:"featureID"`
	// Current version
	FromVersion string `json:"fromVersion"`
	// Target version
	ToVersion string `json:"toVersion"`
	// Current stage
	Stage UpdateStage `json:"stage"`
	// Progress percentage (0-100)
	Progress int `json:"progress"`
	// Current stage message
	Message string `json:"message"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// Input for updating resource configuration
type UpdateResourceInput struct {
	// Updated configuration (partial or full)
	Configuration graphql.Omittable[map[string]any] `json:"configuration,omitempty"`
	// Updated relationships
	Relationships graphql.Omittable[*ResourceRelationshipsInput] `json:"relationships,omitempty"`
	// Updated tags
	Tags graphql.Omittable[[]string] `json:"tags,omitempty"`
	// Updated description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
}

type UpdateResourcePayload struct {
	// The updated resource
	Resource Resource `json:"resource,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Update result after completion or failure.
type UpdateResult struct {
	// Whether the update succeeded
	Success bool `json:"success"`
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Version updated to (if successful)
	Version *string `json:"version,omitempty"`
	// Error message (if failed)
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Whether rollback occurred
	RolledBack bool `json:"rolledBack"`
	// Total duration in milliseconds
	DurationMs int `json:"durationMs"`
	// Update stages completed
	CompletedStages []UpdateStage `json:"completedStages"`
	// Stage where failure occurred (if failed)
	FailedStage *UpdateStage `json:"failedStage,omitempty"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// Input for updating router settings
type UpdateRouterInput struct {
	// Updated display name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Updated hostname or IP address
	Host graphql.Omittable[*string] `json:"host,omitempty"`
	// Updated connection port
	Port graphql.Omittable[*int] `json:"port,omitempty"`
	// Updated username
	Username graphql.Omittable[*string] `json:"username,omitempty"`
	// Updated password
	Password graphql.Omittable[*string] `json:"password,omitempty"`
}

type UpdateRouterPayload struct {
	// The updated router
	Router *Router `json:"router,omitempty"`
	// Errors that occurred during update
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for updating an existing routing schedule.
type UpdateScheduleInput struct {
	// Days of week (0=Sunday, 6=Saturday)
	Days graphql.Omittable[[]int] `json:"days,omitempty"`
	// Start time in HH:MM format (24-hour)
	StartTime graphql.Omittable[*string] `json:"startTime,omitempty"`
	// End time in HH:MM format (24-hour)
	EndTime graphql.Omittable[*string] `json:"endTime,omitempty"`
	// IANA timezone identifier
	Timezone graphql.Omittable[*string] `json:"timezone,omitempty"`
	// Whether schedule is enabled
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

// Input for updating a webhook
type UpdateWebhookInput struct {
	// Human-readable webhook name
	Name graphql.Omittable[*string] `json:"name,omitempty"`
	// Optional description
	Description graphql.Omittable[*string] `json:"description,omitempty"`
	// Webhook URL endpoint
	URL graphql.Omittable[*string] `json:"url,omitempty"`
	// HTTP method
	Method graphql.Omittable[*string] `json:"method,omitempty"`
	// Authentication type
	AuthType graphql.Omittable[*WebhookAuthType] `json:"authType,omitempty"`
	// Username for Basic auth
	Username graphql.Omittable[*string] `json:"username,omitempty"`
	// Password for Basic auth (only set if provided)
	Password graphql.Omittable[*string] `json:"password,omitempty"`
	// Bearer token for Bearer auth (only set if provided)
	BearerToken graphql.Omittable[*string] `json:"bearerToken,omitempty"`
	// Custom HTTP headers (as JSON object)
	Headers graphql.Omittable[map[string]any] `json:"headers,omitempty"`
	// Template type for webhook payload
	Template graphql.Omittable[*WebhookTemplate] `json:"template,omitempty"`
	// Custom template body
	CustomTemplate graphql.Omittable[*string] `json:"customTemplate,omitempty"`
	// Signing secret for HMAC signature (only set if provided)
	SigningSecret graphql.Omittable[*string] `json:"signingSecret,omitempty"`
	// Timeout in seconds
	TimeoutSeconds graphql.Omittable[*int] `json:"timeoutSeconds,omitempty"`
	// Whether to retry failed deliveries
	RetryEnabled graphql.Omittable[*bool] `json:"retryEnabled,omitempty"`
	// Maximum retry attempts
	MaxRetries graphql.Omittable[*int] `json:"maxRetries,omitempty"`
	// Whether webhook is enabled
	Enabled graphql.Omittable[*bool] `json:"enabled,omitempty"`
}

// Impact assessment for an upgrade
type UpgradeImpact struct {
	// Whether reboot is required
	RequiresReboot bool `json:"requiresReboot"`
	// Estimated downtime description
	EstimatedDowntime *string `json:"estimatedDowntime,omitempty"`
	// Whether configuration backup is recommended before upgrade
	BackupRecommended bool `json:"backupRecommended"`
	// Potential breaking changes to be aware of
	BreakingChanges []string `json:"breakingChanges"`
}

// Upgrade recommendation for enabling a feature
type UpgradeRecommendation struct {
	// Feature that requires upgrade
	FeatureID string `json:"featureId"`
	// Human-readable feature name
	FeatureName string `json:"featureName"`
	// Current RouterOS version
	CurrentVersion string `json:"currentVersion"`
	// Minimum required version for this feature
	RequiredVersion string `json:"requiredVersion"`
	// Whether this is a major version upgrade (e.g., 6.x to 7.x)
	IsMajorUpgrade bool `json:"isMajorUpgrade"`
	// Priority level (critical, high, medium, low)
	Priority UpgradePriority `json:"priority"`
	// Steps to complete the upgrade
	Steps []*UpgradeStep `json:"steps"`
	// Estimated impact on router operation
	Impact *UpgradeImpact `json:"impact"`
	// URL to MikroTik upgrade documentation
	DocumentationURL *string `json:"documentationUrl,omitempty"`
	// Warnings or important notes about this upgrade
	Warnings []string `json:"warnings"`
}

// Single step in an upgrade process
type UpgradeStep struct {
	// Step number (1-based)
	Step int `json:"step"`
	// Step title
	Title string `json:"title"`
	// Detailed instructions
	Description string `json:"description"`
	// RouterOS command to execute (if applicable)
	Command *string `json:"command,omitempty"`
	// Whether this step is optional
	Optional bool `json:"optional"`
}

// An uptime data point
type UptimeDataPoint struct {
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
	// Whether resource was up during this period
	IsUp bool `json:"isUp"`
	// Period duration in seconds
	PeriodSeconds int `json:"periodSeconds"`
}

// Single step in VIF enablement guidance
type VIFGuidanceStep struct {
	// Step number (1-based)
	Step int `json:"step"`
	// Short title for the step
	Title string `json:"title"`
	// Detailed instruction
	Description string `json:"description"`
	// Whether this requirement is already met
	Completed bool `json:"completed"`
	// RouterOS command to execute (if applicable)
	RouterCommand *string `json:"routerCommand,omitempty"`
}

// VIF (Virtual Interface Factory) requirements check result
type VIFRequirements struct {
	// Whether all VIF requirements are satisfied
	Met bool `json:"met"`
	// Whether RouterOS version is sufficient (7.13+)
	RouterOSVersion bool `json:"routerOSVersion"`
	// Whether container package is installed
	ContainerPackage bool `json:"containerPackage"`
	// Whether container feature is enabled
	ContainerEnabled bool `json:"containerEnabled"`
	// Whether there's sufficient storage (>100MB)
	SufficientStorage bool `json:"sufficientStorage"`
	// Whether network namespace is supported
	NetworkNamespace bool `json:"networkNamespace"`
	// Human-readable reasons why VIF is not available
	MissingReasons []string `json:"missingReasons"`
	// Step-by-step guidance for enabling VIF
	GuidanceSteps []*VIFGuidanceStep `json:"guidanceSteps"`
}

// VLANAllocation represents an automatic VLAN allocation for a service instance.
//
// Each allocation reserves a VLAN ID from the pool and generates a corresponding
// subnet (e.g., 10.8.100.0/24) for network isolation. Allocations are automatically
// created when service instances are provisioned and released when deleted.
//
// The system prevents conflicts with existing router VLANs through automatic
// detection via VlanService composition.
type VLANAllocation struct {
	// Unique allocation ID (ULID)
	ID string `json:"id"`
	// Router ID this VLAN allocation belongs to
	RouterID string `json:"routerID"`
	// VLAN ID (IEEE 802.1Q range: 1-4094)
	VlanID int `json:"vlanID"`
	// Service instance ID that owns this VLAN
	InstanceID string `json:"instanceID"`
	// Service type (e.g., 'tor', 'xray', 'singbox')
	ServiceType string `json:"serviceType"`
	// Auto-generated subnet for this VLAN (e.g., '10.99.100.0/24')
	Subnet *string `json:"subnet,omitempty"`
	// Allocation lifecycle status
	Status VLANAllocationStatus `json:"status"`
	// Timestamp when VLAN was allocated
	AllocatedAt time.Time `json:"allocatedAt"`
	// Timestamp when VLAN was released (null if still allocated)
	ReleasedAt *time.Time `json:"releasedAt,omitempty"`
	// Router this VLAN belongs to
	Router *Router `json:"router"`
	// Service instance that owns this VLAN
	ServiceInstance *ServiceInstance `json:"serviceInstance"`
}

func (VLANAllocation) IsNode() {}

// VLANPoolStatus represents the current state of the VLAN pool for a router.
//
// Provides utilization metrics and warnings when the pool is approaching exhaustion.
// Useful for capacity planning and monitoring.
type VLANPoolStatus struct {
	// Router ID this pool status applies to
	RouterID string `json:"routerID"`
	// Total number of VLANs in the pool (e.g., 100 for range 100-199)
	TotalVLANs int `json:"totalVLANs"`
	// Number of currently allocated VLANs
	AllocatedVLANs int `json:"allocatedVLANs"`
	// Number of available VLANs remaining
	AvailableVLANs int `json:"availableVLANs"`
	// Utilization percentage (0.0 - 100.0)
	Utilization float64 `json:"utilization"`
	// Warning flag if utilization > 80%
	ShouldWarn bool `json:"shouldWarn"`
	// Pool configuration (start VLAN ID)
	PoolStart int `json:"poolStart"`
	// Pool configuration (end VLAN ID)
	PoolEnd int `json:"poolEnd"`
}

// VPN tunnel information for routes through VPN
type VPNTunnelInfo struct {
	// Tunnel name
	Name string `json:"name"`
	// Tunnel type (wireguard, ipsec, ovpn, l2tp, gre, eoip)
	Type string `json:"type"`
	// Current tunnel connection status
	Status TunnelStatus `json:"status"`
	// Remote endpoint address
	RemoteAddress *string `json:"remoteAddress,omitempty"`
}

// VXLAN Tunnel resource implementing 8-layer model
type VXLANTunnel struct {
	ID              string                 `json:"id"`
	ScopedID        string                 `json:"scopedId"`
	Type            string                 `json:"type"`
	Category        ResourceCategory       `json:"category"`
	Configuration   map[string]any         `json:"configuration,omitempty"`
	Validation      *ValidationResult      `json:"validation,omitempty"`
	Deployment      *DeploymentState       `json:"deployment,omitempty"`
	Runtime         *RuntimeState          `json:"runtime,omitempty"`
	Telemetry       *TelemetryData         `json:"telemetry,omitempty"`
	Metadata        *ResourceMetadata      `json:"metadata"`
	Relationships   *ResourceRelationships `json:"relationships,omitempty"`
	Platform        *PlatformInfo          `json:"platform,omitempty"`
	Config          *VXLANTunnelConfig     `json:"config"`
	VxlanDeployment *VXLANTunnelDeployment `json:"vxlanDeployment,omitempty"`
	VxlanRuntime    *VXLANTunnelRuntime    `json:"vxlanRuntime,omitempty"`
}

func (VXLANTunnel) IsResource() {}

func (VXLANTunnel) IsNode() {}

// VXLAN tunnel configuration
type VXLANTunnelConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// VXLAN Network Identifier (VNI)
	Vni int `json:"vni"`
	// VXLAN UDP port
	Port Port `json:"port"`
	// Remote VXLAN endpoint
	RemoteAddress IPv4 `json:"remoteAddress"`
	// Local source address
	LocalAddress *IPv4 `json:"localAddress,omitempty"`
	// Optional comment/description
	Comment *string `json:"comment,omitempty"`
	// Enable tunnel
	Enabled *bool `json:"enabled,omitempty"`
}

// VXLAN tunnel deployment state
type VXLANTunnelDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// VXLAN tunnel runtime state
type VXLANTunnelRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether tunnel is up
	IsUp bool `json:"isUp"`
	// MTU of tunnel
	Mtu *int `json:"mtu,omitempty"`
	// Current remote endpoint
	CurrentRemote *IPv4 `json:"currentRemote,omitempty"`
	// Bytes transmitted through tunnel
	BytesSent Size `json:"bytesSent"`
	// Bytes received through tunnel
	BytesReceived Size `json:"bytesReceived"`
	// Learning enabled
	LearningEnabled *bool `json:"learningEnabled,omitempty"`
}

type ValidateChangeSetPayload struct {
	// The validated change set
	ChangeSet *ChangeSet `json:"changeSet,omitempty"`
	// Validation result
	Validation *ChangeSetValidationResult `json:"validation,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Payload for provisioning session validation
type ValidateProvisioningSessionPayload struct {
	// The provisioning session
	Session *ProvisioningSession `json:"session"`
	// Validation results for each resource
	ValidationResults []*ResourceValidationResult `json:"validationResults"`
	// Overall validation passed
	IsValid bool `json:"isValid"`
	// Mutation errors
	Errors []*MutationError `json:"errors,omitempty"`
}

type ValidateResourcePayload struct {
	// The validated resource
	Resource Resource `json:"resource,omitempty"`
	// Validation result
	Validation *ValidationResult `json:"validation,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Input for validating service configuration
type ValidateServiceConfigInput struct {
	// Router ID
	RouterID string `json:"routerID"`
	// Service instance ID
	InstanceID string `json:"instanceID"`
	// Configuration to validate (as JSON)
	Config map[string]any `json:"config"`
}

// Field-level validation error with suggestions for fixing.
type ValidationError struct {
	// Field path that failed validation (e.g., 'input.host', 'input.port')
	Field string `json:"field"`
	// Error code for the validation failure
	Code string `json:"code"`
	// Human-readable error message
	Message string `json:"message"`
	// Suggestion for fixing the validation error
	Suggestion *string `json:"suggestion,omitempty"`
	// The invalid value (redacted for sensitive fields)
	ProvidedValue *string `json:"providedValue,omitempty"`
}

// A validation issue (error or warning)
type ValidationIssue struct {
	// Error code for programmatic handling
	Code string `json:"code"`
	// Human-readable message
	Message string `json:"message"`
	// Field path that caused the issue (e.g., 'configuration.listenPort')
	Field *string `json:"field,omitempty"`
	// Severity level
	Severity ValidationSeverity `json:"severity"`
	// Suggested fix
	SuggestedFix *string `json:"suggestedFix,omitempty"`
	// Link to documentation
	DocsURL *string `json:"docsUrl,omitempty"`
}

// Layer 2: Validation result from 7-stage backend validation pipeline.
// Computed on every configuration change.
type ValidationResult struct {
	// Whether the resource can be applied
	CanApply bool `json:"canApply"`
	// Current validation stage
	Stage ValidationStage `json:"stage"`
	// Validation errors (blocking)
	Errors []*ValidationIssue `json:"errors"`
	// Validation warnings (non-blocking)
	Warnings []*ValidationIssue `json:"warnings"`
	// Resource conflicts detected
	Conflicts []*ResourceConflict `json:"conflicts"`
	// Required dependencies that must be active
	RequiredDependencies []*DependencyStatus `json:"requiredDependencies"`
	// When validation was performed
	ValidatedAt time.Time `json:"validatedAt"`
	// Duration of validation in milliseconds
	ValidationDurationMs int `json:"validationDurationMs"`
}

// Verification event for subscriptions.
type VerificationEvent struct {
	// Instance ID
	InstanceID string `json:"instanceID"`
	// Feature ID
	FeatureID string `json:"featureID"`
	// Router ID
	RouterID string `json:"routerID"`
	// Event type (verified, verification_failed, integrity_failed)
	EventType string `json:"eventType"`
	// Archive hash
	ArchiveHash *string `json:"archiveHash,omitempty"`
	// Binary hash
	BinaryHash *string `json:"binaryHash,omitempty"`
	// Expected hash (for failures)
	ExpectedHash *string `json:"expectedHash,omitempty"`
	// Actual hash (for failures)
	ActualHash *string `json:"actualHash,omitempty"`
	// GPG verified
	GpgVerified bool `json:"gpgVerified"`
	// GPG key ID
	GpgKeyID *string `json:"gpgKeyID,omitempty"`
	// Failure reason (for failures)
	FailureReason *string `json:"failureReason,omitempty"`
	// Suggested action (for failures)
	SuggestedAction *string `json:"suggestedAction,omitempty"`
	// Timestamp
	Timestamp time.Time `json:"timestamp"`
}

// Virtual network interface for service instance isolation.
// Each service instance gets its own VLAN interface with routing mark.
type VirtualInterface struct {
	// Interface ID (ULID)
	ID string `json:"id"`
	// Service instance ID this interface belongs to
	InstanceID string `json:"instanceId"`
	// Interface name (e.g., vlan100)
	Name string `json:"name"`
	// VLAN ID for network isolation
	VlanID int `json:"vlanId"`
	// IP address assigned to this interface
	IPAddress string `json:"ipAddress"`
	// Gateway type (tunnel, direct, etc.)
	GatewayType GatewayType `json:"gatewayType"`
	// Gateway runtime status
	GatewayStatus GatewayStatus `json:"gatewayStatus"`
	// Tunnel interface name (for HEV tunnel)
	TunName *string `json:"tunName,omitempty"`
	// Routing mark for policy routing
	RoutingMark string `json:"routingMark"`
	// Interface lifecycle status
	Status VirtualInterfaceStatus `json:"status"`
	// When the interface was created
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
}

// Virtual interface information for routing matrix.
// Simplified view of VirtualInterface for device routing selection.
type VirtualInterfaceInfo struct {
	// Interface ID
	ID string `json:"id"`
	// Service instance ID
	InstanceID string `json:"instanceID"`
	// Service instance name
	InstanceName string `json:"instanceName"`
	// Interface name (e.g., vlan100)
	InterfaceName string `json:"interfaceName"`
	// VLAN ID
	VlanID int `json:"vlanID"`
	// IP address
	IPAddress string `json:"ipAddress"`
	// Routing mark for PBR
	RoutingMark string `json:"routingMark"`
	// Interface status
	Status string `json:"status"`
	// Gateway type
	GatewayType string `json:"gatewayType"`
	// Gateway status
	GatewayStatus string `json:"gatewayStatus"`
}

// A VLAN (Virtual LAN) interface for network segmentation using 802.1Q tagging
type Vlan struct {
	// Unique VLAN identifier
	ID string `json:"id"`
	// VLAN interface name (e.g., vlan10, vlan-guest)
	Name string `json:"name"`
	// 802.1Q VLAN ID (1-4094)
	VlanID int `json:"vlanId"`
	// Parent interface (bridge or physical interface)
	Interface *Interface `json:"interface"`
	// MTU setting (optional, inherits from parent if not set)
	Mtu *int `json:"mtu,omitempty"`
	// MAC address of the VLAN interface
	MacAddress *MAC `json:"macAddress,omitempty"`
	// Whether the VLAN interface is disabled
	Disabled bool `json:"disabled"`
	// Whether the VLAN interface is running (link up)
	Running bool `json:"running"`
	// User comment
	Comment *string `json:"comment,omitempty"`
	// IP addresses assigned to this VLAN
	IPAddresses []*IPAddress `json:"ipAddresses"`
	// Traffic statistics for this VLAN
	Statistics *InterfaceStats `json:"statistics,omitempty"`
}

func (Vlan) IsNode() {}

// Resources that depend on a VLAN interface
type VlanDependencies struct {
	// VLAN interface ID
	VlanID string `json:"vlanId"`
	// IP addresses assigned to this VLAN
	IPAddresses []*IPAddress `json:"ipAddresses"`
	// DHCP servers using this VLAN
	DhcpServers []*DhcpServer `json:"dhcpServers"`
	// Firewall rules referencing this VLAN
	FirewallRules []*FirewallRuleReference `json:"firewallRules"`
	// Routes using this VLAN interface
	Routes []*Route `json:"routes"`
	// Number of active connections on this VLAN
	ActiveConnections int `json:"activeConnections"`
	// Whether the VLAN has any dependencies
	HasDependencies bool `json:"hasDependencies"`
}

// Filter options for querying VLANs
type VlanFilter struct {
	// Filter by parent interface ID
	ParentInterface graphql.Omittable[*string] `json:"parentInterface,omitempty"`
	// Filter by VLAN ID range
	VlanIDRange graphql.Omittable[*IntRange] `json:"vlanIdRange,omitempty"`
	// Filter by name containing this string
	NameContains graphql.Omittable[*string] `json:"nameContains,omitempty"`
}

// Input for creating a new VLAN interface
type VlanInput struct {
	// VLAN interface name (alphanumeric, hyphens, underscores)
	Name string `json:"name"`
	// 802.1Q VLAN ID (1-4094)
	VlanID int `json:"vlanId"`
	// Parent interface ID (bridge or physical interface)
	Interface string `json:"interface"`
	// MTU setting (optional, inherits from parent if not set)
	Mtu graphql.Omittable[*int] `json:"mtu,omitempty"`
	// User comment
	Comment graphql.Omittable[*string] `json:"comment,omitempty"`
}

// Result of a VLAN mutation (create, update)
type VlanMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The created or updated VLAN (if successful)
	Vlan *Vlan `json:"vlan,omitempty"`
	// Configuration preview (RouterOS commands that will be executed)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Errors that occurred during the operation
	Errors []*MutationError `json:"errors,omitempty"`
}

// VLAN topology data (nodes and edges)
type VlanTopology struct {
	// Topology nodes (bridges, VLANs, ports)
	Nodes []*TopologyNode `json:"nodes"`
	// Topology edges (connections)
	Edges []*TopologyEdge `json:"edges"`
}

// WAN connection history entry
type WANConnectionEvent struct {
	// Event ID
	ID string `json:"id"`
	// WAN interface ID
	WanInterfaceID string `json:"wanInterfaceId"`
	// Event type
	EventType WANEventType `json:"eventType"`
	// Event timestamp
	Timestamp time.Time `json:"timestamp"`
	// Public IP at the time (if applicable)
	PublicIP *IPv4 `json:"publicIP,omitempty"`
	// Gateway IP
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Reason/error message (if applicable)
	Reason *string `json:"reason,omitempty"`
	// Connection duration (for disconnect events)
	Duration *Duration `json:"duration,omitempty"`
}

// Connection history pagination
type WANConnectionEventConnection struct {
	Edges      []*WANConnectionEventEdge `json:"edges"`
	PageInfo   *PageInfo                 `json:"pageInfo"`
	TotalCount *int                      `json:"totalCount,omitempty"`
}

func (WANConnectionEventConnection) IsConnection() {}

type WANConnectionEventEdge struct {
	Node   *WANConnectionEvent `json:"node"`
	Cursor string              `json:"cursor"`
}

func (WANConnectionEventEdge) IsEdge() {}

// DNS configuration for WAN link
type WANDNSConfig struct {
	// Use DHCP-provided DNS
	UseDhcpDNS *bool `json:"useDhcpDns,omitempty"`
	// Static DNS servers
	DNSServers []IPv4 `json:"dnsServers,omitempty"`
	// DNS over HTTPS (DoH) URL
	DohURL *string `json:"dohUrl,omitempty"`
	// Enable DNS caching
	EnableCaching *bool `json:"enableCaching,omitempty"`
}

// Input for configuring WAN health check
type WANHealthCheckInput struct {
	// Target host to ping (IP or hostname)
	Target string `json:"target"`
	// Check interval in seconds
	Interval int `json:"interval"`
	// Enable health check
	Enabled bool `json:"enabled"`
}

// WAN health check status
type WANHealthStatus struct {
	// Overall health status
	Status HealthCheckStatus `json:"status"`
	// Target host being monitored
	Target string `json:"target"`
	// Check interval
	Interval Duration `json:"interval"`
	// Current latency (if reachable)
	Latency *int `json:"latency,omitempty"`
	// Packet loss percentage (0-100)
	PacketLoss int `json:"packetLoss"`
	// Consecutive successful checks
	SuccessCount int `json:"successCount"`
	// Consecutive failed checks
	FailureCount int `json:"failureCount"`
	// Last check timestamp
	LastCheck time.Time `json:"lastCheck"`
	// Whether health check is enabled
	Enabled bool `json:"enabled"`
}

// WAN interface status with connection details
type WANInterface struct {
	// Unique identifier
	ID string `json:"id"`
	// Underlying network interface
	Interface *Interface `json:"interface"`
	// WAN connection type
	Type WANConnectionType `json:"type"`
	// Current connection status
	Status WANStatus `json:"status"`
	// Public IP address (if connected)
	PublicIP *IPv4 `json:"publicIP,omitempty"`
	// Gateway IP address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Primary DNS server
	PrimaryDNS *IPv4 `json:"primaryDNS,omitempty"`
	// Secondary DNS server
	SecondaryDNS *IPv4 `json:"secondaryDNS,omitempty"`
	// Connection uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Last connection time
	LastConnected *time.Time `json:"lastConnected,omitempty"`
	// Health check status
	Health *WANHealthStatus `json:"health,omitempty"`
	// DHCP client configuration (if type is DHCP)
	DhcpClient *DhcpClient `json:"dhcpClient,omitempty"`
	// PPPoE client configuration (if type is PPPOE)
	PppoeClient *PppoeClient `json:"pppoeClient,omitempty"`
	// Static IP configuration (if type is STATIC)
	StaticConfig *StaticIPConfig `json:"staticConfig,omitempty"`
	// LTE modem configuration (if type is LTE)
	LteModem *LteModem `json:"lteModem,omitempty"`
	// Whether this is the default route
	IsDefaultRoute bool `json:"isDefaultRoute"`
	// Traffic statistics
	Statistics *InterfaceStats `json:"statistics,omitempty"`
}

func (WANInterface) IsNode() {}

// WAN Link resource for internet connectivity
type WANLink struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]any         `json:"configuration,omitempty"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	WanRuntime    *WANLinkRuntime        `json:"wanRuntime,omitempty"`
	// Interface name
	Interface string `json:"interface"`
	// Connection type (static, dhcp, pppoe)
	ConnectionType WANConnectionType `json:"connectionType"`
	// Whether this is the primary WAN
	IsPrimary bool `json:"isPrimary"`
	// Failover priority (lower = higher priority)
	FailoverPriority *int `json:"failoverPriority,omitempty"`
}

func (WANLink) IsResource() {}

func (WANLink) IsNode() {}

// WAN link configuration
type WANLinkConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// Link type (DOMESTIC or FOREIGN)
	LinkType WANLinkTypeEnum `json:"linkType"`
	// Connection type (DHCP, Static, PPPoE, LTE, None)
	ConnectionType WANConnectionType `json:"connectionType"`
	// Connection-specific configuration (DHCP, PPPoE, Static, LTE)
	ConnectionConfig map[string]any `json:"connectionConfig"`
	// DNS configuration
	DNSConfig *WANDNSConfig `json:"dnsConfig,omitempty"`
	// Physical interface name
	Interface string `json:"interface"`
	// Link priority for multi-link setup (lower = higher priority)
	Priority *int `json:"priority,omitempty"`
	// Link weight for load balancing (in multi-link scenarios)
	Weight *int `json:"weight,omitempty"`
	// Enable link
	Enabled bool `json:"enabled"`
	// Optional comment/description
	Comment *string `json:"comment,omitempty"`
}

// WAN link deployment state
type WANLinkDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Current connection status
	ConnectionStatus *WANStatus `json:"connectionStatus,omitempty"`
	// Current IP address assigned
	CurrentIP *IPv4 `json:"currentIP,omitempty"`
	// Current gateway
	CurrentGateway *IPv4 `json:"currentGateway,omitempty"`
	// DHCP lease expiration (if DHCP)
	LeaseExpiry *time.Time `json:"leaseExpiry,omitempty"`
}

// WAN Link resource implementing 8-layer model
// Extends basic WAN configuration with provisioning context
type WANLinkResource struct {
	ID            string                 `json:"id"`
	ScopedID      string                 `json:"scopedId"`
	Type          string                 `json:"type"`
	Category      ResourceCategory       `json:"category"`
	Configuration map[string]any         `json:"configuration,omitempty"`
	Validation    *ValidationResult      `json:"validation,omitempty"`
	Deployment    *DeploymentState       `json:"deployment,omitempty"`
	Runtime       *RuntimeState          `json:"runtime,omitempty"`
	Telemetry     *TelemetryData         `json:"telemetry,omitempty"`
	Metadata      *ResourceMetadata      `json:"metadata"`
	Relationships *ResourceRelationships `json:"relationships,omitempty"`
	Platform      *PlatformInfo          `json:"platform,omitempty"`
	Config        *WANLinkConfig         `json:"config"`
	WanDeployment *WANLinkDeployment     `json:"wanDeployment,omitempty"`
	WanRuntime    *WANLinkRuntime        `json:"wanRuntime,omitempty"`
}

func (WANLinkResource) IsResource() {}

func (WANLinkResource) IsNode() {}

// WAN Link runtime state
type WANLinkRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Current IP address
	CurrentIP *IPv4 `json:"currentIP,omitempty"`
	// Gateway address
	Gateway *IPv4 `json:"gateway,omitempty"`
	// Public IP (may differ due to NAT)
	PublicIP *IPv4 `json:"publicIP,omitempty"`
	// DNS servers received
	DNSServers []IPv4 `json:"dnsServers,omitempty"`
	// Current uplink speed (bytes/sec)
	UplinkSpeed *Size `json:"uplinkSpeed,omitempty"`
	// Current downlink speed (bytes/sec)
	DownlinkSpeed *Size `json:"downlinkSpeed,omitempty"`
	// Total uptime
	Uptime *Duration `json:"uptime,omitempty"`
	// Last connection change
	LastStateChange *time.Time `json:"lastStateChange,omitempty"`
}

// Result of WAN configuration mutation
type WANMutationResult struct {
	// Whether the operation succeeded
	Success bool `json:"success"`
	// The configured WAN interface
	WanInterface *WANInterface `json:"wanInterface,omitempty"`
	// Configuration preview (RouterOS commands)
	Preview *ConfigPreview `json:"preview,omitempty"`
	// Errors that occurred
	Errors []*MutationError `json:"errors,omitempty"`
}

// Webhook notification configuration
type Webhook struct {
	// Globally unique identifier
	ID string `json:"id"`
	// Human-readable webhook name
	Name string `json:"name"`
	// Optional description
	Description *string `json:"description,omitempty"`
	// Webhook URL endpoint
	URL string `json:"url"`
	// HTTP method (default: POST)
	Method string `json:"method"`
	// Authentication type
	AuthType WebhookAuthType `json:"authType"`
	// Username for Basic auth
	Username *string `json:"username,omitempty"`
	// Bearer token (masked, only shown on creation)
	BearerToken *string `json:"bearerToken,omitempty"`
	// Custom HTTP headers (as JSON object)
	Headers map[string]any `json:"headers,omitempty"`
	// Template type for webhook payload
	Template WebhookTemplate `json:"template"`
	// Custom template body (for CUSTOM template type)
	CustomTemplate *string `json:"customTemplate,omitempty"`
	// Signing secret (masked with ******, never returned in plaintext except on creation)
	SigningSecretMasked *string `json:"signingSecretMasked,omitempty"`
	// Timeout in seconds (default: 10)
	TimeoutSeconds int `json:"timeoutSeconds"`
	// Whether to retry failed deliveries
	RetryEnabled bool `json:"retryEnabled"`
	// Maximum retry attempts (default: 3)
	MaxRetries int `json:"maxRetries"`
	// Whether this webhook is enabled
	Enabled bool `json:"enabled"`
	// Record creation timestamp
	CreatedAt time.Time `json:"createdAt"`
	// Last update timestamp
	UpdatedAt time.Time `json:"updatedAt"`
	// Last successful delivery timestamp
	LastDeliveredAt *time.Time `json:"lastDeliveredAt,omitempty"`
	// Delivery statistics
	DeliveryStats *WebhookDeliveryStats `json:"deliveryStats,omitempty"`
}

func (Webhook) IsNode() {}

// Webhook delivery statistics
type WebhookDeliveryStats struct {
	// Total deliveries attempted
	TotalAttempts int `json:"totalAttempts"`
	// Successful deliveries
	SuccessCount int `json:"successCount"`
	// Failed deliveries
	FailureCount int `json:"failureCount"`
	// Success rate (0-100)
	SuccessRate float64 `json:"successRate"`
	// Average response time in milliseconds
	AvgResponseTimeMs *int `json:"avgResponseTimeMs,omitempty"`
}

// Webhook mutation payload
type WebhookPayload struct {
	// Created/updated webhook
	Webhook *Webhook `json:"webhook,omitempty"`
	// Signing secret (only returned on creation, one-time show)
	SigningSecret *string `json:"signingSecret,omitempty"`
	// Errors encountered during mutation
	Errors []*MutationError `json:"errors,omitempty"`
}

// Webhook test mutation payload
type WebhookTestPayload struct {
	// Test result
	Result *WebhookTestResult `json:"result,omitempty"`
	// Errors encountered during test
	Errors []*MutationError `json:"errors,omitempty"`
}

// Result of testing a webhook
type WebhookTestResult struct {
	// Whether the test was successful
	Success bool `json:"success"`
	// HTTP status code received
	StatusCode *int `json:"statusCode,omitempty"`
	// Response body from webhook endpoint
	ResponseBody *string `json:"responseBody,omitempty"`
	// Response time in milliseconds
	ResponseTimeMs *int `json:"responseTimeMs,omitempty"`
	// Error message if test failed
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// WireGuard VPN Client resource implementing 8-layer model
type WireGuardClient struct {
	ID                  string                 `json:"id"`
	ScopedID            string                 `json:"scopedId"`
	Type                string                 `json:"type"`
	Category            ResourceCategory       `json:"category"`
	Configuration       map[string]any         `json:"configuration,omitempty"`
	Validation          *ValidationResult      `json:"validation,omitempty"`
	Deployment          *DeploymentState       `json:"deployment,omitempty"`
	Runtime             *RuntimeState          `json:"runtime,omitempty"`
	Telemetry           *TelemetryData         `json:"telemetry,omitempty"`
	Metadata            *ResourceMetadata      `json:"metadata"`
	Relationships       *ResourceRelationships `json:"relationships,omitempty"`
	Platform            *PlatformInfo          `json:"platform,omitempty"`
	Config              *WireGuardClientConfig `json:"config"`
	WireguardDeployment *WireGuardDeployment   `json:"wireguardDeployment,omitempty"`
	WireguardRuntime    *WireGuardRuntime      `json:"wireguardRuntime,omitempty"`
}

func (WireGuardClient) IsResource() {}

func (WireGuardClient) IsNode() {}

// WireGuard client configuration
type WireGuardClientConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// WireGuard private key
	PrivateKey string `json:"privateKey"`
	// Peer public key
	PeerPublicKey string `json:"peerPublicKey"`
	// Peer endpoint (IP:port)
	PeerEndpoint string `json:"peerEndpoint"`
	// Allowed IPs (CIDR notation)
	AllowedIPs []CIDR `json:"allowedIPs"`
	// Persistent keepalive interval
	PersistentKeepalive *Duration `json:"persistentKeepalive,omitempty"`
	// Listen port (0 for auto)
	ListenPort *Port `json:"listenPort,omitempty"`
	// WAN interface to use
	WanInterface *string `json:"wanInterface,omitempty"`
	// Enable kill switch
	KillSwitch *bool `json:"killSwitch,omitempty"`
	// DNS servers to use
	DNSServers []IPv4 `json:"dnsServers,omitempty"`
}

// WireGuard deployment state (router-generated)
type WireGuardDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Generated public key
	PublicKey *string `json:"publicKey,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// WireGuard Peer resource implementing 8-layer model
type WireGuardPeer struct {
	ID               string                   `json:"id"`
	ScopedID         string                   `json:"scopedId"`
	Type             string                   `json:"type"`
	Category         ResourceCategory         `json:"category"`
	Configuration    map[string]any           `json:"configuration,omitempty"`
	Validation       *ValidationResult        `json:"validation,omitempty"`
	Deployment       *DeploymentState         `json:"deployment,omitempty"`
	Runtime          *RuntimeState            `json:"runtime,omitempty"`
	Telemetry        *TelemetryData           `json:"telemetry,omitempty"`
	Metadata         *ResourceMetadata        `json:"metadata"`
	Relationships    *ResourceRelationships   `json:"relationships,omitempty"`
	Platform         *PlatformInfo            `json:"platform,omitempty"`
	Config           *WireGuardPeerConfig     `json:"config"`
	WgPeerDeployment *WireGuardPeerDeployment `json:"wgPeerDeployment,omitempty"`
	WgPeerRuntime    *WireGuardPeerRuntime    `json:"wgPeerRuntime,omitempty"`
}

func (WireGuardPeer) IsResource() {}

func (WireGuardPeer) IsNode() {}

// WireGuard peer configuration
type WireGuardPeerConfig struct {
	// Parent WireGuard interface ID
	Interface string `json:"interface"`
	// Peer public key
	PublicKey string `json:"publicKey"`
	// Allowed addresses (CIDR)
	AllowedAddress []CIDR `json:"allowedAddress"`
	// Peer endpoint (IP:port)
	Endpoint *string `json:"endpoint,omitempty"`
	// Preshared key (optional)
	PresharedKey *string `json:"presharedKey,omitempty"`
	// Persistent keepalive interval
	PersistentKeepalive *Duration `json:"persistentKeepalive,omitempty"`
}

// WireGuard peer deployment state
type WireGuardPeerDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
}

// WireGuard peer runtime state
type WireGuardPeerRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether peer is connected
	IsConnected bool `json:"isConnected"`
	// Last handshake time
	LastHandshake *time.Time `json:"lastHandshake,omitempty"`
	// Endpoint currently used
	CurrentEndpoint *string `json:"currentEndpoint,omitempty"`
	// Bytes received from peer
	BytesReceived Size `json:"bytesReceived"`
	// Bytes sent to peer
	BytesSent Size `json:"bytesSent"`
}

// WireGuard runtime state
type WireGuardRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether connected to peer
	IsConnected bool `json:"isConnected"`
	// Last handshake time
	LastHandshake *time.Time `json:"lastHandshake,omitempty"`
	// Current endpoint (may differ from configured)
	CurrentEndpoint *string `json:"currentEndpoint,omitempty"`
	// Bytes transferred in
	BytesIn Size `json:"bytesIn"`
	// Bytes transferred out
	BytesOut Size `json:"bytesOut"`
	// Current active peers count
	ActivePeers int `json:"activePeers"`
}

// WireGuard Server resource implementing 8-layer model
type WireGuardServer struct {
	ID                 string                     `json:"id"`
	ScopedID           string                     `json:"scopedId"`
	Type               string                     `json:"type"`
	Category           ResourceCategory           `json:"category"`
	Configuration      map[string]any             `json:"configuration,omitempty"`
	Validation         *ValidationResult          `json:"validation,omitempty"`
	Deployment         *DeploymentState           `json:"deployment,omitempty"`
	Runtime            *RuntimeState              `json:"runtime,omitempty"`
	Telemetry          *TelemetryData             `json:"telemetry,omitempty"`
	Metadata           *ResourceMetadata          `json:"metadata"`
	Relationships      *ResourceRelationships     `json:"relationships,omitempty"`
	Platform           *PlatformInfo              `json:"platform,omitempty"`
	Config             *WireGuardServerConfig     `json:"config"`
	WgServerDeployment *WireGuardServerDeployment `json:"wgServerDeployment,omitempty"`
	WgServerRuntime    *WireGuardServerRuntime    `json:"wgServerRuntime,omitempty"`
}

func (WireGuardServer) IsResource() {}

func (WireGuardServer) IsNode() {}

// WireGuard server configuration
type WireGuardServerConfig struct {
	// User-friendly name
	Name string `json:"name"`
	// Server listen port
	ListenPort Port `json:"listenPort"`
	// Server private key
	PrivateKey string `json:"privateKey"`
	// Server address (tunnel IP)
	Address string `json:"address"`
	// Server peers
	Peers []string `json:"peers"`
	// Enable peer to peer mode
	EnableP2p *bool `json:"enableP2P,omitempty"`
	// Mtu
	Mtu *int `json:"mtu,omitempty"`
}

// WireGuard server deployment state
type WireGuardServerDeployment struct {
	RouterResourceID *string    `json:"routerResourceId,omitempty"`
	AppliedAt        time.Time  `json:"appliedAt"`
	AppliedBy        *string    `json:"appliedBy,omitempty"`
	RouterVersion    *int       `json:"routerVersion,omitempty"`
	IsInSync         bool       `json:"isInSync"`
	Drift            *DriftInfo `json:"drift,omitempty"`
	// Generated public key
	PublicKey *string `json:"publicKey,omitempty"`
	// Assigned interface name
	InterfaceName *string `json:"interfaceName,omitempty"`
}

// WireGuard server runtime state
type WireGuardServerRuntime struct {
	IsRunning    bool          `json:"isRunning"`
	Health       RuntimeHealth `json:"health"`
	ErrorMessage *string       `json:"errorMessage,omitempty"`
	LastUpdated  time.Time     `json:"lastUpdated"`
	// Whether server is listening
	IsListening bool `json:"isListening"`
	// Current connected peers
	ConnectedPeers int `json:"connectedPeers"`
	// Total bytes transferred in
	BytesIn Size `json:"bytesIn"`
	// Total bytes transferred out
	BytesOut Size `json:"bytesOut"`
}

// Alert action types for subscriptions
type AlertAction string

const (
	// Alert was created/triggered
	AlertActionCreated AlertAction = "CREATED"
	// Alert was acknowledged
	AlertActionAcknowledged AlertAction = "ACKNOWLEDGED"
	// Alert was resolved
	AlertActionResolved AlertAction = "RESOLVED"
)

var AllAlertAction = []AlertAction{
	AlertActionCreated,
	AlertActionAcknowledged,
	AlertActionResolved,
}

func (e AlertAction) IsValid() bool {
	switch e {
	case AlertActionCreated, AlertActionAcknowledged, AlertActionResolved:
		return true
	}
	return false
}

func (e AlertAction) String() string {
	return string(e)
}

func (e *AlertAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertAction", str)
	}
	return nil
}

func (e AlertAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Alert rule template categories
type AlertRuleTemplateCategory string

const (
	// Network connectivity and interface monitoring
	AlertRuleTemplateCategoryNetwork AlertRuleTemplateCategory = "NETWORK"
	// Security and firewall events
	AlertRuleTemplateCategorySecurity AlertRuleTemplateCategory = "SECURITY"
	// Resource usage (CPU, memory, disk)
	AlertRuleTemplateCategoryResources AlertRuleTemplateCategory = "RESOURCES"
	// VPN and tunnel monitoring
	AlertRuleTemplateCategoryVpn AlertRuleTemplateCategory = "VPN"
	// DHCP and IP address management
	AlertRuleTemplateCategoryDhcp AlertRuleTemplateCategory = "DHCP"
	// System events and maintenance
	AlertRuleTemplateCategorySystem AlertRuleTemplateCategory = "SYSTEM"
	// Custom user-defined templates
	AlertRuleTemplateCategoryCustom AlertRuleTemplateCategory = "CUSTOM"
)

var AllAlertRuleTemplateCategory = []AlertRuleTemplateCategory{
	AlertRuleTemplateCategoryNetwork,
	AlertRuleTemplateCategorySecurity,
	AlertRuleTemplateCategoryResources,
	AlertRuleTemplateCategoryVpn,
	AlertRuleTemplateCategoryDhcp,
	AlertRuleTemplateCategorySystem,
	AlertRuleTemplateCategoryCustom,
}

func (e AlertRuleTemplateCategory) IsValid() bool {
	switch e {
	case AlertRuleTemplateCategoryNetwork, AlertRuleTemplateCategorySecurity, AlertRuleTemplateCategoryResources, AlertRuleTemplateCategoryVpn, AlertRuleTemplateCategoryDhcp, AlertRuleTemplateCategorySystem, AlertRuleTemplateCategoryCustom:
		return true
	}
	return false
}

func (e AlertRuleTemplateCategory) String() string {
	return string(e)
}

func (e *AlertRuleTemplateCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertRuleTemplateCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertRuleTemplateCategory", str)
	}
	return nil
}

func (e AlertRuleTemplateCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertRuleTemplateCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertRuleTemplateCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Variable types for alert rule templates
type AlertRuleTemplateVariableType string

const (
	// String value
	AlertRuleTemplateVariableTypeString AlertRuleTemplateVariableType = "STRING"
	// Integer value
	AlertRuleTemplateVariableTypeInteger AlertRuleTemplateVariableType = "INTEGER"
	// Duration in seconds
	AlertRuleTemplateVariableTypeDuration AlertRuleTemplateVariableType = "DURATION"
	// Percentage (0-100)
	AlertRuleTemplateVariableTypePercentage AlertRuleTemplateVariableType = "PERCENTAGE"
)

var AllAlertRuleTemplateVariableType = []AlertRuleTemplateVariableType{
	AlertRuleTemplateVariableTypeString,
	AlertRuleTemplateVariableTypeInteger,
	AlertRuleTemplateVariableTypeDuration,
	AlertRuleTemplateVariableTypePercentage,
}

func (e AlertRuleTemplateVariableType) IsValid() bool {
	switch e {
	case AlertRuleTemplateVariableTypeString, AlertRuleTemplateVariableTypeInteger, AlertRuleTemplateVariableTypeDuration, AlertRuleTemplateVariableTypePercentage:
		return true
	}
	return false
}

func (e AlertRuleTemplateVariableType) String() string {
	return string(e)
}

func (e *AlertRuleTemplateVariableType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertRuleTemplateVariableType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertRuleTemplateVariableType", str)
	}
	return nil
}

func (e AlertRuleTemplateVariableType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertRuleTemplateVariableType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertRuleTemplateVariableType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Alert severity levels
type AlertSeverity string

const (
	// Critical - requires immediate attention
	AlertSeverityCritical AlertSeverity = "CRITICAL"
	// Warning - attention needed soon
	AlertSeverityWarning AlertSeverity = "WARNING"
	// Info - informational only
	AlertSeverityInfo AlertSeverity = "INFO"
)

var AllAlertSeverity = []AlertSeverity{
	AlertSeverityCritical,
	AlertSeverityWarning,
	AlertSeverityInfo,
}

func (e AlertSeverity) IsValid() bool {
	switch e {
	case AlertSeverityCritical, AlertSeverityWarning, AlertSeverityInfo:
		return true
	}
	return false
}

func (e AlertSeverity) String() string {
	return string(e)
}

func (e *AlertSeverity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertSeverity", str)
	}
	return nil
}

func (e AlertSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertSeverity) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertSeverity) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Template variable types for notification templates
type AlertTemplateVariableType string

const (
	// String value
	AlertTemplateVariableTypeString AlertTemplateVariableType = "STRING"
	// Numeric value
	AlertTemplateVariableTypeNumber AlertTemplateVariableType = "NUMBER"
	// Timestamp value
	AlertTemplateVariableTypeTimestamp AlertTemplateVariableType = "TIMESTAMP"
	// Boolean value
	AlertTemplateVariableTypeBoolean AlertTemplateVariableType = "BOOLEAN"
	// Interface name
	AlertTemplateVariableTypeInterface AlertTemplateVariableType = "INTERFACE"
	// IP address
	AlertTemplateVariableTypeIpaddress AlertTemplateVariableType = "IPADDRESS"
)

var AllAlertTemplateVariableType = []AlertTemplateVariableType{
	AlertTemplateVariableTypeString,
	AlertTemplateVariableTypeNumber,
	AlertTemplateVariableTypeTimestamp,
	AlertTemplateVariableTypeBoolean,
	AlertTemplateVariableTypeInterface,
	AlertTemplateVariableTypeIpaddress,
}

func (e AlertTemplateVariableType) IsValid() bool {
	switch e {
	case AlertTemplateVariableTypeString, AlertTemplateVariableTypeNumber, AlertTemplateVariableTypeTimestamp, AlertTemplateVariableTypeBoolean, AlertTemplateVariableTypeInterface, AlertTemplateVariableTypeIpaddress:
		return true
	}
	return false
}

func (e AlertTemplateVariableType) String() string {
	return string(e)
}

func (e *AlertTemplateVariableType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertTemplateVariableType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertTemplateVariableType", str)
	}
	return nil
}

func (e AlertTemplateVariableType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertTemplateVariableType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertTemplateVariableType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Actions available for batch interface operations
type BatchInterfaceAction string

const (
	BatchInterfaceActionEnable  BatchInterfaceAction = "ENABLE"
	BatchInterfaceActionDisable BatchInterfaceAction = "DISABLE"
	BatchInterfaceActionUpdate  BatchInterfaceAction = "UPDATE"
)

var AllBatchInterfaceAction = []BatchInterfaceAction{
	BatchInterfaceActionEnable,
	BatchInterfaceActionDisable,
	BatchInterfaceActionUpdate,
}

func (e BatchInterfaceAction) IsValid() bool {
	switch e {
	case BatchInterfaceActionEnable, BatchInterfaceActionDisable, BatchInterfaceActionUpdate:
		return true
	}
	return false
}

func (e BatchInterfaceAction) String() string {
	return string(e)
}

func (e *BatchInterfaceAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BatchInterfaceAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BatchInterfaceAction", str)
	}
	return nil
}

func (e BatchInterfaceAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BatchInterfaceAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BatchInterfaceAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Bonding mode enum
type BondingMode string

const (
	// Load balancing - transmit on first available
	BondingModeBalanceRr BondingMode = "BALANCE_RR"
	// Active-backup - only one link active
	BondingModeActiveBackup BondingMode = "ACTIVE_BACKUP"
	// Balance XOR - based on source/destination
	BondingModeBalanceXor BondingMode = "BALANCE_XOR"
	// Broadcast - send on all links
	BondingModeBroadcast BondingMode = "BROADCAST"
	// 802.3AD - LACP protocol
	BondingModeBalanceAlb BondingMode = "BALANCE_ALB"
	// Transmit load balancing
	BondingModeBalanceTlb BondingMode = "BALANCE_TLB"
)

var AllBondingMode = []BondingMode{
	BondingModeBalanceRr,
	BondingModeActiveBackup,
	BondingModeBalanceXor,
	BondingModeBroadcast,
	BondingModeBalanceAlb,
	BondingModeBalanceTlb,
}

func (e BondingMode) IsValid() bool {
	switch e {
	case BondingModeBalanceRr, BondingModeActiveBackup, BondingModeBalanceXor, BondingModeBroadcast, BondingModeBalanceAlb, BondingModeBalanceTlb:
		return true
	}
	return false
}

func (e BondingMode) String() string {
	return string(e)
}

func (e *BondingMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BondingMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BondingMode", str)
	}
	return nil
}

func (e BondingMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BondingMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BondingMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Frame types that can be admitted on a bridge port
type BridgePortFrameTypes string

const (
	// Accept all frames (tagged and untagged)
	BridgePortFrameTypesAdmitAll BridgePortFrameTypes = "ADMIT_ALL"
	// Accept only untagged and priority-tagged frames
	BridgePortFrameTypesAdmitOnlyUntaggedAndPriorityTagged BridgePortFrameTypes = "ADMIT_ONLY_UNTAGGED_AND_PRIORITY_TAGGED"
	// Accept only VLAN-tagged frames
	BridgePortFrameTypesAdmitOnlyVlanTagged BridgePortFrameTypes = "ADMIT_ONLY_VLAN_TAGGED"
)

var AllBridgePortFrameTypes = []BridgePortFrameTypes{
	BridgePortFrameTypesAdmitAll,
	BridgePortFrameTypesAdmitOnlyUntaggedAndPriorityTagged,
	BridgePortFrameTypesAdmitOnlyVlanTagged,
}

func (e BridgePortFrameTypes) IsValid() bool {
	switch e {
	case BridgePortFrameTypesAdmitAll, BridgePortFrameTypesAdmitOnlyUntaggedAndPriorityTagged, BridgePortFrameTypesAdmitOnlyVlanTagged:
		return true
	}
	return false
}

func (e BridgePortFrameTypes) String() string {
	return string(e)
}

func (e *BridgePortFrameTypes) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BridgePortFrameTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BridgePortFrameTypes", str)
	}
	return nil
}

func (e BridgePortFrameTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BridgePortFrameTypes) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BridgePortFrameTypes) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CacheScope string

const (
	CacheScopePrivate CacheScope = "PRIVATE"
	CacheScopePublic  CacheScope = "PUBLIC"
)

var AllCacheScope = []CacheScope{
	CacheScopePrivate,
	CacheScopePublic,
}

func (e CacheScope) IsValid() bool {
	switch e {
	case CacheScopePrivate, CacheScopePublic:
		return true
	}
	return false
}

func (e CacheScope) String() string {
	return string(e)
}

func (e *CacheScope) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CacheScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CacheScope", str)
	}
	return nil
}

func (e CacheScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CacheScope) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CacheScope) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Feature capability categories detected on routers.
// Used to determine what features are available on a specific router.
type Capability string

const (
	// Container/Docker support
	CapabilityContainer Capability = "CONTAINER"
	// Virtual Interface Factory support
	CapabilityVif Capability = "VIF"
	// Wireless/WiFi support
	CapabilityWireless Capability = "WIRELESS"
	// Advanced routing features
	CapabilityRouting Capability = "ROUTING"
	// Firewall features
	CapabilityFirewall Capability = "FIREWALL"
	// MPLS support
	CapabilityMpls Capability = "MPLS"
	// IPv6 support
	CapabilityIPV6 Capability = "IPV6"
	// Hotspot features
	CapabilityHotspot Capability = "HOTSPOT"
	// User Manager features
	CapabilityUserManager Capability = "USER_MANAGER"
	// Dude monitoring support
	CapabilityDude Capability = "DUDE"
	// WireGuard VPN support
	CapabilityWireguard Capability = "WIREGUARD"
	// ZeroTier support
	CapabilityZerotier Capability = "ZEROTIER"
)

var AllCapability = []Capability{
	CapabilityContainer,
	CapabilityVif,
	CapabilityWireless,
	CapabilityRouting,
	CapabilityFirewall,
	CapabilityMpls,
	CapabilityIPV6,
	CapabilityHotspot,
	CapabilityUserManager,
	CapabilityDude,
	CapabilityWireguard,
	CapabilityZerotier,
}

func (e Capability) IsValid() bool {
	switch e {
	case CapabilityContainer, CapabilityVif, CapabilityWireless, CapabilityRouting, CapabilityFirewall, CapabilityMpls, CapabilityIPV6, CapabilityHotspot, CapabilityUserManager, CapabilityDude, CapabilityWireguard, CapabilityZerotier:
		return true
	}
	return false
}

func (e Capability) String() string {
	return string(e)
}

func (e *Capability) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Capability(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Capability", str)
	}
	return nil
}

func (e Capability) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Capability) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Capability) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Capability support level for a feature.
// Determines how the feature appears in the UI.
type CapabilityLevel string

const (
	// Feature not supported (hide in UI)
	CapabilityLevelNone CapabilityLevel = "NONE"
	// Limited support (show with warnings)
	CapabilityLevelBasic CapabilityLevel = "BASIC"
	// Full RouterOS native support
	CapabilityLevelAdvanced CapabilityLevel = "ADVANCED"
	// Complete support including container-based features
	CapabilityLevelFull CapabilityLevel = "FULL"
)

var AllCapabilityLevel = []CapabilityLevel{
	CapabilityLevelNone,
	CapabilityLevelBasic,
	CapabilityLevelAdvanced,
	CapabilityLevelFull,
}

func (e CapabilityLevel) IsValid() bool {
	switch e {
	case CapabilityLevelNone, CapabilityLevelBasic, CapabilityLevelAdvanced, CapabilityLevelFull:
		return true
	}
	return false
}

func (e CapabilityLevel) String() string {
	return string(e)
}

func (e *CapabilityLevel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CapabilityLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CapabilityLevel", str)
	}
	return nil
}

func (e CapabilityLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CapabilityLevel) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CapabilityLevel) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of operation to perform on a resource
type ChangeOperation string

const (
	// Create a new resource
	ChangeOperationCreate ChangeOperation = "CREATE"
	// Update an existing resource
	ChangeOperationUpdate ChangeOperation = "UPDATE"
	// Delete an existing resource
	ChangeOperationDelete ChangeOperation = "DELETE"
)

var AllChangeOperation = []ChangeOperation{
	ChangeOperationCreate,
	ChangeOperationUpdate,
	ChangeOperationDelete,
}

func (e ChangeOperation) IsValid() bool {
	switch e {
	case ChangeOperationCreate, ChangeOperationUpdate, ChangeOperationDelete:
		return true
	}
	return false
}

func (e ChangeOperation) String() string {
	return string(e)
}

func (e *ChangeOperation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeOperation", str)
	}
	return nil
}

func (e ChangeOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ChangeOperation) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ChangeOperation) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status of individual items within a change set
type ChangeSetItemStatus string

const (
	// Waiting to be applied
	ChangeSetItemStatusPending ChangeSetItemStatus = "PENDING"
	// Currently being applied
	ChangeSetItemStatusApplying ChangeSetItemStatus = "APPLYING"
	// Successfully applied
	ChangeSetItemStatusApplied ChangeSetItemStatus = "APPLIED"
	// Application failed
	ChangeSetItemStatusFailed ChangeSetItemStatus = "FAILED"
	// Successfully rolled back
	ChangeSetItemStatusRolledBack ChangeSetItemStatus = "ROLLED_BACK"
	// Rollback failed - manual intervention needed
	ChangeSetItemStatusRollbackFailed ChangeSetItemStatus = "ROLLBACK_FAILED"
	// Skipped due to dependency failure
	ChangeSetItemStatusSkipped ChangeSetItemStatus = "SKIPPED"
)

var AllChangeSetItemStatus = []ChangeSetItemStatus{
	ChangeSetItemStatusPending,
	ChangeSetItemStatusApplying,
	ChangeSetItemStatusApplied,
	ChangeSetItemStatusFailed,
	ChangeSetItemStatusRolledBack,
	ChangeSetItemStatusRollbackFailed,
	ChangeSetItemStatusSkipped,
}

func (e ChangeSetItemStatus) IsValid() bool {
	switch e {
	case ChangeSetItemStatusPending, ChangeSetItemStatusApplying, ChangeSetItemStatusApplied, ChangeSetItemStatusFailed, ChangeSetItemStatusRolledBack, ChangeSetItemStatusRollbackFailed, ChangeSetItemStatusSkipped:
		return true
	}
	return false
}

func (e ChangeSetItemStatus) String() string {
	return string(e)
}

func (e *ChangeSetItemStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeSetItemStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeSetItemStatus", str)
	}
	return nil
}

func (e ChangeSetItemStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ChangeSetItemStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ChangeSetItemStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Change set lifecycle status
type ChangeSetStatus string

const (
	// Initial state - adding items, not yet validated
	ChangeSetStatusDraft ChangeSetStatus = "DRAFT"
	// Running validation on all items
	ChangeSetStatusValidating ChangeSetStatus = "VALIDATING"
	// All items validated, ready to apply
	ChangeSetStatusReady ChangeSetStatus = "READY"
	// Applying resources in dependency order
	ChangeSetStatusApplying ChangeSetStatus = "APPLYING"
	// All resources applied successfully
	ChangeSetStatusCompleted ChangeSetStatus = "COMPLETED"
	// Apply failed, may have partial application
	ChangeSetStatusFailed ChangeSetStatus = "FAILED"
	// Rolling back applied changes
	ChangeSetStatusRollingBack ChangeSetStatus = "ROLLING_BACK"
	// Rollback completed successfully
	ChangeSetStatusRolledBack ChangeSetStatus = "ROLLED_BACK"
	// Rollback partially failed - manual intervention needed
	ChangeSetStatusPartialFailure ChangeSetStatus = "PARTIAL_FAILURE"
	// User cancelled the operation
	ChangeSetStatusCancelled ChangeSetStatus = "CANCELLED"
)

var AllChangeSetStatus = []ChangeSetStatus{
	ChangeSetStatusDraft,
	ChangeSetStatusValidating,
	ChangeSetStatusReady,
	ChangeSetStatusApplying,
	ChangeSetStatusCompleted,
	ChangeSetStatusFailed,
	ChangeSetStatusRollingBack,
	ChangeSetStatusRolledBack,
	ChangeSetStatusPartialFailure,
	ChangeSetStatusCancelled,
}

func (e ChangeSetStatus) IsValid() bool {
	switch e {
	case ChangeSetStatusDraft, ChangeSetStatusValidating, ChangeSetStatusReady, ChangeSetStatusApplying, ChangeSetStatusCompleted, ChangeSetStatusFailed, ChangeSetStatusRollingBack, ChangeSetStatusRolledBack, ChangeSetStatusPartialFailure, ChangeSetStatusCancelled:
		return true
	}
	return false
}

func (e ChangeSetStatus) String() string {
	return string(e)
}

func (e *ChangeSetStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeSetStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeSetStatus", str)
	}
	return nil
}

func (e ChangeSetStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ChangeSetStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ChangeSetStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of change for resource events
type ChangeType string

const (
	ChangeTypeCreate ChangeType = "CREATE"
	ChangeTypeUpdate ChangeType = "UPDATE"
	ChangeTypeDelete ChangeType = "DELETE"
)

var AllChangeType = []ChangeType{
	ChangeTypeCreate,
	ChangeTypeUpdate,
	ChangeTypeDelete,
}

func (e ChangeType) IsValid() bool {
	switch e {
	case ChangeTypeCreate, ChangeTypeUpdate, ChangeTypeDelete:
		return true
	}
	return false
}

func (e ChangeType) String() string {
	return string(e)
}

func (e *ChangeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChangeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChangeType", str)
	}
	return nil
}

func (e ChangeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ChangeType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ChangeType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of notification channel
type ChannelType string

const (
	ChannelTypePushover ChannelType = "PUSHOVER"
	ChannelTypeEmail    ChannelType = "EMAIL"
	ChannelTypeSLACk    ChannelType = "SLACK"
	ChannelTypeWebhook  ChannelType = "WEBHOOK"
	ChannelTypeTelegram ChannelType = "TELEGRAM"
)

var AllChannelType = []ChannelType{
	ChannelTypePushover,
	ChannelTypeEmail,
	ChannelTypeSLACk,
	ChannelTypeWebhook,
	ChannelTypeTelegram,
}

func (e ChannelType) IsValid() bool {
	switch e {
	case ChannelTypePushover, ChannelTypeEmail, ChannelTypeSLACk, ChannelTypeWebhook, ChannelTypeTelegram:
		return true
	}
	return false
}

func (e ChannelType) String() string {
	return string(e)
}

func (e *ChannelType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChannelType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChannelType", str)
	}
	return nil
}

func (e ChannelType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ChannelType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ChannelType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Circuit breaker state
type CircuitBreakerState string

const (
	// Circuit is closed (normal operation)
	CircuitBreakerStateClosed CircuitBreakerState = "CLOSED"
	// Circuit is open (blocking requests)
	CircuitBreakerStateOpen CircuitBreakerState = "OPEN"
	// Circuit is half-open (testing recovery)
	CircuitBreakerStateHalfOpen CircuitBreakerState = "HALF_OPEN"
)

var AllCircuitBreakerState = []CircuitBreakerState{
	CircuitBreakerStateClosed,
	CircuitBreakerStateOpen,
	CircuitBreakerStateHalfOpen,
}

func (e CircuitBreakerState) IsValid() bool {
	switch e {
	case CircuitBreakerStateClosed, CircuitBreakerStateOpen, CircuitBreakerStateHalfOpen:
		return true
	}
	return false
}

func (e CircuitBreakerState) String() string {
	return string(e)
}

func (e *CircuitBreakerState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CircuitBreakerState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CircuitBreakerState", str)
	}
	return nil
}

func (e CircuitBreakerState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CircuitBreakerState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CircuitBreakerState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Condition comparison operators
type ConditionOperator string

const (
	// Exact match
	ConditionOperatorEquals ConditionOperator = "EQUALS"
	// Not equal
	ConditionOperatorNotEquals ConditionOperator = "NOT_EQUALS"
	// Numeric greater than
	ConditionOperatorGreaterThan ConditionOperator = "GREATER_THAN"
	// Numeric less than
	ConditionOperatorLessThan ConditionOperator = "LESS_THAN"
	// String contains
	ConditionOperatorContains ConditionOperator = "CONTAINS"
	// Regular expression match
	ConditionOperatorRegex ConditionOperator = "REGEX"
)

var AllConditionOperator = []ConditionOperator{
	ConditionOperatorEquals,
	ConditionOperatorNotEquals,
	ConditionOperatorGreaterThan,
	ConditionOperatorLessThan,
	ConditionOperatorContains,
	ConditionOperatorRegex,
}

func (e ConditionOperator) IsValid() bool {
	switch e {
	case ConditionOperatorEquals, ConditionOperatorNotEquals, ConditionOperatorGreaterThan, ConditionOperatorLessThan, ConditionOperatorContains, ConditionOperatorRegex:
		return true
	}
	return false
}

func (e ConditionOperator) String() string {
	return string(e)
}

func (e *ConditionOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionOperator", str)
	}
	return nil
}

func (e ConditionOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConditionOperator) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConditionOperator) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status of a configuration apply operation
type ConfigApplyStatus string

const (
	ConfigApplyStatusPending    ConfigApplyStatus = "PENDING"
	ConfigApplyStatusValidating ConfigApplyStatus = "VALIDATING"
	ConfigApplyStatusApplying   ConfigApplyStatus = "APPLYING"
	ConfigApplyStatusVerifying  ConfigApplyStatus = "VERIFYING"
	ConfigApplyStatusCompleted  ConfigApplyStatus = "COMPLETED"
	ConfigApplyStatusFailed     ConfigApplyStatus = "FAILED"
	ConfigApplyStatusRolledBack ConfigApplyStatus = "ROLLED_BACK"
)

var AllConfigApplyStatus = []ConfigApplyStatus{
	ConfigApplyStatusPending,
	ConfigApplyStatusValidating,
	ConfigApplyStatusApplying,
	ConfigApplyStatusVerifying,
	ConfigApplyStatusCompleted,
	ConfigApplyStatusFailed,
	ConfigApplyStatusRolledBack,
}

func (e ConfigApplyStatus) IsValid() bool {
	switch e {
	case ConfigApplyStatusPending, ConfigApplyStatusValidating, ConfigApplyStatusApplying, ConfigApplyStatusVerifying, ConfigApplyStatusCompleted, ConfigApplyStatusFailed, ConfigApplyStatusRolledBack:
		return true
	}
	return false
}

func (e ConfigApplyStatus) String() string {
	return string(e)
}

func (e *ConfigApplyStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfigApplyStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfigApplyStatus", str)
	}
	return nil
}

func (e ConfigApplyStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConfigApplyStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConfigApplyStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Configuration field type for dynamic form generation
type ConfigFieldType string

const (
	// Single-line text input
	ConfigFieldTypeText ConfigFieldType = "TEXT"
	// Multi-line text area
	ConfigFieldTypeTextArea ConfigFieldType = "TEXT_AREA"
	// Number input
	ConfigFieldTypeNumber ConfigFieldType = "NUMBER"
	// Boolean toggle/checkbox
	ConfigFieldTypeToggle ConfigFieldType = "TOGGLE"
	// Single-select dropdown
	ConfigFieldTypeSelect ConfigFieldType = "SELECT"
	// Multi-select dropdown
	ConfigFieldTypeMultiSelect ConfigFieldType = "MULTI_SELECT"
	// Array of text inputs
	ConfigFieldTypeTextArray ConfigFieldType = "TEXT_ARRAY"
	// Password input (masked)
	ConfigFieldTypePassword ConfigFieldType = "PASSWORD"
	// IP address input
	ConfigFieldTypeIP ConfigFieldType = "IP"
	// Port number input
	ConfigFieldTypePort ConfigFieldType = "PORT"
	// Email input
	ConfigFieldTypeEmail ConfigFieldType = "EMAIL"
	// URL input
	ConfigFieldTypeURL ConfigFieldType = "URL"
)

var AllConfigFieldType = []ConfigFieldType{
	ConfigFieldTypeText,
	ConfigFieldTypeTextArea,
	ConfigFieldTypeNumber,
	ConfigFieldTypeToggle,
	ConfigFieldTypeSelect,
	ConfigFieldTypeMultiSelect,
	ConfigFieldTypeTextArray,
	ConfigFieldTypePassword,
	ConfigFieldTypeIP,
	ConfigFieldTypePort,
	ConfigFieldTypeEmail,
	ConfigFieldTypeURL,
}

func (e ConfigFieldType) IsValid() bool {
	switch e {
	case ConfigFieldTypeText, ConfigFieldTypeTextArea, ConfigFieldTypeNumber, ConfigFieldTypeToggle, ConfigFieldTypeSelect, ConfigFieldTypeMultiSelect, ConfigFieldTypeTextArray, ConfigFieldTypePassword, ConfigFieldTypeIP, ConfigFieldTypePort, ConfigFieldTypeEmail, ConfigFieldTypeURL:
		return true
	}
	return false
}

func (e ConfigFieldType) String() string {
	return string(e)
}

func (e *ConfigFieldType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfigFieldType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfigFieldType", str)
	}
	return nil
}

func (e ConfigFieldType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConfigFieldType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConfigFieldType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Severity level for confirmation dialogs
type ConfirmationSeverity string

const (
	// Critical operation requiring explicit confirmation
	ConfirmationSeverityCritical ConfirmationSeverity = "CRITICAL"
	// Standard operation with brief confirmation
	ConfirmationSeverityStandard ConfirmationSeverity = "STANDARD"
)

var AllConfirmationSeverity = []ConfirmationSeverity{
	ConfirmationSeverityCritical,
	ConfirmationSeverityStandard,
}

func (e ConfirmationSeverity) IsValid() bool {
	switch e {
	case ConfirmationSeverityCritical, ConfirmationSeverityStandard:
		return true
	}
	return false
}

func (e ConfirmationSeverity) String() string {
	return string(e)
}

func (e *ConfirmationSeverity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConfirmationSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConfirmationSeverity", str)
	}
	return nil
}

func (e ConfirmationSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConfirmationSeverity) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConfirmationSeverity) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Conflict resolution strategy for service import.
// Determines what happens when an imported service name already exists.
type ConflictResolution string

const (
	// Skip import, leave existing instance unchanged
	ConflictResolutionSkip ConflictResolution = "SKIP"
	// Overwrite existing instance configuration
	ConflictResolutionOverwrite ConflictResolution = "OVERWRITE"
	// Create new instance with renamed name
	ConflictResolutionRename ConflictResolution = "RENAME"
)

var AllConflictResolution = []ConflictResolution{
	ConflictResolutionSkip,
	ConflictResolutionOverwrite,
	ConflictResolutionRename,
}

func (e ConflictResolution) IsValid() bool {
	switch e {
	case ConflictResolutionSkip, ConflictResolutionOverwrite, ConflictResolutionRename:
		return true
	}
	return false
}

func (e ConflictResolution) String() string {
	return string(e)
}

func (e *ConflictResolution) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConflictResolution(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConflictResolution", str)
	}
	return nil
}

func (e ConflictResolution) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConflictResolution) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConflictResolution) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Types of resource conflicts
type ConflictType string

const (
	// Port number conflict
	ConflictTypePort ConflictType = "PORT"
	// IP address conflict
	ConflictTypeIPAddress ConflictType = "IP_ADDRESS"
	// Route overlap
	ConflictTypeRoute ConflictType = "ROUTE"
	// Interface conflict
	ConflictTypeInterface ConflictType = "INTERFACE"
	// Name collision
	ConflictTypeName ConflictType = "NAME"
	// Configuration incompatibility
	ConflictTypeConfiguration ConflictType = "CONFIGURATION"
)

var AllConflictType = []ConflictType{
	ConflictTypePort,
	ConflictTypeIPAddress,
	ConflictTypeRoute,
	ConflictTypeInterface,
	ConflictTypeName,
	ConflictTypeConfiguration,
}

func (e ConflictType) IsValid() bool {
	switch e {
	case ConflictTypePort, ConflictTypeIPAddress, ConflictTypeRoute, ConflictTypeInterface, ConflictTypeName, ConflictTypeConfiguration:
		return true
	}
	return false
}

func (e ConflictType) String() string {
	return string(e)
}

func (e *ConflictType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConflictType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConflictType", str)
	}
	return nil
}

func (e ConflictType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConflictType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConflictType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Error codes for connection failures.
// Each code has specific meaning and recovery suggestions.
type ConnectionErrorCode string

const (
	// Authentication failed - invalid username or password
	ConnectionErrorCodeAuthFailed ConnectionErrorCode = "AUTH_FAILED"
	// Network unreachable - cannot reach the host
	ConnectionErrorCodeNetworkUnreachable ConnectionErrorCode = "NETWORK_UNREACHABLE"
	// Connection refused - port is closed or blocked
	ConnectionErrorCodeConnectionRefused ConnectionErrorCode = "CONNECTION_REFUSED"
	// No compatible protocol found after trying all options
	ConnectionErrorCodeProtocolMismatch ConnectionErrorCode = "PROTOCOL_MISMATCH"
	// Connection or response timed out
	ConnectionErrorCodeTimeout ConnectionErrorCode = "TIMEOUT"
	// DNS resolution failed for hostname
	ConnectionErrorCodeDNSFailed ConnectionErrorCode = "DNS_FAILED"
	// Router with same host/port already exists
	ConnectionErrorCodeDuplicateRouter ConnectionErrorCode = "DUPLICATE_ROUTER"
	// TLS/SSL handshake failed
	ConnectionErrorCodeTLSError ConnectionErrorCode = "TLS_ERROR"
	// Router responded but is not a MikroTik device
	ConnectionErrorCodeNotMikrotik ConnectionErrorCode = "NOT_MIKROTIK"
	// Unknown or unexpected error
	ConnectionErrorCodeUnknown ConnectionErrorCode = "UNKNOWN"
)

var AllConnectionErrorCode = []ConnectionErrorCode{
	ConnectionErrorCodeAuthFailed,
	ConnectionErrorCodeNetworkUnreachable,
	ConnectionErrorCodeConnectionRefused,
	ConnectionErrorCodeProtocolMismatch,
	ConnectionErrorCodeTimeout,
	ConnectionErrorCodeDNSFailed,
	ConnectionErrorCodeDuplicateRouter,
	ConnectionErrorCodeTLSError,
	ConnectionErrorCodeNotMikrotik,
	ConnectionErrorCodeUnknown,
}

func (e ConnectionErrorCode) IsValid() bool {
	switch e {
	case ConnectionErrorCodeAuthFailed, ConnectionErrorCodeNetworkUnreachable, ConnectionErrorCodeConnectionRefused, ConnectionErrorCodeProtocolMismatch, ConnectionErrorCodeTimeout, ConnectionErrorCodeDNSFailed, ConnectionErrorCodeDuplicateRouter, ConnectionErrorCodeTLSError, ConnectionErrorCodeNotMikrotik, ConnectionErrorCodeUnknown:
		return true
	}
	return false
}

func (e ConnectionErrorCode) String() string {
	return string(e)
}

func (e *ConnectionErrorCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionErrorCode", str)
	}
	return nil
}

func (e ConnectionErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConnectionErrorCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConnectionErrorCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Router connection status
type ConnectionStatus string

const (
	// Actively connected and responsive
	ConnectionStatusConnected ConnectionStatus = "CONNECTED"
	// Connection attempt in progress
	ConnectionStatusConnecting ConnectionStatus = "CONNECTING"
	// Not connected
	ConnectionStatusDisconnected ConnectionStatus = "DISCONNECTED"
	// Connection failed with error
	ConnectionStatusError ConnectionStatus = "ERROR"
)

var AllConnectionStatus = []ConnectionStatus{
	ConnectionStatusConnected,
	ConnectionStatusConnecting,
	ConnectionStatusDisconnected,
	ConnectionStatusError,
}

func (e ConnectionStatus) IsValid() bool {
	switch e {
	case ConnectionStatusConnected, ConnectionStatusConnecting, ConnectionStatusDisconnected, ConnectionStatusError:
		return true
	}
	return false
}

func (e ConnectionStatus) String() string {
	return string(e)
}

func (e *ConnectionStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectionStatus", str)
	}
	return nil
}

func (e ConnectionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConnectionStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConnectionStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Error codes specific to credential operations.
type CredentialErrorCode string

const (
	// Authentication failed with new credentials
	CredentialErrorCodeAuthFailed CredentialErrorCode = "AUTH_FAILED"
	// Connection timed out when testing credentials
	CredentialErrorCodeTimeout CredentialErrorCode = "TIMEOUT"
	// Connection was refused
	CredentialErrorCodeConnectionRefused CredentialErrorCode = "CONNECTION_REFUSED"
	// Router not found
	CredentialErrorCodeRouterNotFound CredentialErrorCode = "ROUTER_NOT_FOUND"
	// Credentials not found for router
	CredentialErrorCodeCredentialsNotFound CredentialErrorCode = "CREDENTIALS_NOT_FOUND"
	// Encryption failed
	CredentialErrorCodeEncryptionFailed CredentialErrorCode = "ENCRYPTION_FAILED"
	// Decryption failed (key may have rotated)
	CredentialErrorCodeDecryptionFailed CredentialErrorCode = "DECRYPTION_FAILED"
	// Invalid input provided
	CredentialErrorCodeInvalidInput CredentialErrorCode = "INVALID_INPUT"
)

var AllCredentialErrorCode = []CredentialErrorCode{
	CredentialErrorCodeAuthFailed,
	CredentialErrorCodeTimeout,
	CredentialErrorCodeConnectionRefused,
	CredentialErrorCodeRouterNotFound,
	CredentialErrorCodeCredentialsNotFound,
	CredentialErrorCodeEncryptionFailed,
	CredentialErrorCodeDecryptionFailed,
	CredentialErrorCodeInvalidInput,
}

func (e CredentialErrorCode) IsValid() bool {
	switch e {
	case CredentialErrorCodeAuthFailed, CredentialErrorCodeTimeout, CredentialErrorCodeConnectionRefused, CredentialErrorCodeRouterNotFound, CredentialErrorCodeCredentialsNotFound, CredentialErrorCodeEncryptionFailed, CredentialErrorCodeDecryptionFailed, CredentialErrorCodeInvalidInput:
		return true
	}
	return false
}

func (e CredentialErrorCode) String() string {
	return string(e)
}

func (e *CredentialErrorCode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CredentialErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CredentialErrorCode", str)
	}
	return nil
}

func (e CredentialErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CredentialErrorCode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CredentialErrorCode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status of a credential test.
type CredentialTestStatus string

const (
	// Credentials are valid and connection succeeded
	CredentialTestStatusSuccess CredentialTestStatus = "SUCCESS"
	// Authentication failed
	CredentialTestStatusAuthFailed CredentialTestStatus = "AUTH_FAILED"
	// Connection timed out
	CredentialTestStatusTimeout CredentialTestStatus = "TIMEOUT"
	// Connection was refused
	CredentialTestStatusConnectionRefused CredentialTestStatus = "CONNECTION_REFUSED"
	// Network unreachable
	CredentialTestStatusNetworkError CredentialTestStatus = "NETWORK_ERROR"
	// No credentials stored for this router
	CredentialTestStatusNoCredentials CredentialTestStatus = "NO_CREDENTIALS"
	// Unknown error occurred
	CredentialTestStatusError CredentialTestStatus = "ERROR"
)

var AllCredentialTestStatus = []CredentialTestStatus{
	CredentialTestStatusSuccess,
	CredentialTestStatusAuthFailed,
	CredentialTestStatusTimeout,
	CredentialTestStatusConnectionRefused,
	CredentialTestStatusNetworkError,
	CredentialTestStatusNoCredentials,
	CredentialTestStatusError,
}

func (e CredentialTestStatus) IsValid() bool {
	switch e {
	case CredentialTestStatusSuccess, CredentialTestStatusAuthFailed, CredentialTestStatusTimeout, CredentialTestStatusConnectionRefused, CredentialTestStatusNetworkError, CredentialTestStatusNoCredentials, CredentialTestStatusError:
		return true
	}
	return false
}

func (e CredentialTestStatus) String() string {
	return string(e)
}

func (e *CredentialTestStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CredentialTestStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CredentialTestStatus", str)
	}
	return nil
}

func (e CredentialTestStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CredentialTestStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CredentialTestStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// DependencyType defines the strength of the dependency relationship.
type DependencyType string

const (
	// REQUIRES: Hard dependency - dependent cannot start without this dependency
	DependencyTypeRequires DependencyType = "REQUIRES"
	// OPTIONAL: Soft dependency - dependent can start even if this dependency is unavailable
	DependencyTypeOptional DependencyType = "OPTIONAL"
)

var AllDependencyType = []DependencyType{
	DependencyTypeRequires,
	DependencyTypeOptional,
}

func (e DependencyType) IsValid() bool {
	switch e {
	case DependencyTypeRequires, DependencyTypeOptional:
		return true
	}
	return false
}

func (e DependencyType) String() string {
	return string(e)
}

func (e *DependencyType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DependencyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DependencyType", str)
	}
	return nil
}

func (e DependencyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DependencyType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DependencyType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Diagnostic test status.
type DiagnosticStatus string

const (
	// Test passed successfully
	DiagnosticStatusPass DiagnosticStatus = "PASS"
	// Test failed
	DiagnosticStatusFail DiagnosticStatus = "FAIL"
	// Test completed with warnings
	DiagnosticStatusWarning DiagnosticStatus = "WARNING"
	// Test was skipped
	DiagnosticStatusSkipped DiagnosticStatus = "SKIPPED"
)

var AllDiagnosticStatus = []DiagnosticStatus{
	DiagnosticStatusPass,
	DiagnosticStatusFail,
	DiagnosticStatusWarning,
	DiagnosticStatusSkipped,
}

func (e DiagnosticStatus) IsValid() bool {
	switch e {
	case DiagnosticStatusPass, DiagnosticStatusFail, DiagnosticStatusWarning, DiagnosticStatusSkipped:
		return true
	}
	return false
}

func (e DiagnosticStatus) String() string {
	return string(e)
}

func (e *DiagnosticStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DiagnosticStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DiagnosticStatus", str)
	}
	return nil
}

func (e DiagnosticStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DiagnosticStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DiagnosticStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Reason for router disconnection
type DisconnectReason string

const (
	// Unknown reason
	DisconnectReasonUnknown DisconnectReason = "UNKNOWN"
	// User manually disconnected
	DisconnectReasonManual DisconnectReason = "MANUAL"
	// Network failure
	DisconnectReasonNetworkFailure DisconnectReason = "NETWORK_FAILURE"
	// Authentication failed
	DisconnectReasonAuthFailure DisconnectReason = "AUTH_FAILURE"
	// Connection timed out
	DisconnectReasonTimeout DisconnectReason = "TIMEOUT"
	// Circuit breaker is open
	DisconnectReasonCircuitOpen DisconnectReason = "CIRCUIT_OPEN"
	// Application shutting down
	DisconnectReasonShutdown DisconnectReason = "SHUTDOWN"
)

var AllDisconnectReason = []DisconnectReason{
	DisconnectReasonUnknown,
	DisconnectReasonManual,
	DisconnectReasonNetworkFailure,
	DisconnectReasonAuthFailure,
	DisconnectReasonTimeout,
	DisconnectReasonCircuitOpen,
	DisconnectReasonShutdown,
}

func (e DisconnectReason) IsValid() bool {
	switch e {
	case DisconnectReasonUnknown, DisconnectReasonManual, DisconnectReasonNetworkFailure, DisconnectReasonAuthFailure, DisconnectReasonTimeout, DisconnectReasonCircuitOpen, DisconnectReasonShutdown:
		return true
	}
	return false
}

func (e DisconnectReason) String() string {
	return string(e)
}

func (e *DisconnectReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DisconnectReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DisconnectReason", str)
	}
	return nil
}

func (e DisconnectReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DisconnectReason) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DisconnectReason) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// DNS lookup status codes
type DNSLookupStatus string

const (
	// Query completed successfully
	DNSLookupStatusSuccess DNSLookupStatus = "SUCCESS"
	// Domain does not exist (NXDOMAIN)
	DNSLookupStatusNxdomain DNSLookupStatus = "NXDOMAIN"
	// DNS server failure (SERVFAIL)
	DNSLookupStatusServfail DNSLookupStatus = "SERVFAIL"
	// Query timed out
	DNSLookupStatusTimeout DNSLookupStatus = "TIMEOUT"
	// Query refused by server
	DNSLookupStatusRefused DNSLookupStatus = "REFUSED"
	// Network error occurred
	DNSLookupStatusNetworkError DNSLookupStatus = "NETWORK_ERROR"
)

var AllDNSLookupStatus = []DNSLookupStatus{
	DNSLookupStatusSuccess,
	DNSLookupStatusNxdomain,
	DNSLookupStatusServfail,
	DNSLookupStatusTimeout,
	DNSLookupStatusRefused,
	DNSLookupStatusNetworkError,
}

func (e DNSLookupStatus) IsValid() bool {
	switch e {
	case DNSLookupStatusSuccess, DNSLookupStatusNxdomain, DNSLookupStatusServfail, DNSLookupStatusTimeout, DNSLookupStatusRefused, DNSLookupStatusNetworkError:
		return true
	}
	return false
}

func (e DNSLookupStatus) String() string {
	return string(e)
}

func (e *DNSLookupStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DNSLookupStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DnsLookupStatus", str)
	}
	return nil
}

func (e DNSLookupStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DNSLookupStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DNSLookupStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// DNS record types supported
type DNSRecordType string

const (
	// IPv4 address record
	DNSRecordTypeA DNSRecordType = "A"
	// IPv6 address record
	DNSRecordTypeAaaa DNSRecordType = "AAAA"
	// Mail exchange record
	DNSRecordTypeMx DNSRecordType = "MX"
	// Text record
	DNSRecordTypeTxt DNSRecordType = "TXT"
	// Canonical name record
	DNSRecordTypeCname DNSRecordType = "CNAME"
	// Name server record
	DNSRecordTypeNs DNSRecordType = "NS"
	// Pointer record (reverse DNS)
	DNSRecordTypePtr DNSRecordType = "PTR"
	// Start of authority record
	DNSRecordTypeSoa DNSRecordType = "SOA"
	// Service record
	DNSRecordTypeSrv DNSRecordType = "SRV"
)

var AllDNSRecordType = []DNSRecordType{
	DNSRecordTypeA,
	DNSRecordTypeAaaa,
	DNSRecordTypeMx,
	DNSRecordTypeTxt,
	DNSRecordTypeCname,
	DNSRecordTypeNs,
	DNSRecordTypePtr,
	DNSRecordTypeSoa,
	DNSRecordTypeSrv,
}

func (e DNSRecordType) IsValid() bool {
	switch e {
	case DNSRecordTypeA, DNSRecordTypeAaaa, DNSRecordTypeMx, DNSRecordTypeTxt, DNSRecordTypeCname, DNSRecordTypeNs, DNSRecordTypePtr, DNSRecordTypeSoa, DNSRecordTypeSrv:
		return true
	}
	return false
}

func (e DNSRecordType) String() string {
	return string(e)
}

func (e *DNSRecordType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DNSRecordType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DnsRecordType", str)
	}
	return nil
}

func (e DNSRecordType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DNSRecordType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DNSRecordType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status classification for DNS servers in benchmark
type DNSServerStatus string

const (
	// Fastest responding server
	DNSServerStatusFastest DNSServerStatus = "FASTEST"
	// Server responded in acceptable time (<100ms)
	DNSServerStatusGood DNSServerStatus = "GOOD"
	// Server responded slowly (>100ms)
	DNSServerStatusSlow DNSServerStatus = "SLOW"
	// Server did not respond
	DNSServerStatusUnreachable DNSServerStatus = "UNREACHABLE"
)

var AllDNSServerStatus = []DNSServerStatus{
	DNSServerStatusFastest,
	DNSServerStatusGood,
	DNSServerStatusSlow,
	DNSServerStatusUnreachable,
}

func (e DNSServerStatus) IsValid() bool {
	switch e {
	case DNSServerStatusFastest, DNSServerStatusGood, DNSServerStatusSlow, DNSServerStatusUnreachable:
		return true
	}
	return false
}

func (e DNSServerStatus) String() string {
	return string(e)
}

func (e *DNSServerStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DNSServerStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DnsServerStatus", str)
	}
	return nil
}

func (e DNSServerStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DNSServerStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DNSServerStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Actions to resolve drift
type DriftAction string

const (
	// Re-apply configuration to router
	DriftActionReapply DriftAction = "REAPPLY"
	// Update configuration to match router
	DriftActionAccept DriftAction = "ACCEPT"
	// Manual review required
	DriftActionReview DriftAction = "REVIEW"
)

var AllDriftAction = []DriftAction{
	DriftActionReapply,
	DriftActionAccept,
	DriftActionReview,
}

func (e DriftAction) IsValid() bool {
	switch e {
	case DriftActionReapply, DriftActionAccept, DriftActionReview:
		return true
	}
	return false
}

func (e DriftAction) String() string {
	return string(e)
}

func (e *DriftAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DriftAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DriftAction", str)
	}
	return nil
}

func (e DriftAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DriftAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DriftAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Category of connection error for classification
type ErrorCategory string

const (
	// Connection or response timeout
	ErrorCategoryTimeout ErrorCategory = "TIMEOUT"
	// Connection actively refused
	ErrorCategoryRefused ErrorCategory = "REFUSED"
	// Authentication failed
	ErrorCategoryAuthFailed ErrorCategory = "AUTH_FAILED"
	// Protocol-level error
	ErrorCategoryProtocolError ErrorCategory = "PROTOCOL_ERROR"
	// Network unreachable or DNS failure
	ErrorCategoryNetworkError ErrorCategory = "NETWORK_ERROR"
	// TLS/SSL certificate or handshake error
	ErrorCategoryTLSError ErrorCategory = "TLS_ERROR"
)

var AllErrorCategory = []ErrorCategory{
	ErrorCategoryTimeout,
	ErrorCategoryRefused,
	ErrorCategoryAuthFailed,
	ErrorCategoryProtocolError,
	ErrorCategoryNetworkError,
	ErrorCategoryTLSError,
}

func (e ErrorCategory) IsValid() bool {
	switch e {
	case ErrorCategoryTimeout, ErrorCategoryRefused, ErrorCategoryAuthFailed, ErrorCategoryProtocolError, ErrorCategoryNetworkError, ErrorCategoryTLSError:
		return true
	}
	return false
}

func (e ErrorCategory) String() string {
	return string(e)
}

func (e *ErrorCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorCategory", str)
	}
	return nil
}

func (e ErrorCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ErrorCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ErrorCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Escalation status (NAS-18.9)
type EscalationStatus string

const (
	// Escalation is pending/in progress
	EscalationStatusPending EscalationStatus = "PENDING"
	// Escalation was resolved (alert acknowledged)
	EscalationStatusResolved EscalationStatus = "RESOLVED"
	// Maximum escalation level reached
	EscalationStatusMaxReached EscalationStatus = "MAX_REACHED"
)

var AllEscalationStatus = []EscalationStatus{
	EscalationStatusPending,
	EscalationStatusResolved,
	EscalationStatusMaxReached,
}

func (e EscalationStatus) IsValid() bool {
	switch e {
	case EscalationStatusPending, EscalationStatusResolved, EscalationStatusMaxReached:
		return true
	}
	return false
}

func (e EscalationStatus) String() string {
	return string(e)
}

func (e *EscalationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EscalationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EscalationStatus", str)
	}
	return nil
}

func (e EscalationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EscalationStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EscalationStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Firewall table types.
type FirewallTable string

const (
	// Packet filtering
	FirewallTableFilter FirewallTable = "FILTER"
	// Network address translation
	FirewallTableNat FirewallTable = "NAT"
	// Packet marking and modification
	FirewallTableMangle FirewallTable = "MANGLE"
	// Raw packet processing
	FirewallTableRaw FirewallTable = "RAW"
)

var AllFirewallTable = []FirewallTable{
	FirewallTableFilter,
	FirewallTableNat,
	FirewallTableMangle,
	FirewallTableRaw,
}

func (e FirewallTable) IsValid() bool {
	switch e {
	case FirewallTableFilter, FirewallTableNat, FirewallTableMangle, FirewallTableRaw:
		return true
	}
	return false
}

func (e FirewallTable) String() string {
	return string(e)
}

func (e *FirewallTable) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FirewallTable(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FirewallTable", str)
	}
	return nil
}

func (e FirewallTable) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FirewallTable) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FirewallTable) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status of a fix application
type FixApplicationStatus string

const (
	// Fix is available but not yet applied
	FixApplicationStatusAvailable FixApplicationStatus = "AVAILABLE"
	// Fix is being applied
	FixApplicationStatusApplying FixApplicationStatus = "APPLYING"
	// Fix was applied successfully
	FixApplicationStatusApplied FixApplicationStatus = "APPLIED"
	// Fix application failed
	FixApplicationStatusFailed FixApplicationStatus = "FAILED"
	// Fix was applied but issue persists
	FixApplicationStatusIssuePersists FixApplicationStatus = "ISSUE_PERSISTS"
)

var AllFixApplicationStatus = []FixApplicationStatus{
	FixApplicationStatusAvailable,
	FixApplicationStatusApplying,
	FixApplicationStatusApplied,
	FixApplicationStatusFailed,
	FixApplicationStatusIssuePersists,
}

func (e FixApplicationStatus) IsValid() bool {
	switch e {
	case FixApplicationStatusAvailable, FixApplicationStatusApplying, FixApplicationStatusApplied, FixApplicationStatusFailed, FixApplicationStatusIssuePersists:
		return true
	}
	return false
}

func (e FixApplicationStatus) String() string {
	return string(e)
}

func (e *FixApplicationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FixApplicationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FixApplicationStatus", str)
	}
	return nil
}

func (e FixApplicationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FixApplicationStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FixApplicationStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Confidence level for a fix suggestion
type FixConfidence string

const (
	// High confidence this fix will resolve the issue
	FixConfidenceHigh FixConfidence = "HIGH"
	// Medium confidence, may resolve the issue
	FixConfidenceMedium FixConfidence = "MEDIUM"
	// Low confidence, worth trying as last resort
	FixConfidenceLow FixConfidence = "LOW"
)

var AllFixConfidence = []FixConfidence{
	FixConfidenceHigh,
	FixConfidenceMedium,
	FixConfidenceLow,
}

func (e FixConfidence) IsValid() bool {
	switch e {
	case FixConfidenceHigh, FixConfidenceMedium, FixConfidenceLow:
		return true
	}
	return false
}

func (e FixConfidence) String() string {
	return string(e)
}

func (e *FixConfidence) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FixConfidence(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FixConfidence", str)
	}
	return nil
}

func (e FixConfidence) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FixConfidence) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FixConfidence) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type FrameTypes string

const (
	FrameTypesAdmitAll                     FrameTypes = "ADMIT_ALL"
	FrameTypesAdmitOnlyUntaggedAndPriority FrameTypes = "ADMIT_ONLY_UNTAGGED_AND_PRIORITY"
	FrameTypesAdmitOnlyVlanTagged          FrameTypes = "ADMIT_ONLY_VLAN_TAGGED"
)

var AllFrameTypes = []FrameTypes{
	FrameTypesAdmitAll,
	FrameTypesAdmitOnlyUntaggedAndPriority,
	FrameTypesAdmitOnlyVlanTagged,
}

func (e FrameTypes) IsValid() bool {
	switch e {
	case FrameTypesAdmitAll, FrameTypesAdmitOnlyUntaggedAndPriority, FrameTypesAdmitOnlyVlanTagged:
		return true
	}
	return false
}

func (e FrameTypes) String() string {
	return string(e)
}

func (e *FrameTypes) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FrameTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FrameTypes", str)
	}
	return nil
}

func (e FrameTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FrameTypes) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FrameTypes) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Gateway process state for monitoring
type GatewayState string

const (
	// Gateway is running normally
	GatewayStateRunning GatewayState = "RUNNING"
	// Gateway is stopped
	GatewayStateStopped GatewayState = "STOPPED"
	// Gateway encountered an error
	GatewayStateError GatewayState = "ERROR"
	// Service does not need a gateway
	GatewayStateNotNeeded GatewayState = "NOT_NEEDED"
)

var AllGatewayState = []GatewayState{
	GatewayStateRunning,
	GatewayStateStopped,
	GatewayStateError,
	GatewayStateNotNeeded,
}

func (e GatewayState) IsValid() bool {
	switch e {
	case GatewayStateRunning, GatewayStateStopped, GatewayStateError, GatewayStateNotNeeded:
		return true
	}
	return false
}

func (e GatewayState) String() string {
	return string(e)
}

func (e *GatewayState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GatewayState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GatewayState", str)
	}
	return nil
}

func (e GatewayState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GatewayState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GatewayState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Gateway runtime status.
type GatewayStatus string

const (
	// Gateway process is stopped
	GatewayStatusStopped GatewayStatus = "STOPPED"
	// Gateway process is starting
	GatewayStatusStarting GatewayStatus = "STARTING"
	// Gateway process is running
	GatewayStatusRunning GatewayStatus = "RUNNING"
	// Gateway process failed to start
	GatewayStatusFailed GatewayStatus = "FAILED"
)

var AllGatewayStatus = []GatewayStatus{
	GatewayStatusStopped,
	GatewayStatusStarting,
	GatewayStatusRunning,
	GatewayStatusFailed,
}

func (e GatewayStatus) IsValid() bool {
	switch e {
	case GatewayStatusStopped, GatewayStatusStarting, GatewayStatusRunning, GatewayStatusFailed:
		return true
	}
	return false
}

func (e GatewayStatus) String() string {
	return string(e)
}

func (e *GatewayStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GatewayStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GatewayStatus", str)
	}
	return nil
}

func (e GatewayStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GatewayStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GatewayStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Gateway type for virtual interface routing.
type GatewayType string

const (
	// No gateway, direct routing
	GatewayTypeNone GatewayType = "NONE"
	// HEV SOCKS5 tunnel gateway
	GatewayTypeHevSocks5Tunnel GatewayType = "HEV_SOCKS5_TUNNEL"
)

var AllGatewayType = []GatewayType{
	GatewayTypeNone,
	GatewayTypeHevSocks5Tunnel,
}

func (e GatewayType) IsValid() bool {
	switch e {
	case GatewayTypeNone, GatewayTypeHevSocks5Tunnel:
		return true
	}
	return false
}

func (e GatewayType) String() string {
	return string(e)
}

func (e *GatewayType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GatewayType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GatewayType", str)
	}
	return nil
}

func (e GatewayType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GatewayType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GatewayType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Health check status
type HealthCheckStatus string

const (
	// Target is reachable (healthy)
	HealthCheckStatusHealthy HealthCheckStatus = "HEALTHY"
	// Target is unreachable (unhealthy)
	HealthCheckStatusUnhealthy HealthCheckStatus = "UNHEALTHY"
	// Health check is disabled
	HealthCheckStatusDisabled HealthCheckStatus = "DISABLED"
	// Health check is starting
	HealthCheckStatusUnknown HealthCheckStatus = "UNKNOWN"
)

var AllHealthCheckStatus = []HealthCheckStatus{
	HealthCheckStatusHealthy,
	HealthCheckStatusUnhealthy,
	HealthCheckStatusDisabled,
	HealthCheckStatusUnknown,
}

func (e HealthCheckStatus) IsValid() bool {
	switch e {
	case HealthCheckStatusHealthy, HealthCheckStatusUnhealthy, HealthCheckStatusDisabled, HealthCheckStatusUnknown:
		return true
	}
	return false
}

func (e HealthCheckStatus) String() string {
	return string(e)
}

func (e *HealthCheckStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthCheckStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthCheckStatus", str)
	}
	return nil
}

func (e HealthCheckStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HealthCheckStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HealthCheckStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Connection status from health probe checks
type HealthConnectionState string

const (
	HealthConnectionStateConnected  HealthConnectionState = "CONNECTED"
	HealthConnectionStateConnecting HealthConnectionState = "CONNECTING"
	HealthConnectionStateFailed     HealthConnectionState = "FAILED"
)

var AllHealthConnectionState = []HealthConnectionState{
	HealthConnectionStateConnected,
	HealthConnectionStateConnecting,
	HealthConnectionStateFailed,
}

func (e HealthConnectionState) IsValid() bool {
	switch e {
	case HealthConnectionStateConnected, HealthConnectionStateConnecting, HealthConnectionStateFailed:
		return true
	}
	return false
}

func (e HealthConnectionState) String() string {
	return string(e)
}

func (e *HealthConnectionState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthConnectionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthConnectionState", str)
	}
	return nil
}

func (e HealthConnectionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HealthConnectionState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HealthConnectionState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status of a single hop in a traceroute
type HopStatus string

const (
	// Hop responded successfully
	HopStatusSuccess HopStatus = "SUCCESS"
	// Hop did not respond (timeout)
	HopStatusTimeout HopStatus = "TIMEOUT"
	// Destination unreachable at this hop
	HopStatusUnreachable HopStatus = "UNREACHABLE"
	// Access prohibited (firewall/ACL)
	HopStatusProhibited HopStatus = "PROHIBITED"
)

var AllHopStatus = []HopStatus{
	HopStatusSuccess,
	HopStatusTimeout,
	HopStatusUnreachable,
	HopStatusProhibited,
}

func (e HopStatus) IsValid() bool {
	switch e {
	case HopStatusSuccess, HopStatusTimeout, HopStatusUnreachable, HopStatusProhibited:
		return true
	}
	return false
}

func (e HopStatus) String() string {
	return string(e)
}

func (e *HopStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HopStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HopStatus", str)
	}
	return nil
}

func (e HopStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HopStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HopStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Health status enumeration for service instances
type InstanceHealthState string

const (
	InstanceHealthStateHealthy   InstanceHealthState = "HEALTHY"
	InstanceHealthStateUnhealthy InstanceHealthState = "UNHEALTHY"
	InstanceHealthStateUnknown   InstanceHealthState = "UNKNOWN"
	InstanceHealthStateChecking  InstanceHealthState = "CHECKING"
)

var AllInstanceHealthState = []InstanceHealthState{
	InstanceHealthStateHealthy,
	InstanceHealthStateUnhealthy,
	InstanceHealthStateUnknown,
	InstanceHealthStateChecking,
}

func (e InstanceHealthState) IsValid() bool {
	switch e {
	case InstanceHealthStateHealthy, InstanceHealthStateUnhealthy, InstanceHealthStateUnknown, InstanceHealthStateChecking:
		return true
	}
	return false
}

func (e InstanceHealthState) String() string {
	return string(e)
}

func (e *InstanceHealthState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstanceHealthState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstanceHealthState", str)
	}
	return nil
}

func (e InstanceHealthState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InstanceHealthState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InstanceHealthState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Operational status of a network interface
type InterfaceStatus string

const (
	// Interface is up and running
	InterfaceStatusUp InterfaceStatus = "UP"
	// Interface is down
	InterfaceStatusDown InterfaceStatus = "DOWN"
	// Interface is disabled
	InterfaceStatusDisabled InterfaceStatus = "DISABLED"
	// Status unknown or error
	InterfaceStatusUnknown InterfaceStatus = "UNKNOWN"
)

var AllInterfaceStatus = []InterfaceStatus{
	InterfaceStatusUp,
	InterfaceStatusDown,
	InterfaceStatusDisabled,
	InterfaceStatusUnknown,
}

func (e InterfaceStatus) IsValid() bool {
	switch e {
	case InterfaceStatusUp, InterfaceStatusDown, InterfaceStatusDisabled, InterfaceStatusUnknown:
		return true
	}
	return false
}

func (e InterfaceStatus) String() string {
	return string(e)
}

func (e *InterfaceStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfaceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InterfaceStatus", str)
	}
	return nil
}

func (e InterfaceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InterfaceStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InterfaceStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Types of network interfaces
type InterfaceType string

const (
	InterfaceTypeEthernet InterfaceType = "ETHERNET"
	InterfaceTypeVlan     InterfaceType = "VLAN"
	InterfaceTypeBridge   InterfaceType = "BRIDGE"
	InterfaceTypeWireless InterfaceType = "WIRELESS"
	InterfaceTypeTunnel   InterfaceType = "TUNNEL"
	InterfaceTypePpp      InterfaceType = "PPP"
	InterfaceTypeBonding  InterfaceType = "BONDING"
	InterfaceTypeLoopback InterfaceType = "LOOPBACK"
	InterfaceTypeVirtual  InterfaceType = "VIRTUAL"
	InterfaceTypeOther    InterfaceType = "OTHER"
)

var AllInterfaceType = []InterfaceType{
	InterfaceTypeEthernet,
	InterfaceTypeVlan,
	InterfaceTypeBridge,
	InterfaceTypeWireless,
	InterfaceTypeTunnel,
	InterfaceTypePpp,
	InterfaceTypeBonding,
	InterfaceTypeLoopback,
	InterfaceTypeVirtual,
	InterfaceTypeOther,
}

func (e InterfaceType) IsValid() bool {
	switch e {
	case InterfaceTypeEthernet, InterfaceTypeVlan, InterfaceTypeBridge, InterfaceTypeWireless, InterfaceTypeTunnel, InterfaceTypePpp, InterfaceTypeBonding, InterfaceTypeLoopback, InterfaceTypeVirtual, InterfaceTypeOther:
		return true
	}
	return false
}

func (e InterfaceType) String() string {
	return string(e)
}

func (e *InterfaceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InterfaceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InterfaceType", str)
	}
	return nil
}

func (e InterfaceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *InterfaceType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e InterfaceType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of IP address conflict
type IPConflictType string

const (
	// Exact IP address match on different interface
	IPConflictTypeExact IPConflictType = "EXACT"
	// IP addresses are in overlapping subnets
	IPConflictTypeSubnetOverlap IPConflictType = "SUBNET_OVERLAP"
	// IP is the broadcast address of another subnet
	IPConflictTypeBroadcast IPConflictType = "BROADCAST"
	// IP is the network address of another subnet
	IPConflictTypeNetwork IPConflictType = "NETWORK"
)

var AllIPConflictType = []IPConflictType{
	IPConflictTypeExact,
	IPConflictTypeSubnetOverlap,
	IPConflictTypeBroadcast,
	IPConflictTypeNetwork,
}

func (e IPConflictType) IsValid() bool {
	switch e {
	case IPConflictTypeExact, IPConflictTypeSubnetOverlap, IPConflictTypeBroadcast, IPConflictTypeNetwork:
		return true
	}
	return false
}

func (e IPConflictType) String() string {
	return string(e)
}

func (e *IPConflictType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IPConflictType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IpConflictType", str)
	}
	return nil
}

func (e IPConflictType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IPConflictType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IPConflictType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Severity level of an isolation violation.
type IsolationSeverity string

const (
	// Critical error that blocks instance start
	IsolationSeverityError IsolationSeverity = "ERROR"
	// Warning that is logged but allows instance start
	IsolationSeverityWarning IsolationSeverity = "WARNING"
	// Informational message
	IsolationSeverityInfo IsolationSeverity = "INFO"
)

var AllIsolationSeverity = []IsolationSeverity{
	IsolationSeverityError,
	IsolationSeverityWarning,
	IsolationSeverityInfo,
}

func (e IsolationSeverity) IsValid() bool {
	switch e {
	case IsolationSeverityError, IsolationSeverityWarning, IsolationSeverityInfo:
		return true
	}
	return false
}

func (e IsolationSeverity) String() string {
	return string(e)
}

func (e *IsolationSeverity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IsolationSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IsolationSeverity", str)
	}
	return nil
}

func (e IsolationSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *IsolationSeverity) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e IsolationSeverity) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Job status for async traceroute execution
type JobStatus string

const (
	// Job has been created
	JobStatusStarted JobStatus = "STARTED"
	// Job is currently running
	JobStatusRunning JobStatus = "RUNNING"
	// Job completed successfully
	JobStatusComplete JobStatus = "COMPLETE"
	// Job was cancelled by user
	JobStatusCancelled JobStatus = "CANCELLED"
	// Job encountered an error
	JobStatusError JobStatus = "ERROR"
)

var AllJobStatus = []JobStatus{
	JobStatusStarted,
	JobStatusRunning,
	JobStatusComplete,
	JobStatusCancelled,
	JobStatusError,
}

func (e JobStatus) IsValid() bool {
	switch e {
	case JobStatusStarted, JobStatusRunning, JobStatusComplete, JobStatusCancelled, JobStatusError:
		return true
	}
	return false
}

func (e JobStatus) String() string {
	return string(e)
}

func (e *JobStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobStatus", str)
	}
	return nil
}

func (e JobStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JobStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JobStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Kill switch behavior when any hop in a chain fails.
type KillSwitchMode string

const (
	// Block all traffic from the device
	KillSwitchModeBlockAll KillSwitchMode = "BLOCK_ALL"
	// Fall back to a specified service
	KillSwitchModeFallbackService KillSwitchMode = "FALLBACK_SERVICE"
	// Allow direct internet access (no VPN)
	KillSwitchModeAllowDirect KillSwitchMode = "ALLOW_DIRECT"
)

var AllKillSwitchMode = []KillSwitchMode{
	KillSwitchModeBlockAll,
	KillSwitchModeFallbackService,
	KillSwitchModeAllowDirect,
}

func (e KillSwitchMode) IsValid() bool {
	switch e {
	case KillSwitchModeBlockAll, KillSwitchModeFallbackService, KillSwitchModeAllowDirect:
		return true
	}
	return false
}

func (e KillSwitchMode) String() string {
	return string(e)
}

func (e *KillSwitchMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KillSwitchMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KillSwitchMode", str)
	}
	return nil
}

func (e KillSwitchMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *KillSwitchMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e KillSwitchMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Protocol for knock port.
type KnockProtocol string

const (
	// TCP only
	KnockProtocolTCP KnockProtocol = "TCP"
	// UDP only
	KnockProtocolUDP KnockProtocol = "UDP"
	// Both TCP and UDP
	KnockProtocolBoth KnockProtocol = "BOTH"
)

var AllKnockProtocol = []KnockProtocol{
	KnockProtocolTCP,
	KnockProtocolUDP,
	KnockProtocolBoth,
}

func (e KnockProtocol) IsValid() bool {
	switch e {
	case KnockProtocolTCP, KnockProtocolUDP, KnockProtocolBoth:
		return true
	}
	return false
}

func (e KnockProtocol) String() string {
	return string(e)
}

func (e *KnockProtocol) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KnockProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KnockProtocol", str)
	}
	return nil
}

func (e KnockProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *KnockProtocol) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e KnockProtocol) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status of knock attempt.
type KnockStatus string

const (
	// All ports hit correctly, access granted
	KnockStatusSuccess KnockStatus = "SUCCESS"
	// Wrong port order
	KnockStatusFailed KnockStatus = "FAILED"
	// Some ports hit, sequence incomplete
	KnockStatusPartial KnockStatus = "PARTIAL"
	// Time between knocks exceeded
	KnockStatusTimeout KnockStatus = "TIMEOUT"
)

var AllKnockStatus = []KnockStatus{
	KnockStatusSuccess,
	KnockStatusFailed,
	KnockStatusPartial,
	KnockStatusTimeout,
}

func (e KnockStatus) IsValid() bool {
	switch e {
	case KnockStatusSuccess, KnockStatusFailed, KnockStatusPartial, KnockStatusTimeout:
		return true
	}
	return false
}

func (e KnockStatus) String() string {
	return string(e)
}

func (e *KnockStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = KnockStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid KnockStatus", str)
	}
	return nil
}

func (e KnockStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *KnockStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e KnockStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Log level for service log entries.
type LogLevel string

const (
	// Debug-level log
	LogLevelDebug LogLevel = "DEBUG"
	// Informational log
	LogLevelInfo LogLevel = "INFO"
	// Warning log
	LogLevelWarn LogLevel = "WARN"
	// Error log
	LogLevelError LogLevel = "ERROR"
	// Unknown/unparsed log level
	LogLevelUnknown LogLevel = "UNKNOWN"
)

var AllLogLevel = []LogLevel{
	LogLevelDebug,
	LogLevelInfo,
	LogLevelWarn,
	LogLevelError,
	LogLevelUnknown,
}

func (e LogLevel) IsValid() bool {
	switch e {
	case LogLevelDebug, LogLevelInfo, LogLevelWarn, LogLevelError, LogLevelUnknown:
		return true
	}
	return false
}

func (e LogLevel) String() string {
	return string(e)
}

func (e *LogLevel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LogLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LogLevel", str)
	}
	return nil
}

func (e LogLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *LogLevel) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e LogLevel) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Direction of traffic to mirror
type MirrorDirection string

const (
	// Mirror only ingress (incoming) traffic
	MirrorDirectionIngress MirrorDirection = "INGRESS"
	// Mirror only egress (outgoing) traffic
	MirrorDirectionEgress MirrorDirection = "EGRESS"
	// Mirror both ingress and egress traffic
	MirrorDirectionBoth MirrorDirection = "BOTH"
)

var AllMirrorDirection = []MirrorDirection{
	MirrorDirectionIngress,
	MirrorDirectionEgress,
	MirrorDirectionBoth,
}

func (e MirrorDirection) IsValid() bool {
	switch e {
	case MirrorDirectionIngress, MirrorDirectionEgress, MirrorDirectionBoth:
		return true
	}
	return false
}

func (e MirrorDirection) String() string {
	return string(e)
}

func (e *MirrorDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MirrorDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MirrorDirection", str)
	}
	return nil
}

func (e MirrorDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MirrorDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MirrorDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Multi-link strategy enum
type MultiLinkStrategy string

const (
	// Failover - use secondary only if primary fails
	MultiLinkStrategyFailover MultiLinkStrategy = "FAILOVER"
	// PCC (Per-Connection-Classifier) - distribute per connection
	MultiLinkStrategyPcc MultiLinkStrategy = "PCC"
	// NTH - distribute per Nth connection
	MultiLinkStrategyNth MultiLinkStrategy = "NTH"
	// ECMP (Equal Cost Multi-Path) - true load balancing
	MultiLinkStrategyEcmp MultiLinkStrategy = "ECMP"
)

var AllMultiLinkStrategy = []MultiLinkStrategy{
	MultiLinkStrategyFailover,
	MultiLinkStrategyPcc,
	MultiLinkStrategyNth,
	MultiLinkStrategyEcmp,
}

func (e MultiLinkStrategy) IsValid() bool {
	switch e {
	case MultiLinkStrategyFailover, MultiLinkStrategyPcc, MultiLinkStrategyNth, MultiLinkStrategyEcmp:
		return true
	}
	return false
}

func (e MultiLinkStrategy) String() string {
	return string(e)
}

func (e *MultiLinkStrategy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MultiLinkStrategy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MultiLinkStrategy", str)
	}
	return nil
}

func (e MultiLinkStrategy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MultiLinkStrategy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MultiLinkStrategy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// NAT action types for firewall NAT rules.
type NatAction string

const (
	// Masquerade (dynamic source NAT)
	NatActionMasquerade NatAction = "MASQUERADE"
	// Destination NAT (port forwarding)
	NatActionDstNat NatAction = "DST_NAT"
	// Source NAT (static mapping)
	NatActionSrcNat NatAction = "SRC_NAT"
	// Redirect to different port
	NatActionRedirect NatAction = "REDIRECT"
	// Network mapping
	NatActionNetmap NatAction = "NETMAP"
	// Use same IP
	NatActionSame NatAction = "SAME"
	// Accept packet
	NatActionAccept NatAction = "ACCEPT"
	// Drop packet
	NatActionDrop NatAction = "DROP"
	// Jump to different chain
	NatActionJump NatAction = "JUMP"
	// Return to parent chain
	NatActionReturn NatAction = "RETURN"
	// Log packet
	NatActionLog NatAction = "LOG"
	// Pass through without action
	NatActionPassthrough NatAction = "PASSTHROUGH"
)

var AllNatAction = []NatAction{
	NatActionMasquerade,
	NatActionDstNat,
	NatActionSrcNat,
	NatActionRedirect,
	NatActionNetmap,
	NatActionSame,
	NatActionAccept,
	NatActionDrop,
	NatActionJump,
	NatActionReturn,
	NatActionLog,
	NatActionPassthrough,
}

func (e NatAction) IsValid() bool {
	switch e {
	case NatActionMasquerade, NatActionDstNat, NatActionSrcNat, NatActionRedirect, NatActionNetmap, NatActionSame, NatActionAccept, NatActionDrop, NatActionJump, NatActionReturn, NatActionLog, NatActionPassthrough:
		return true
	}
	return false
}

func (e NatAction) String() string {
	return string(e)
}

func (e *NatAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NatAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NatAction", str)
	}
	return nil
}

func (e NatAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NatAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NatAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// NAT chain types (srcnat for source NAT, dstnat for destination NAT).
type NatChain string

const (
	// Source NAT (outgoing traffic)
	NatChainSrcnat NatChain = "SRCNAT"
	// Destination NAT (incoming traffic)
	NatChainDstnat NatChain = "DSTNAT"
)

var AllNatChain = []NatChain{
	NatChainSrcnat,
	NatChainDstnat,
}

func (e NatChain) IsValid() bool {
	switch e {
	case NatChainSrcnat, NatChainDstnat:
		return true
	}
	return false
}

func (e NatChain) String() string {
	return string(e)
}

func (e *NatChain) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NatChain(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NatChain", str)
	}
	return nil
}

func (e NatChain) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NatChain) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NatChain) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Notification channel types
type NotificationChannel string

const (
	// Email notifications
	NotificationChannelEmail NotificationChannel = "EMAIL"
	// Telegram notifications
	NotificationChannelTelegram NotificationChannel = "TELEGRAM"
	// Pushover notifications
	NotificationChannelPushover NotificationChannel = "PUSHOVER"
	// Webhook notifications
	NotificationChannelWebhook NotificationChannel = "WEBHOOK"
	// Ntfy.sh notifications
	NotificationChannelNtfy NotificationChannel = "NTFY"
	// In-app notifications
	NotificationChannelInapp NotificationChannel = "INAPP"
)

var AllNotificationChannel = []NotificationChannel{
	NotificationChannelEmail,
	NotificationChannelTelegram,
	NotificationChannelPushover,
	NotificationChannelWebhook,
	NotificationChannelNtfy,
	NotificationChannelInapp,
}

func (e NotificationChannel) IsValid() bool {
	switch e {
	case NotificationChannelEmail, NotificationChannelTelegram, NotificationChannelPushover, NotificationChannelWebhook, NotificationChannelNtfy, NotificationChannelInapp:
		return true
	}
	return false
}

func (e NotificationChannel) String() string {
	return string(e)
}

func (e *NotificationChannel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationChannel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationChannel", str)
	}
	return nil
}

func (e NotificationChannel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NotificationChannel) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NotificationChannel) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Notification delivery status
type NotificationStatus string

const (
	// Delivery pending
	NotificationStatusPending NotificationStatus = "PENDING"
	// Successfully delivered
	NotificationStatusSuccess NotificationStatus = "SUCCESS"
	// Delivery failed
	NotificationStatusFailed NotificationStatus = "FAILED"
	// Retrying after failure
	NotificationStatusRetrying NotificationStatus = "RETRYING"
)

var AllNotificationStatus = []NotificationStatus{
	NotificationStatusPending,
	NotificationStatusSuccess,
	NotificationStatusFailed,
	NotificationStatusRetrying,
}

func (e NotificationStatus) IsValid() bool {
	switch e {
	case NotificationStatusPending, NotificationStatusSuccess, NotificationStatusFailed, NotificationStatusRetrying:
		return true
	}
	return false
}

func (e NotificationStatus) String() string {
	return string(e)
}

func (e *NotificationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NotificationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NotificationStatus", str)
	}
	return nil
}

func (e NotificationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *NotificationStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e NotificationStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status of a port forward configuration.
type PortForwardStatus string

const (
	// Port forward is active and working
	PortForwardStatusActive PortForwardStatus = "ACTIVE"
	// Port forward is disabled
	PortForwardStatusDisabled PortForwardStatus = "DISABLED"
	// Port forward has errors or misconfiguration
	PortForwardStatusError PortForwardStatus = "ERROR"
	// Port forward is partially configured (missing rules)
	PortForwardStatusIncomplete PortForwardStatus = "INCOMPLETE"
)

var AllPortForwardStatus = []PortForwardStatus{
	PortForwardStatusActive,
	PortForwardStatusDisabled,
	PortForwardStatusError,
	PortForwardStatusIncomplete,
}

func (e PortForwardStatus) IsValid() bool {
	switch e {
	case PortForwardStatusActive, PortForwardStatusDisabled, PortForwardStatusError, PortForwardStatusIncomplete:
		return true
	}
	return false
}

func (e PortForwardStatus) String() string {
	return string(e)
}

func (e *PortForwardStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PortForwardStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PortForwardStatus", str)
	}
	return nil
}

func (e PortForwardStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PortForwardStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PortForwardStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Port mode for VLAN configuration
type PortMode string

const (
	// Trunk port (carries multiple VLANs with tagging)
	PortModeTrunk PortMode = "TRUNK"
	// Access port (single VLAN, untagged)
	PortModeAccess PortMode = "ACCESS"
)

var AllPortMode = []PortMode{
	PortModeTrunk,
	PortModeAccess,
}

func (e PortMode) IsValid() bool {
	switch e {
	case PortModeTrunk, PortModeAccess:
		return true
	}
	return false
}

func (e PortMode) String() string {
	return string(e)
}

func (e *PortMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PortMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PortMode", str)
	}
	return nil
}

func (e PortMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PortMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PortMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Transport protocol for port allocations.
type PortProtocol string

const (
	// TCP protocol
	PortProtocolTCP PortProtocol = "TCP"
	// UDP protocol
	PortProtocolUDP PortProtocol = "UDP"
)

var AllPortProtocol = []PortProtocol{
	PortProtocolTCP,
	PortProtocolUDP,
}

func (e PortProtocol) IsValid() bool {
	switch e {
	case PortProtocolTCP, PortProtocolUDP:
		return true
	}
	return false
}

func (e PortProtocol) String() string {
	return string(e)
}

func (e *PortProtocol) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PortProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PortProtocol", str)
	}
	return nil
}

func (e PortProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PortProtocol) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PortProtocol) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Protocol used for router communication
type Protocol string

const (
	// REST API protocol (RouterOS 7.1+)
	ProtocolRest Protocol = "REST"
	// Binary API protocol (port 8728)
	ProtocolAPI Protocol = "API"
	// TLS-encrypted binary API (port 8729)
	ProtocolAPISsl Protocol = "API_SSL"
	// SSH protocol (port 22)
	ProtocolSSH Protocol = "SSH"
	// Telnet protocol (port 23)
	ProtocolTelnet Protocol = "TELNET"
)

var AllProtocol = []Protocol{
	ProtocolRest,
	ProtocolAPI,
	ProtocolAPISsl,
	ProtocolSSH,
	ProtocolTelnet,
}

func (e Protocol) IsValid() bool {
	switch e {
	case ProtocolRest, ProtocolAPI, ProtocolAPISsl, ProtocolSSH, ProtocolTelnet:
		return true
	}
	return false
}

func (e Protocol) String() string {
	return string(e)
}

func (e *Protocol) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Protocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Protocol", str)
	}
	return nil
}

func (e Protocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Protocol) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Protocol) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// User preference for which protocol to use when connecting to a router.
// AUTO will try protocols in the recommended fallback order.
type ProtocolPreference string

const (
	// Automatically detect best protocol (REST -> API -> API_SSL -> SSH -> Telnet)
	ProtocolPreferenceAuto ProtocolPreference = "AUTO"
	// Force REST API protocol (RouterOS 7.1+)
	ProtocolPreferenceRest ProtocolPreference = "REST"
	// Force Binary API protocol (port 8728)
	ProtocolPreferenceAPI ProtocolPreference = "API"
	// Force TLS-encrypted binary API (port 8729)
	ProtocolPreferenceAPISsl ProtocolPreference = "API_SSL"
	// Force SSH protocol (port 22)
	ProtocolPreferenceSSH ProtocolPreference = "SSH"
	// Force Telnet protocol (port 23, insecure - use only as last resort)
	ProtocolPreferenceTelnet ProtocolPreference = "TELNET"
)

var AllProtocolPreference = []ProtocolPreference{
	ProtocolPreferenceAuto,
	ProtocolPreferenceRest,
	ProtocolPreferenceAPI,
	ProtocolPreferenceAPISsl,
	ProtocolPreferenceSSH,
	ProtocolPreferenceTelnet,
}

func (e ProtocolPreference) IsValid() bool {
	switch e {
	case ProtocolPreferenceAuto, ProtocolPreferenceRest, ProtocolPreferenceAPI, ProtocolPreferenceAPISsl, ProtocolPreferenceSSH, ProtocolPreferenceTelnet:
		return true
	}
	return false
}

func (e ProtocolPreference) String() string {
	return string(e)
}

func (e *ProtocolPreference) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProtocolPreference(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProtocolPreference", str)
	}
	return nil
}

func (e ProtocolPreference) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProtocolPreference) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProtocolPreference) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status of provisioning session apply operation
type ProvisioningApplyStatus string

const (
	// Session in draft state - not ready for application
	ProvisioningApplyStatusDraft ProvisioningApplyStatus = "DRAFT"
	// Validating all resources and configurations
	ProvisioningApplyStatusValidating ProvisioningApplyStatus = "VALIDATING"
	// All validations passed - ready to apply
	ProvisioningApplyStatusValidated ProvisioningApplyStatus = "VALIDATED"
	// Applying configuration changes to router
	ProvisioningApplyStatusApplying ProvisioningApplyStatus = "APPLYING"
	// Configuration successfully applied to router
	ProvisioningApplyStatusApplied ProvisioningApplyStatus = "APPLIED"
	// Application failed - rollback may have occurred
	ProvisioningApplyStatusFailed ProvisioningApplyStatus = "FAILED"
)

var AllProvisioningApplyStatus = []ProvisioningApplyStatus{
	ProvisioningApplyStatusDraft,
	ProvisioningApplyStatusValidating,
	ProvisioningApplyStatusValidated,
	ProvisioningApplyStatusApplying,
	ProvisioningApplyStatusApplied,
	ProvisioningApplyStatusFailed,
}

func (e ProvisioningApplyStatus) IsValid() bool {
	switch e {
	case ProvisioningApplyStatusDraft, ProvisioningApplyStatusValidating, ProvisioningApplyStatusValidated, ProvisioningApplyStatusApplying, ProvisioningApplyStatusApplied, ProvisioningApplyStatusFailed:
		return true
	}
	return false
}

func (e ProvisioningApplyStatus) String() string {
	return string(e)
}

func (e *ProvisioningApplyStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProvisioningApplyStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProvisioningApplyStatus", str)
	}
	return nil
}

func (e ProvisioningApplyStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProvisioningApplyStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProvisioningApplyStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Target firmware for provisioning
type ProvisioningFirmware string

const (
	// MikroTik RouterOS
	ProvisioningFirmwareMikrotik ProvisioningFirmware = "MIKROTIK"
	// OpenWRT
	ProvisioningFirmwareOpenwrt ProvisioningFirmware = "OPENWRT"
)

var AllProvisioningFirmware = []ProvisioningFirmware{
	ProvisioningFirmwareMikrotik,
	ProvisioningFirmwareOpenwrt,
}

func (e ProvisioningFirmware) IsValid() bool {
	switch e {
	case ProvisioningFirmwareMikrotik, ProvisioningFirmwareOpenwrt:
		return true
	}
	return false
}

func (e ProvisioningFirmware) String() string {
	return string(e)
}

func (e *ProvisioningFirmware) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProvisioningFirmware(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProvisioningFirmware", str)
	}
	return nil
}

func (e ProvisioningFirmware) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProvisioningFirmware) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProvisioningFirmware) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Provisioning mode - determines the setup workflow complexity
type ProvisioningMode string

const (
	// EASY: Guided wizard for basic setup (WAN, LAN, optional extra features)
	ProvisioningModeEasy ProvisioningMode = "EASY"
	// ADVANCE: Full control over all provisioning parameters and resource config
	ProvisioningModeAdvance ProvisioningMode = "ADVANCE"
)

var AllProvisioningMode = []ProvisioningMode{
	ProvisioningModeEasy,
	ProvisioningModeAdvance,
}

func (e ProvisioningMode) IsValid() bool {
	switch e {
	case ProvisioningModeEasy, ProvisioningModeAdvance:
		return true
	}
	return false
}

func (e ProvisioningMode) String() string {
	return string(e)
}

func (e *ProvisioningMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProvisioningMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProvisioningMode", str)
	}
	return nil
}

func (e ProvisioningMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProvisioningMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProvisioningMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Router operational mode for provisioning
type ProvisioningRouterMode string

const (
	// Access Point mode - router provides WiFi, acts as network hub
	ProvisioningRouterModeApMode ProvisioningRouterMode = "AP_MODE"
	// Trunk/Core mode - high-performance router backbone
	ProvisioningRouterModeTrunkMode ProvisioningRouterMode = "TRUNK_MODE"
)

var AllProvisioningRouterMode = []ProvisioningRouterMode{
	ProvisioningRouterModeApMode,
	ProvisioningRouterModeTrunkMode,
}

func (e ProvisioningRouterMode) IsValid() bool {
	switch e {
	case ProvisioningRouterModeApMode, ProvisioningRouterModeTrunkMode:
		return true
	}
	return false
}

func (e ProvisioningRouterMode) String() string {
	return string(e)
}

func (e *ProvisioningRouterMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProvisioningRouterMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProvisioningRouterMode", str)
	}
	return nil
}

func (e ProvisioningRouterMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProvisioningRouterMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProvisioningRouterMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// WAN link type for provisioning context
type ProvisioningWANLinkType string

const (
	// Domestic ISP link (residential, small business)
	ProvisioningWANLinkTypeDomestic ProvisioningWANLinkType = "DOMESTIC"
	// Foreign/International link with special routing needs
	ProvisioningWANLinkTypeForeign ProvisioningWANLinkType = "FOREIGN"
	// Supports both domestic and foreign link configurations
	ProvisioningWANLinkTypeBoth ProvisioningWANLinkType = "BOTH"
)

var AllProvisioningWANLinkType = []ProvisioningWANLinkType{
	ProvisioningWANLinkTypeDomestic,
	ProvisioningWANLinkTypeForeign,
	ProvisioningWANLinkTypeBoth,
}

func (e ProvisioningWANLinkType) IsValid() bool {
	switch e {
	case ProvisioningWANLinkTypeDomestic, ProvisioningWANLinkTypeForeign, ProvisioningWANLinkTypeBoth:
		return true
	}
	return false
}

func (e ProvisioningWANLinkType) String() string {
	return string(e)
}

func (e *ProvisioningWANLinkType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProvisioningWANLinkType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProvisioningWANLinkType", str)
	}
	return nil
}

func (e ProvisioningWANLinkType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProvisioningWANLinkType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProvisioningWANLinkType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Action to take when traffic quota is reached.
type QuotaAction string

const (
	// Log a warning but continue allowing traffic
	QuotaActionLogOnly QuotaAction = "LOG_ONLY"
	// Send alert notification to user
	QuotaActionAlert QuotaAction = "ALERT"
	// Stop the service instance to prevent further traffic
	QuotaActionStopService QuotaAction = "STOP_SERVICE"
	// Throttle bandwidth to a lower speed
	QuotaActionThrottle QuotaAction = "THROTTLE"
)

var AllQuotaAction = []QuotaAction{
	QuotaActionLogOnly,
	QuotaActionAlert,
	QuotaActionStopService,
	QuotaActionThrottle,
}

func (e QuotaAction) IsValid() bool {
	switch e {
	case QuotaActionLogOnly, QuotaActionAlert, QuotaActionStopService, QuotaActionThrottle:
		return true
	}
	return false
}

func (e QuotaAction) String() string {
	return string(e)
}

func (e *QuotaAction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QuotaAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QuotaAction", str)
	}
	return nil
}

func (e QuotaAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *QuotaAction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e QuotaAction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Quota period for traffic limits.
type QuotaPeriod string

const (
	// Reset daily at midnight
	QuotaPeriodDaily QuotaPeriod = "DAILY"
	// Reset weekly on Sunday at midnight
	QuotaPeriodWeekly QuotaPeriod = "WEEKLY"
	// Reset monthly on the 1st at midnight
	QuotaPeriodMonthly QuotaPeriod = "MONTHLY"
)

var AllQuotaPeriod = []QuotaPeriod{
	QuotaPeriodDaily,
	QuotaPeriodWeekly,
	QuotaPeriodMonthly,
}

func (e QuotaPeriod) IsValid() bool {
	switch e {
	case QuotaPeriodDaily, QuotaPeriodWeekly, QuotaPeriodMonthly:
		return true
	}
	return false
}

func (e QuotaPeriod) String() string {
	return string(e)
}

func (e *QuotaPeriod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QuotaPeriod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QuotaPeriod", str)
	}
	return nil
}

func (e QuotaPeriod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *QuotaPeriod) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e QuotaPeriod) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Categories of managed resources
type ResourceCategory string

const (
	// Network topology: WAN Links, LAN Networks, VLANs
	ResourceCategoryNetwork ResourceCategory = "NETWORK"
	// VPN connectivity: WireGuard, OpenVPN, IPsec
	ResourceCategoryVpn ResourceCategory = "VPN"
	// System infrastructure: Certificates, NTP, DDNS
	ResourceCategoryInfrastructure ResourceCategory = "INFRASTRUCTURE"
	// Application-level: Port Forwarding, Game Rules
	ResourceCategoryApplication ResourceCategory = "APPLICATION"
	// Marketplace features: Tor, AdGuard, sing-box
	ResourceCategoryFeature ResourceCategory = "FEATURE"
	// Community extensions: Third-party plugins
	ResourceCategoryPlugin ResourceCategory = "PLUGIN"
)

var AllResourceCategory = []ResourceCategory{
	ResourceCategoryNetwork,
	ResourceCategoryVpn,
	ResourceCategoryInfrastructure,
	ResourceCategoryApplication,
	ResourceCategoryFeature,
	ResourceCategoryPlugin,
}

func (e ResourceCategory) IsValid() bool {
	switch e {
	case ResourceCategoryNetwork, ResourceCategoryVpn, ResourceCategoryInfrastructure, ResourceCategoryApplication, ResourceCategoryFeature, ResourceCategoryPlugin:
		return true
	}
	return false
}

func (e ResourceCategory) String() string {
	return string(e)
}

func (e *ResourceCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceCategory", str)
	}
	return nil
}

func (e ResourceCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResourceCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResourceCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Impact level for affected resources
type ResourceImpact string

const (
	// Resource will be modified
	ResourceImpactModified ResourceImpact = "MODIFIED"
	// Resource will be disabled
	ResourceImpactDisabled ResourceImpact = "DISABLED"
	// Resource will be removed
	ResourceImpactRemoved ResourceImpact = "REMOVED"
	// Connections will be dropped
	ResourceImpactConnectionDrop ResourceImpact = "CONNECTION_DROP"
)

var AllResourceImpact = []ResourceImpact{
	ResourceImpactModified,
	ResourceImpactDisabled,
	ResourceImpactRemoved,
	ResourceImpactConnectionDrop,
}

func (e ResourceImpact) IsValid() bool {
	switch e {
	case ResourceImpactModified, ResourceImpactDisabled, ResourceImpactRemoved, ResourceImpactConnectionDrop:
		return true
	}
	return false
}

func (e ResourceImpact) String() string {
	return string(e)
}

func (e *ResourceImpact) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceImpact(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceImpact", str)
	}
	return nil
}

func (e ResourceImpact) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResourceImpact) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResourceImpact) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Selectable resource layers for optimized fetching
type ResourceLayer string

const (
	ResourceLayerConfiguration ResourceLayer = "CONFIGURATION"
	ResourceLayerValidation    ResourceLayer = "VALIDATION"
	ResourceLayerDeployment    ResourceLayer = "DEPLOYMENT"
	ResourceLayerRuntime       ResourceLayer = "RUNTIME"
	ResourceLayerTelemetry     ResourceLayer = "TELEMETRY"
	ResourceLayerMetadata      ResourceLayer = "METADATA"
	ResourceLayerRelationships ResourceLayer = "RELATIONSHIPS"
	ResourceLayerPlatform      ResourceLayer = "PLATFORM"
)

var AllResourceLayer = []ResourceLayer{
	ResourceLayerConfiguration,
	ResourceLayerValidation,
	ResourceLayerDeployment,
	ResourceLayerRuntime,
	ResourceLayerTelemetry,
	ResourceLayerMetadata,
	ResourceLayerRelationships,
	ResourceLayerPlatform,
}

func (e ResourceLayer) IsValid() bool {
	switch e {
	case ResourceLayerConfiguration, ResourceLayerValidation, ResourceLayerDeployment, ResourceLayerRuntime, ResourceLayerTelemetry, ResourceLayerMetadata, ResourceLayerRelationships, ResourceLayerPlatform:
		return true
	}
	return false
}

func (e ResourceLayer) String() string {
	return string(e)
}

func (e *ResourceLayer) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceLayer(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceLayer", str)
	}
	return nil
}

func (e ResourceLayer) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResourceLayer) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResourceLayer) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Resource lifecycle states for state machine
type ResourceLifecycleState string

const (
	// Initial creation, not yet validated
	ResourceLifecycleStateDraft ResourceLifecycleState = "DRAFT"
	// Backend validation in progress
	ResourceLifecycleStateValidating ResourceLifecycleState = "VALIDATING"
	// Passed validation, ready to apply
	ResourceLifecycleStateValid ResourceLifecycleState = "VALID"
	// Being applied to router
	ResourceLifecycleStateApplying ResourceLifecycleState = "APPLYING"
	// Successfully applied and running
	ResourceLifecycleStateActive ResourceLifecycleState = "ACTIVE"
	// Running but with issues
	ResourceLifecycleStateDegraded ResourceLifecycleState = "DEGRADED"
	// Failed state (validation or apply)
	ResourceLifecycleStateError ResourceLifecycleState = "ERROR"
	// Marked for removal
	ResourceLifecycleStateDeprecated ResourceLifecycleState = "DEPRECATED"
	// Final state, no longer active
	ResourceLifecycleStateArchived ResourceLifecycleState = "ARCHIVED"
)

var AllResourceLifecycleState = []ResourceLifecycleState{
	ResourceLifecycleStateDraft,
	ResourceLifecycleStateValidating,
	ResourceLifecycleStateValid,
	ResourceLifecycleStateApplying,
	ResourceLifecycleStateActive,
	ResourceLifecycleStateDegraded,
	ResourceLifecycleStateError,
	ResourceLifecycleStateDeprecated,
	ResourceLifecycleStateArchived,
}

func (e ResourceLifecycleState) IsValid() bool {
	switch e {
	case ResourceLifecycleStateDraft, ResourceLifecycleStateValidating, ResourceLifecycleStateValid, ResourceLifecycleStateApplying, ResourceLifecycleStateActive, ResourceLifecycleStateDegraded, ResourceLifecycleStateError, ResourceLifecycleStateDeprecated, ResourceLifecycleStateArchived:
		return true
	}
	return false
}

func (e ResourceLifecycleState) String() string {
	return string(e)
}

func (e *ResourceLifecycleState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceLifecycleState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceLifecycleState", str)
	}
	return nil
}

func (e ResourceLifecycleState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResourceLifecycleState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResourceLifecycleState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Types of relationships between resources
type ResourceRelationshipType string

const (
	// Child depends on parent
	ResourceRelationshipTypeDependsOn ResourceRelationshipType = "DEPENDS_ON"
	// Traffic routes via this resource
	ResourceRelationshipTypeRoutesVia ResourceRelationshipType = "ROUTES_VIA"
	// Parent-child hierarchy
	ResourceRelationshipTypeParentChild ResourceRelationshipType = "PARENT_CHILD"
	// Resources are in the same group
	ResourceRelationshipTypeGroup ResourceRelationshipType = "GROUP"
	// Custom relationship
	ResourceRelationshipTypeCustom ResourceRelationshipType = "CUSTOM"
)

var AllResourceRelationshipType = []ResourceRelationshipType{
	ResourceRelationshipTypeDependsOn,
	ResourceRelationshipTypeRoutesVia,
	ResourceRelationshipTypeParentChild,
	ResourceRelationshipTypeGroup,
	ResourceRelationshipTypeCustom,
}

func (e ResourceRelationshipType) IsValid() bool {
	switch e {
	case ResourceRelationshipTypeDependsOn, ResourceRelationshipTypeRoutesVia, ResourceRelationshipTypeParentChild, ResourceRelationshipTypeGroup, ResourceRelationshipTypeCustom:
		return true
	}
	return false
}

func (e ResourceRelationshipType) String() string {
	return string(e)
}

func (e *ResourceRelationshipType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceRelationshipType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceRelationshipType", str)
	}
	return nil
}

func (e ResourceRelationshipType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResourceRelationshipType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResourceRelationshipType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Resource status indicating health of resource usage.
type ResourceStatus string

const (
	// Resource usage is within acceptable limits (<70%)
	ResourceStatusOk ResourceStatus = "OK"
	// Resource usage is high (70-90%)
	ResourceStatusWarning ResourceStatus = "WARNING"
	// Resource usage is critical (>90%)
	ResourceStatusCritical ResourceStatus = "CRITICAL"
)

var AllResourceStatus = []ResourceStatus{
	ResourceStatusOk,
	ResourceStatusWarning,
	ResourceStatusCritical,
}

func (e ResourceStatus) IsValid() bool {
	switch e {
	case ResourceStatusOk, ResourceStatusWarning, ResourceStatusCritical:
		return true
	}
	return false
}

func (e ResourceStatus) String() string {
	return string(e)
}

func (e *ResourceStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ResourceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ResourceStatus", str)
	}
	return nil
}

func (e ResourceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ResourceStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ResourceStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Rollback operation type
type RollbackOperation string

const (
	// Delete a created resource
	RollbackOperationDelete RollbackOperation = "DELETE"
	// Restore a deleted resource
	RollbackOperationRestore RollbackOperation = "RESTORE"
	// Revert an updated resource
	RollbackOperationRevert RollbackOperation = "REVERT"
)

var AllRollbackOperation = []RollbackOperation{
	RollbackOperationDelete,
	RollbackOperationRestore,
	RollbackOperationRevert,
}

func (e RollbackOperation) IsValid() bool {
	switch e {
	case RollbackOperationDelete, RollbackOperationRestore, RollbackOperationRevert:
		return true
	}
	return false
}

func (e RollbackOperation) String() string {
	return string(e)
}

func (e *RollbackOperation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RollbackOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RollbackOperation", str)
	}
	return nil
}

func (e RollbackOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RollbackOperation) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RollbackOperation) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Route scope
type RouteScope string

const (
	// Global route (forwarded between interfaces)
	RouteScopeGlobal RouteScope = "GLOBAL"
	// Link-local route (not forwarded)
	RouteScopeLink RouteScope = "LINK"
	// Host-local route
	RouteScopeHost RouteScope = "HOST"
)

var AllRouteScope = []RouteScope{
	RouteScopeGlobal,
	RouteScopeLink,
	RouteScopeHost,
}

func (e RouteScope) IsValid() bool {
	switch e {
	case RouteScopeGlobal, RouteScopeLink, RouteScopeHost:
		return true
	}
	return false
}

func (e RouteScope) String() string {
	return string(e)
}

func (e *RouteScope) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RouteScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RouteScope", str)
	}
	return nil
}

func (e RouteScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RouteScope) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RouteScope) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Route type classification
type RouteType string

const (
	// Static route (manually configured)
	RouteTypeStatic RouteType = "STATIC"
	// Connected route (directly connected network)
	RouteTypeConnected RouteType = "CONNECTED"
	// Dynamic route (learned via routing protocol)
	RouteTypeDynamic RouteType = "DYNAMIC"
	// BGP route
	RouteTypeBgp RouteType = "BGP"
	// OSPF route
	RouteTypeOspf RouteType = "OSPF"
)

var AllRouteType = []RouteType{
	RouteTypeStatic,
	RouteTypeConnected,
	RouteTypeDynamic,
	RouteTypeBgp,
	RouteTypeOspf,
}

func (e RouteType) IsValid() bool {
	switch e {
	case RouteTypeStatic, RouteTypeConnected, RouteTypeDynamic, RouteTypeBgp, RouteTypeOspf:
		return true
	}
	return false
}

func (e RouteType) String() string {
	return string(e)
}

func (e *RouteType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RouteType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RouteType", str)
	}
	return nil
}

func (e RouteType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RouteType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RouteType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Supported router platforms
type RouterPlatform string

const (
	// MikroTik RouterOS
	RouterPlatformMikrotik RouterPlatform = "MIKROTIK"
	// OpenWrt
	RouterPlatformOpenwrt RouterPlatform = "OPENWRT"
	// VyOS
	RouterPlatformVyos RouterPlatform = "VYOS"
	// Generic/Unknown
	RouterPlatformGeneric RouterPlatform = "GENERIC"
)

var AllRouterPlatform = []RouterPlatform{
	RouterPlatformMikrotik,
	RouterPlatformOpenwrt,
	RouterPlatformVyos,
	RouterPlatformGeneric,
}

func (e RouterPlatform) IsValid() bool {
	switch e {
	case RouterPlatformMikrotik, RouterPlatformOpenwrt, RouterPlatformVyos, RouterPlatformGeneric:
		return true
	}
	return false
}

func (e RouterPlatform) String() string {
	return string(e)
}

func (e *RouterPlatform) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RouterPlatform(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RouterPlatform", str)
	}
	return nil
}

func (e RouterPlatform) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RouterPlatform) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RouterPlatform) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Routing mode for device routing assignments.
type RoutingMode string

const (
	// MAC address-based routing (default, more reliable)
	RoutingModeMac RoutingMode = "MAC"
	// IP address-based routing (less reliable due to DHCP changes)
	RoutingModeIP RoutingMode = "IP"
)

var AllRoutingMode = []RoutingMode{
	RoutingModeMac,
	RoutingModeIP,
}

func (e RoutingMode) IsValid() bool {
	switch e {
	case RoutingModeMac, RoutingModeIP:
		return true
	}
	return false
}

func (e RoutingMode) String() string {
	return string(e)
}

func (e *RoutingMode) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoutingMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoutingMode", str)
	}
	return nil
}

func (e RoutingMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RoutingMode) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RoutingMode) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Runtime health status
type RuntimeHealth string

const (
	// Resource is healthy and operating normally
	RuntimeHealthHealthy RuntimeHealth = "HEALTHY"
	// Resource is running but with warnings
	RuntimeHealthWarning RuntimeHealth = "WARNING"
	// Resource is running but degraded
	RuntimeHealthDegraded RuntimeHealth = "DEGRADED"
	// Resource has failed
	RuntimeHealthFailed RuntimeHealth = "FAILED"
	// Health status unknown
	RuntimeHealthUnknown RuntimeHealth = "UNKNOWN"
)

var AllRuntimeHealth = []RuntimeHealth{
	RuntimeHealthHealthy,
	RuntimeHealthWarning,
	RuntimeHealthDegraded,
	RuntimeHealthFailed,
	RuntimeHealthUnknown,
}

func (e RuntimeHealth) IsValid() bool {
	switch e {
	case RuntimeHealthHealthy, RuntimeHealthWarning, RuntimeHealthDegraded, RuntimeHealthFailed, RuntimeHealthUnknown:
		return true
	}
	return false
}

func (e RuntimeHealth) String() string {
	return string(e)
}

func (e *RuntimeHealth) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RuntimeHealth(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RuntimeHealth", str)
	}
	return nil
}

func (e RuntimeHealth) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RuntimeHealth) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RuntimeHealth) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status of a network scan operation
type ScanStatus string

const (
	// Scan is queued and waiting to start
	ScanStatusPending ScanStatus = "PENDING"
	// Scan is actively running
	ScanStatusRunning ScanStatus = "RUNNING"
	// Scan completed successfully
	ScanStatusCompleted ScanStatus = "COMPLETED"
	// Scan was cancelled by user
	ScanStatusCancelled ScanStatus = "CANCELLED"
	// Scan failed with an error
	ScanStatusFailed ScanStatus = "FAILED"
)

var AllScanStatus = []ScanStatus{
	ScanStatusPending,
	ScanStatusRunning,
	ScanStatusCompleted,
	ScanStatusCancelled,
	ScanStatusFailed,
}

func (e ScanStatus) IsValid() bool {
	switch e {
	case ScanStatusPending, ScanStatusRunning, ScanStatusCompleted, ScanStatusCancelled, ScanStatusFailed:
		return true
	}
	return false
}

func (e ScanStatus) String() string {
	return string(e)
}

func (e *ScanStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ScanStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ScanStatus", str)
	}
	return nil
}

func (e ScanStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ScanStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ScanStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Service instance lifecycle status.
type ServiceInstanceStatus string

const (
	// Binary is being downloaded and installed
	ServiceInstanceStatusInstalling ServiceInstanceStatus = "INSTALLING"
	// Binary installed, ready to start
	ServiceInstanceStatusInstalled ServiceInstanceStatus = "INSTALLED"
	// Process is starting
	ServiceInstanceStatusStarting ServiceInstanceStatus = "STARTING"
	// Process is running
	ServiceInstanceStatusRunning ServiceInstanceStatus = "RUNNING"
	// Process is stopping
	ServiceInstanceStatusStopping ServiceInstanceStatus = "STOPPING"
	// Process is stopped
	ServiceInstanceStatusStopped ServiceInstanceStatus = "STOPPED"
	// Operation failed
	ServiceInstanceStatusFailed ServiceInstanceStatus = "FAILED"
	// Instance is being deleted
	ServiceInstanceStatusDeleting ServiceInstanceStatus = "DELETING"
)

var AllServiceInstanceStatus = []ServiceInstanceStatus{
	ServiceInstanceStatusInstalling,
	ServiceInstanceStatusInstalled,
	ServiceInstanceStatusStarting,
	ServiceInstanceStatusRunning,
	ServiceInstanceStatusStopping,
	ServiceInstanceStatusStopped,
	ServiceInstanceStatusFailed,
	ServiceInstanceStatusDeleting,
}

func (e ServiceInstanceStatus) IsValid() bool {
	switch e {
	case ServiceInstanceStatusInstalling, ServiceInstanceStatusInstalled, ServiceInstanceStatusStarting, ServiceInstanceStatusRunning, ServiceInstanceStatusStopping, ServiceInstanceStatusStopped, ServiceInstanceStatusFailed, ServiceInstanceStatusDeleting:
		return true
	}
	return false
}

func (e ServiceInstanceStatus) String() string {
	return string(e)
}

func (e *ServiceInstanceStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceInstanceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceInstanceStatus", str)
	}
	return nil
}

func (e ServiceInstanceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ServiceInstanceStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ServiceInstanceStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Service operational status
type ServiceStatus string

const (
	// Service is fully operational
	ServiceStatusHealthy ServiceStatus = "HEALTHY"
	// Service is operational with degraded performance
	ServiceStatusDegraded ServiceStatus = "DEGRADED"
	// Service is not operational
	ServiceStatusUnhealthy ServiceStatus = "UNHEALTHY"
)

var AllServiceStatus = []ServiceStatus{
	ServiceStatusHealthy,
	ServiceStatusDegraded,
	ServiceStatusUnhealthy,
}

func (e ServiceStatus) IsValid() bool {
	switch e {
	case ServiceStatusHealthy, ServiceStatusDegraded, ServiceStatusUnhealthy:
		return true
	}
	return false
}

func (e ServiceStatus) String() string {
	return string(e)
}

func (e *ServiceStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceStatus", str)
	}
	return nil
}

func (e ServiceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ServiceStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ServiceStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Service template category enum
type ServiceTemplateCategory string

const (
	ServiceTemplateCategoryPrivacy        ServiceTemplateCategory = "PRIVACY"
	ServiceTemplateCategoryAntiCensorship ServiceTemplateCategory = "ANTI_CENSORSHIP"
	ServiceTemplateCategoryMessaging      ServiceTemplateCategory = "MESSAGING"
	ServiceTemplateCategoryGaming         ServiceTemplateCategory = "GAMING"
	ServiceTemplateCategorySecurity       ServiceTemplateCategory = "SECURITY"
	ServiceTemplateCategoryNetworking     ServiceTemplateCategory = "NETWORKING"
)

var AllServiceTemplateCategory = []ServiceTemplateCategory{
	ServiceTemplateCategoryPrivacy,
	ServiceTemplateCategoryAntiCensorship,
	ServiceTemplateCategoryMessaging,
	ServiceTemplateCategoryGaming,
	ServiceTemplateCategorySecurity,
	ServiceTemplateCategoryNetworking,
}

func (e ServiceTemplateCategory) IsValid() bool {
	switch e {
	case ServiceTemplateCategoryPrivacy, ServiceTemplateCategoryAntiCensorship, ServiceTemplateCategoryMessaging, ServiceTemplateCategoryGaming, ServiceTemplateCategorySecurity, ServiceTemplateCategoryNetworking:
		return true
	}
	return false
}

func (e ServiceTemplateCategory) String() string {
	return string(e)
}

func (e *ServiceTemplateCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceTemplateCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceTemplateCategory", str)
	}
	return nil
}

func (e ServiceTemplateCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ServiceTemplateCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ServiceTemplateCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of storage location.
type StorageLocationType string

const (
	// Internal flash memory (limited, persistent)
	StorageLocationTypeFlash StorageLocationType = "FLASH"
	// External USB/disk storage (large, removable)
	StorageLocationTypeExternal StorageLocationType = "EXTERNAL"
	// Unknown storage type
	StorageLocationTypeUnknown StorageLocationType = "UNKNOWN"
)

var AllStorageLocationType = []StorageLocationType{
	StorageLocationTypeFlash,
	StorageLocationTypeExternal,
	StorageLocationTypeUnknown,
}

func (e StorageLocationType) IsValid() bool {
	switch e {
	case StorageLocationTypeFlash, StorageLocationTypeExternal, StorageLocationTypeUnknown:
		return true
	}
	return false
}

func (e StorageLocationType) String() string {
	return string(e)
}

func (e *StorageLocationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StorageLocationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StorageLocationType", str)
	}
	return nil
}

func (e StorageLocationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StorageLocationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StorageLocationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Storage space threshold status.
// Used to trigger warnings and prevent installations when space is low.
type StorageThresholdStatus string

const (
	// Normal usage (<80%)
	StorageThresholdStatusNormal StorageThresholdStatus = "NORMAL"
	// Low space warning (80-89%)
	StorageThresholdStatusLow StorageThresholdStatus = "LOW"
	// Critical space warning (90-94%)
	StorageThresholdStatusCritical StorageThresholdStatus = "CRITICAL"
	// Full - installations blocked (95%+)
	StorageThresholdStatusFull StorageThresholdStatus = "FULL"
)

var AllStorageThresholdStatus = []StorageThresholdStatus{
	StorageThresholdStatusNormal,
	StorageThresholdStatusLow,
	StorageThresholdStatusCritical,
	StorageThresholdStatusFull,
}

func (e StorageThresholdStatus) IsValid() bool {
	switch e {
	case StorageThresholdStatusNormal, StorageThresholdStatusLow, StorageThresholdStatusCritical, StorageThresholdStatusFull:
		return true
	}
	return false
}

func (e StorageThresholdStatus) String() string {
	return string(e)
}

func (e *StorageThresholdStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StorageThresholdStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StorageThresholdStatus", str)
	}
	return nil
}

func (e StorageThresholdStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StorageThresholdStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StorageThresholdStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StpPortRole string

const (
	StpPortRoleRoot       StpPortRole = "ROOT"
	StpPortRoleDesignated StpPortRole = "DESIGNATED"
	StpPortRoleAlternate  StpPortRole = "ALTERNATE"
	StpPortRoleBackup     StpPortRole = "BACKUP"
	StpPortRoleDisabled   StpPortRole = "DISABLED"
)

var AllStpPortRole = []StpPortRole{
	StpPortRoleRoot,
	StpPortRoleDesignated,
	StpPortRoleAlternate,
	StpPortRoleBackup,
	StpPortRoleDisabled,
}

func (e StpPortRole) IsValid() bool {
	switch e {
	case StpPortRoleRoot, StpPortRoleDesignated, StpPortRoleAlternate, StpPortRoleBackup, StpPortRoleDisabled:
		return true
	}
	return false
}

func (e StpPortRole) String() string {
	return string(e)
}

func (e *StpPortRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StpPortRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StpPortRole", str)
	}
	return nil
}

func (e StpPortRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StpPortRole) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StpPortRole) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StpPortState string

const (
	StpPortStateDisabled   StpPortState = "DISABLED"
	StpPortStateBlocking   StpPortState = "BLOCKING"
	StpPortStateListening  StpPortState = "LISTENING"
	StpPortStateLearning   StpPortState = "LEARNING"
	StpPortStateForwarding StpPortState = "FORWARDING"
)

var AllStpPortState = []StpPortState{
	StpPortStateDisabled,
	StpPortStateBlocking,
	StpPortStateListening,
	StpPortStateLearning,
	StpPortStateForwarding,
}

func (e StpPortState) IsValid() bool {
	switch e {
	case StpPortStateDisabled, StpPortStateBlocking, StpPortStateListening, StpPortStateLearning, StpPortStateForwarding:
		return true
	}
	return false
}

func (e StpPortState) String() string {
	return string(e)
}

func (e *StpPortState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StpPortState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StpPortState", str)
	}
	return nil
}

func (e StpPortState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StpPortState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StpPortState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StpProtocol string

const (
	StpProtocolNone StpProtocol = "NONE"
	StpProtocolStp  StpProtocol = "STP"
	StpProtocolRstp StpProtocol = "RSTP"
	StpProtocolMstp StpProtocol = "MSTP"
)

var AllStpProtocol = []StpProtocol{
	StpProtocolNone,
	StpProtocolStp,
	StpProtocolRstp,
	StpProtocolMstp,
}

func (e StpProtocol) IsValid() bool {
	switch e {
	case StpProtocolNone, StpProtocolStp, StpProtocolRstp, StpProtocolMstp:
		return true
	}
	return false
}

func (e StpProtocol) String() string {
	return string(e)
}

func (e *StpProtocol) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StpProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StpProtocol", str)
	}
	return nil
}

func (e StpProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StpProtocol) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StpProtocol) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Severity level for diagnostic suggestions
type SuggestionSeverity string

const (
	// Informational message, no action required
	SuggestionSeverityInfo SuggestionSeverity = "INFO"
	// Warning that may affect functionality
	SuggestionSeverityWarning SuggestionSeverity = "WARNING"
	// Error that needs to be addressed
	SuggestionSeverityError SuggestionSeverity = "ERROR"
	// Critical issue blocking connectivity
	SuggestionSeverityCritical SuggestionSeverity = "CRITICAL"
)

var AllSuggestionSeverity = []SuggestionSeverity{
	SuggestionSeverityInfo,
	SuggestionSeverityWarning,
	SuggestionSeverityError,
	SuggestionSeverityCritical,
}

func (e SuggestionSeverity) IsValid() bool {
	switch e {
	case SuggestionSeverityInfo, SuggestionSeverityWarning, SuggestionSeverityError, SuggestionSeverityCritical:
		return true
	}
	return false
}

func (e SuggestionSeverity) String() string {
	return string(e)
}

func (e *SuggestionSeverity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SuggestionSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SuggestionSeverity", str)
	}
	return nil
}

func (e SuggestionSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SuggestionSeverity) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SuggestionSeverity) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Template categories for organization.
type TemplateCategory string

const (
	// Basic security rules
	TemplateCategoryBasic TemplateCategory = "BASIC"
	// Home network configurations
	TemplateCategoryHome TemplateCategory = "HOME"
	// Gaming-optimized rules
	TemplateCategoryGaming TemplateCategory = "GAMING"
	// IoT device isolation
	TemplateCategoryIot TemplateCategory = "IOT"
	// Guest network access
	TemplateCategoryGuest TemplateCategory = "GUEST"
	// User-created custom templates
	TemplateCategoryCustom TemplateCategory = "CUSTOM"
)

var AllTemplateCategory = []TemplateCategory{
	TemplateCategoryBasic,
	TemplateCategoryHome,
	TemplateCategoryGaming,
	TemplateCategoryIot,
	TemplateCategoryGuest,
	TemplateCategoryCustom,
}

func (e TemplateCategory) IsValid() bool {
	switch e {
	case TemplateCategoryBasic, TemplateCategoryHome, TemplateCategoryGaming, TemplateCategoryIot, TemplateCategoryGuest, TemplateCategoryCustom:
		return true
	}
	return false
}

func (e TemplateCategory) String() string {
	return string(e)
}

func (e *TemplateCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateCategory", str)
	}
	return nil
}

func (e TemplateCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TemplateCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TemplateCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Template complexity levels.
type TemplateComplexity string

const (
	// Simple templates with few rules
	TemplateComplexitySimple TemplateComplexity = "SIMPLE"
	// Moderate complexity
	TemplateComplexityModerate TemplateComplexity = "MODERATE"
	// Advanced templates with many rules
	TemplateComplexityAdvanced TemplateComplexity = "ADVANCED"
)

var AllTemplateComplexity = []TemplateComplexity{
	TemplateComplexitySimple,
	TemplateComplexityModerate,
	TemplateComplexityAdvanced,
}

func (e TemplateComplexity) IsValid() bool {
	switch e {
	case TemplateComplexitySimple, TemplateComplexityModerate, TemplateComplexityAdvanced:
		return true
	}
	return false
}

func (e TemplateComplexity) String() string {
	return string(e)
}

func (e *TemplateComplexity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateComplexity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateComplexity", str)
	}
	return nil
}

func (e TemplateComplexity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TemplateComplexity) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TemplateComplexity) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Conflict types between template and existing configuration.
type TemplateConflictType string

const (
	// Duplicate rule already exists
	TemplateConflictTypeDuplicateRule TemplateConflictType = "DUPLICATE_RULE"
	// IP address range overlaps
	TemplateConflictTypeIPOverlap TemplateConflictType = "IP_OVERLAP"
	// Chain configuration conflicts
	TemplateConflictTypeChainConflict TemplateConflictType = "CHAIN_CONFLICT"
	// Position conflict in chain
	TemplateConflictTypePositionConflict TemplateConflictType = "POSITION_CONFLICT"
)

var AllTemplateConflictType = []TemplateConflictType{
	TemplateConflictTypeDuplicateRule,
	TemplateConflictTypeIPOverlap,
	TemplateConflictTypeChainConflict,
	TemplateConflictTypePositionConflict,
}

func (e TemplateConflictType) IsValid() bool {
	switch e {
	case TemplateConflictTypeDuplicateRule, TemplateConflictTypeIPOverlap, TemplateConflictTypeChainConflict, TemplateConflictTypePositionConflict:
		return true
	}
	return false
}

func (e TemplateConflictType) String() string {
	return string(e)
}

func (e *TemplateConflictType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateConflictType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateConflictType", str)
	}
	return nil
}

func (e TemplateConflictType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TemplateConflictType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TemplateConflictType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Template installation status
type TemplateInstallationStatus string

const (
	TemplateInstallationStatusPending    TemplateInstallationStatus = "PENDING"
	TemplateInstallationStatusInProgress TemplateInstallationStatus = "IN_PROGRESS"
	TemplateInstallationStatusCompleted  TemplateInstallationStatus = "COMPLETED"
	TemplateInstallationStatusFailed     TemplateInstallationStatus = "FAILED"
	TemplateInstallationStatusPartial    TemplateInstallationStatus = "PARTIAL"
)

var AllTemplateInstallationStatus = []TemplateInstallationStatus{
	TemplateInstallationStatusPending,
	TemplateInstallationStatusInProgress,
	TemplateInstallationStatusCompleted,
	TemplateInstallationStatusFailed,
	TemplateInstallationStatusPartial,
}

func (e TemplateInstallationStatus) IsValid() bool {
	switch e {
	case TemplateInstallationStatusPending, TemplateInstallationStatusInProgress, TemplateInstallationStatusCompleted, TemplateInstallationStatusFailed, TemplateInstallationStatusPartial:
		return true
	}
	return false
}

func (e TemplateInstallationStatus) String() string {
	return string(e)
}

func (e *TemplateInstallationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateInstallationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateInstallationStatus", str)
	}
	return nil
}

func (e TemplateInstallationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TemplateInstallationStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TemplateInstallationStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Template deployment scope
type TemplateScope string

const (
	// Single service instance
	TemplateScopeSingle TemplateScope = "SINGLE"
	// Multiple independent services
	TemplateScopeMultiple TemplateScope = "MULTIPLE"
	// Chained services (e.g., Tor -> Xray)
	TemplateScopeChain TemplateScope = "CHAIN"
)

var AllTemplateScope = []TemplateScope{
	TemplateScopeSingle,
	TemplateScopeMultiple,
	TemplateScopeChain,
}

func (e TemplateScope) IsValid() bool {
	switch e {
	case TemplateScopeSingle, TemplateScopeMultiple, TemplateScopeChain:
		return true
	}
	return false
}

func (e TemplateScope) String() string {
	return string(e)
}

func (e *TemplateScope) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateScope", str)
	}
	return nil
}

func (e TemplateScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TemplateScope) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TemplateScope) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Template variable type
type TemplateVariableType string

const (
	TemplateVariableTypeString  TemplateVariableType = "STRING"
	TemplateVariableTypeNumber  TemplateVariableType = "NUMBER"
	TemplateVariableTypeBoolean TemplateVariableType = "BOOLEAN"
	TemplateVariableTypeEnum    TemplateVariableType = "ENUM"
	TemplateVariableTypePort    TemplateVariableType = "PORT"
	TemplateVariableTypeIP      TemplateVariableType = "IP"
)

var AllTemplateVariableType = []TemplateVariableType{
	TemplateVariableTypeString,
	TemplateVariableTypeNumber,
	TemplateVariableTypeBoolean,
	TemplateVariableTypeEnum,
	TemplateVariableTypePort,
	TemplateVariableTypeIP,
}

func (e TemplateVariableType) IsValid() bool {
	switch e {
	case TemplateVariableTypeString, TemplateVariableTypeNumber, TemplateVariableTypeBoolean, TemplateVariableTypeEnum, TemplateVariableTypePort, TemplateVariableTypeIP:
		return true
	}
	return false
}

func (e TemplateVariableType) String() string {
	return string(e)
}

func (e *TemplateVariableType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateVariableType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateVariableType", str)
	}
	return nil
}

func (e TemplateVariableType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TemplateVariableType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TemplateVariableType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Type of topology node
type TopologyNodeType string

const (
	// Bridge interface
	TopologyNodeTypeBridge TopologyNodeType = "BRIDGE"
	// VLAN interface
	TopologyNodeTypeVlan TopologyNodeType = "VLAN"
	// Physical port
	TopologyNodeTypePort TopologyNodeType = "PORT"
)

var AllTopologyNodeType = []TopologyNodeType{
	TopologyNodeTypeBridge,
	TopologyNodeTypeVlan,
	TopologyNodeTypePort,
}

func (e TopologyNodeType) IsValid() bool {
	switch e {
	case TopologyNodeTypeBridge, TopologyNodeTypeVlan, TopologyNodeTypePort:
		return true
	}
	return false
}

func (e TopologyNodeType) String() string {
	return string(e)
}

func (e *TopologyNodeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TopologyNodeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TopologyNodeType", str)
	}
	return nil
}

func (e TopologyNodeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TopologyNodeType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TopologyNodeType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Event type for traceroute progress updates
type TracerouteEventType string

const (
	// A new hop was discovered
	TracerouteEventTypeHopDiscovered TracerouteEventType = "HOP_DISCOVERED"
	// Traceroute completed
	TracerouteEventTypeComplete TracerouteEventType = "COMPLETE"
	// Traceroute encountered an error
	TracerouteEventTypeError TracerouteEventType = "ERROR"
	// Traceroute was cancelled
	TracerouteEventTypeCancelled TracerouteEventType = "CANCELLED"
)

var AllTracerouteEventType = []TracerouteEventType{
	TracerouteEventTypeHopDiscovered,
	TracerouteEventTypeComplete,
	TracerouteEventTypeError,
	TracerouteEventTypeCancelled,
}

func (e TracerouteEventType) IsValid() bool {
	switch e {
	case TracerouteEventTypeHopDiscovered, TracerouteEventTypeComplete, TracerouteEventTypeError, TracerouteEventTypeCancelled:
		return true
	}
	return false
}

func (e TracerouteEventType) String() string {
	return string(e)
}

func (e *TracerouteEventType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TracerouteEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TracerouteEventType", str)
	}
	return nil
}

func (e TracerouteEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TracerouteEventType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TracerouteEventType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Protocol to use for traceroute probes
type TracerouteProtocol string

const (
	// ICMP echo request (default)
	TracerouteProtocolICMP TracerouteProtocol = "ICMP"
	// UDP probes
	TracerouteProtocolUDP TracerouteProtocol = "UDP"
	// TCP SYN probes
	TracerouteProtocolTCP TracerouteProtocol = "TCP"
)

var AllTracerouteProtocol = []TracerouteProtocol{
	TracerouteProtocolICMP,
	TracerouteProtocolUDP,
	TracerouteProtocolTCP,
}

func (e TracerouteProtocol) IsValid() bool {
	switch e {
	case TracerouteProtocolICMP, TracerouteProtocolUDP, TracerouteProtocolTCP:
		return true
	}
	return false
}

func (e TracerouteProtocol) String() string {
	return string(e)
}

func (e *TracerouteProtocol) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TracerouteProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TracerouteProtocol", str)
	}
	return nil
}

func (e TracerouteProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TracerouteProtocol) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TracerouteProtocol) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Transport protocol enum for network traffic.
type TransportProtocol string

const (
	TransportProtocolTCP TransportProtocol = "TCP"
	TransportProtocolUDP TransportProtocol = "UDP"
)

var AllTransportProtocol = []TransportProtocol{
	TransportProtocolTCP,
	TransportProtocolUDP,
}

func (e TransportProtocol) IsValid() bool {
	switch e {
	case TransportProtocolTCP, TransportProtocolUDP:
		return true
	}
	return false
}

func (e TransportProtocol) String() string {
	return string(e)
}

func (e *TransportProtocol) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransportProtocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransportProtocol", str)
	}
	return nil
}

func (e TransportProtocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TransportProtocol) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TransportProtocol) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Overall status of a troubleshooting session
type TroubleshootSessionStatus string

const (
	// Session created but not started
	TroubleshootSessionStatusIdle TroubleshootSessionStatus = "IDLE"
	// Detecting network configuration
	TroubleshootSessionStatusInitializing TroubleshootSessionStatus = "INITIALIZING"
	// Running diagnostic steps
	TroubleshootSessionStatusRunning TroubleshootSessionStatus = "RUNNING"
	// Waiting for user decision on fix
	TroubleshootSessionStatusAwaitingFixDecision TroubleshootSessionStatus = "AWAITING_FIX_DECISION"
	// Applying a fix
	TroubleshootSessionStatusApplyingFix TroubleshootSessionStatus = "APPLYING_FIX"
	// Verifying fix worked
	TroubleshootSessionStatusVerifyingFix TroubleshootSessionStatus = "VERIFYING_FIX"
	// Session completed
	TroubleshootSessionStatusCompleted TroubleshootSessionStatus = "COMPLETED"
	// Session was cancelled
	TroubleshootSessionStatusCancelled TroubleshootSessionStatus = "CANCELLED"
)

var AllTroubleshootSessionStatus = []TroubleshootSessionStatus{
	TroubleshootSessionStatusIdle,
	TroubleshootSessionStatusInitializing,
	TroubleshootSessionStatusRunning,
	TroubleshootSessionStatusAwaitingFixDecision,
	TroubleshootSessionStatusApplyingFix,
	TroubleshootSessionStatusVerifyingFix,
	TroubleshootSessionStatusCompleted,
	TroubleshootSessionStatusCancelled,
}

func (e TroubleshootSessionStatus) IsValid() bool {
	switch e {
	case TroubleshootSessionStatusIdle, TroubleshootSessionStatusInitializing, TroubleshootSessionStatusRunning, TroubleshootSessionStatusAwaitingFixDecision, TroubleshootSessionStatusApplyingFix, TroubleshootSessionStatusVerifyingFix, TroubleshootSessionStatusCompleted, TroubleshootSessionStatusCancelled:
		return true
	}
	return false
}

func (e TroubleshootSessionStatus) String() string {
	return string(e)
}

func (e *TroubleshootSessionStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TroubleshootSessionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TroubleshootSessionStatus", str)
	}
	return nil
}

func (e TroubleshootSessionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TroubleshootSessionStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TroubleshootSessionStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status of a diagnostic step
type TroubleshootStepStatus string

const (
	// Step not yet started
	TroubleshootStepStatusPending TroubleshootStepStatus = "PENDING"
	// Step currently executing
	TroubleshootStepStatusRunning TroubleshootStepStatus = "RUNNING"
	// Step completed successfully
	TroubleshootStepStatusPassed TroubleshootStepStatus = "PASSED"
	// Step failed
	TroubleshootStepStatusFailed TroubleshootStepStatus = "FAILED"
	// Step skipped
	TroubleshootStepStatusSkipped TroubleshootStepStatus = "SKIPPED"
)

var AllTroubleshootStepStatus = []TroubleshootStepStatus{
	TroubleshootStepStatusPending,
	TroubleshootStepStatusRunning,
	TroubleshootStepStatusPassed,
	TroubleshootStepStatusFailed,
	TroubleshootStepStatusSkipped,
}

func (e TroubleshootStepStatus) IsValid() bool {
	switch e {
	case TroubleshootStepStatusPending, TroubleshootStepStatusRunning, TroubleshootStepStatusPassed, TroubleshootStepStatusFailed, TroubleshootStepStatusSkipped:
		return true
	}
	return false
}

func (e TroubleshootStepStatus) String() string {
	return string(e)
}

func (e *TroubleshootStepStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TroubleshootStepStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TroubleshootStepStatus", str)
	}
	return nil
}

func (e TroubleshootStepStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TroubleshootStepStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TroubleshootStepStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Diagnostic step identifier for internet troubleshooting
type TroubleshootStepType string

const (
	// Check WAN interface status
	TroubleshootStepTypeWan TroubleshootStepType = "WAN"
	// Ping default gateway
	TroubleshootStepTypeGateway TroubleshootStepType = "GATEWAY"
	// Ping external internet server
	TroubleshootStepTypeInternet TroubleshootStepType = "INTERNET"
	// Test DNS resolution
	TroubleshootStepTypeDNS TroubleshootStepType = "DNS"
	// Verify NAT/masquerade rules
	TroubleshootStepTypeNat TroubleshootStepType = "NAT"
)

var AllTroubleshootStepType = []TroubleshootStepType{
	TroubleshootStepTypeWan,
	TroubleshootStepTypeGateway,
	TroubleshootStepTypeInternet,
	TroubleshootStepTypeDNS,
	TroubleshootStepTypeNat,
}

func (e TroubleshootStepType) IsValid() bool {
	switch e {
	case TroubleshootStepTypeWan, TroubleshootStepTypeGateway, TroubleshootStepTypeInternet, TroubleshootStepTypeDNS, TroubleshootStepTypeNat:
		return true
	}
	return false
}

func (e TroubleshootStepType) String() string {
	return string(e)
}

func (e *TroubleshootStepType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TroubleshootStepType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TroubleshootStepType", str)
	}
	return nil
}

func (e TroubleshootStepType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TroubleshootStepType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TroubleshootStepType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Status of a VPN tunnel
type TunnelStatus string

const (
	// Tunnel is connected and active
	TunnelStatusConnected TunnelStatus = "CONNECTED"
	// Tunnel is disconnected
	TunnelStatusDisconnected TunnelStatus = "DISCONNECTED"
	// Tunnel is attempting to connect
	TunnelStatusConnecting TunnelStatus = "CONNECTING"
)

var AllTunnelStatus = []TunnelStatus{
	TunnelStatusConnected,
	TunnelStatusDisconnected,
	TunnelStatusConnecting,
}

func (e TunnelStatus) IsValid() bool {
	switch e {
	case TunnelStatusConnected, TunnelStatusDisconnected, TunnelStatusConnecting:
		return true
	}
	return false
}

func (e TunnelStatus) String() string {
	return string(e)
}

func (e *TunnelStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TunnelStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TunnelStatus", str)
	}
	return nil
}

func (e TunnelStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TunnelStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TunnelStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Network tunnel types supported by MikroTik RouterOS
type TunnelType string

const (
	// IP-in-IP tunnel (RFC 2003) - Basic L3 encapsulation
	TunnelTypeIpip TunnelType = "IPIP"
	// Generic Routing Encapsulation (RFC 2784) - L3 with optional IPsec
	TunnelTypeGre TunnelType = "GRE"
	// Ethernet over IP - Layer 2 tunnel for bridge extension
	TunnelTypeEoip TunnelType = "EOIP"
	// Virtual eXtensible LAN (RFC 7348) - L2 overlay network
	TunnelTypeVxlan TunnelType = "VXLAN"
	// Secure Socket Tunneling Protocol (future support)
	TunnelTypeSstp TunnelType = "SSTP"
	// Layer 2 Tunneling Protocol (future support)
	TunnelTypeL2tp TunnelType = "L2TP"
)

var AllTunnelType = []TunnelType{
	TunnelTypeIpip,
	TunnelTypeGre,
	TunnelTypeEoip,
	TunnelTypeVxlan,
	TunnelTypeSstp,
	TunnelTypeL2tp,
}

func (e TunnelType) IsValid() bool {
	switch e {
	case TunnelTypeIpip, TunnelTypeGre, TunnelTypeEoip, TunnelTypeVxlan, TunnelTypeSstp, TunnelTypeL2tp:
		return true
	}
	return false
}

func (e TunnelType) String() string {
	return string(e)
}

func (e *TunnelType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TunnelType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TunnelType", str)
	}
	return nil
}

func (e TunnelType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TunnelType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TunnelType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Update severity classification for available updates.
type UpdateSeverity string

const (
	// Critical security fix - auto-apply recommended
	UpdateSeverityCritical UpdateSeverity = "CRITICAL"
	// Major version with breaking changes
	UpdateSeverityMajor UpdateSeverity = "MAJOR"
	// Minor version with new features
	UpdateSeverityMinor UpdateSeverity = "MINOR"
	// Patch version with bug fixes
	UpdateSeverityPatch UpdateSeverity = "PATCH"
)

var AllUpdateSeverity = []UpdateSeverity{
	UpdateSeverityCritical,
	UpdateSeverityMajor,
	UpdateSeverityMinor,
	UpdateSeverityPatch,
}

func (e UpdateSeverity) IsValid() bool {
	switch e {
	case UpdateSeverityCritical, UpdateSeverityMajor, UpdateSeverityMinor, UpdateSeverityPatch:
		return true
	}
	return false
}

func (e UpdateSeverity) String() string {
	return string(e)
}

func (e *UpdateSeverity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateSeverity", str)
	}
	return nil
}

func (e UpdateSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UpdateSeverity) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UpdateSeverity) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Update stage during atomic update process.
type UpdateStage string

const (
	// Downloading and verifying new binary
	UpdateStageStaging UpdateStage = "STAGING"
	// Backing up current binary
	UpdateStageBackup UpdateStage = "BACKUP"
	// Swapping binaries
	UpdateStageSwap UpdateStage = "SWAP"
	// Running config migrations
	UpdateStageMigration UpdateStage = "MIGRATION"
	// Validating new version
	UpdateStageValidation UpdateStage = "VALIDATION"
	// Finalizing update
	UpdateStageCommit UpdateStage = "COMMIT"
	// Restoring from backup
	UpdateStageRollback UpdateStage = "ROLLBACK"
)

var AllUpdateStage = []UpdateStage{
	UpdateStageStaging,
	UpdateStageBackup,
	UpdateStageSwap,
	UpdateStageMigration,
	UpdateStageValidation,
	UpdateStageCommit,
	UpdateStageRollback,
}

func (e UpdateStage) IsValid() bool {
	switch e {
	case UpdateStageStaging, UpdateStageBackup, UpdateStageSwap, UpdateStageMigration, UpdateStageValidation, UpdateStageCommit, UpdateStageRollback:
		return true
	}
	return false
}

func (e UpdateStage) String() string {
	return string(e)
}

func (e *UpdateStage) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpdateStage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpdateStage", str)
	}
	return nil
}

func (e UpdateStage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UpdateStage) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UpdateStage) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Priority level for upgrade recommendations
type UpgradePriority string

const (
	// Security-related, should upgrade immediately
	UpgradePriorityCritical UpgradePriority = "CRITICAL"
	// Highly recommended for stability/features
	UpgradePriorityHigh UpgradePriority = "HIGH"
	// Recommended but not urgent
	UpgradePriorityMedium UpgradePriority = "MEDIUM"
	// Nice to have, optional
	UpgradePriorityLow UpgradePriority = "LOW"
)

var AllUpgradePriority = []UpgradePriority{
	UpgradePriorityCritical,
	UpgradePriorityHigh,
	UpgradePriorityMedium,
	UpgradePriorityLow,
}

func (e UpgradePriority) IsValid() bool {
	switch e {
	case UpgradePriorityCritical, UpgradePriorityHigh, UpgradePriorityMedium, UpgradePriorityLow:
		return true
	}
	return false
}

func (e UpgradePriority) String() string {
	return string(e)
}

func (e *UpgradePriority) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UpgradePriority(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UpgradePriority", str)
	}
	return nil
}

func (e UpgradePriority) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UpgradePriority) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UpgradePriority) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// VLANAllocationStatus represents the lifecycle state of a VLAN allocation.
type VLANAllocationStatus string

const (
	// VLAN is currently allocated and in use
	VLANAllocationStatusAllocated VLANAllocationStatus = "ALLOCATED"
	// VLAN is being released (transitional state)
	VLANAllocationStatusReleasing VLANAllocationStatus = "RELEASING"
	// VLAN has been released and is available for reuse
	VLANAllocationStatusReleased VLANAllocationStatus = "RELEASED"
)

var AllVLANAllocationStatus = []VLANAllocationStatus{
	VLANAllocationStatusAllocated,
	VLANAllocationStatusReleasing,
	VLANAllocationStatusReleased,
}

func (e VLANAllocationStatus) IsValid() bool {
	switch e {
	case VLANAllocationStatusAllocated, VLANAllocationStatusReleasing, VLANAllocationStatusReleased:
		return true
	}
	return false
}

func (e VLANAllocationStatus) String() string {
	return string(e)
}

func (e *VLANAllocationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VLANAllocationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VLANAllocationStatus", str)
	}
	return nil
}

func (e VLANAllocationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VLANAllocationStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VLANAllocationStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Predefined validation formats for common data types
type ValidateFormat string

const (
	ValidateFormatEmail    ValidateFormat = "EMAIL"
	ValidateFormatURL      ValidateFormat = "URL"
	ValidateFormatUUID     ValidateFormat = "UUID"
	ValidateFormatIPV4     ValidateFormat = "IPV4"
	ValidateFormatIPV6     ValidateFormat = "IPV6"
	ValidateFormatMac      ValidateFormat = "MAC"
	ValidateFormatCidr     ValidateFormat = "CIDR"
	ValidateFormatHostname ValidateFormat = "HOSTNAME"
	ValidateFormatFqdn     ValidateFormat = "FQDN"
)

var AllValidateFormat = []ValidateFormat{
	ValidateFormatEmail,
	ValidateFormatURL,
	ValidateFormatUUID,
	ValidateFormatIPV4,
	ValidateFormatIPV6,
	ValidateFormatMac,
	ValidateFormatCidr,
	ValidateFormatHostname,
	ValidateFormatFqdn,
}

func (e ValidateFormat) IsValid() bool {
	switch e {
	case ValidateFormatEmail, ValidateFormatURL, ValidateFormatUUID, ValidateFormatIPV4, ValidateFormatIPV6, ValidateFormatMac, ValidateFormatCidr, ValidateFormatHostname, ValidateFormatFqdn:
		return true
	}
	return false
}

func (e ValidateFormat) String() string {
	return string(e)
}

func (e *ValidateFormat) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidateFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidateFormat", str)
	}
	return nil
}

func (e ValidateFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ValidateFormat) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ValidateFormat) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Validation issue severity
type ValidationSeverity string

const (
	// Blocks apply, must be fixed
	ValidationSeverityError ValidationSeverity = "ERROR"
	// Does not block, but recommended to address
	ValidationSeverityWarning ValidationSeverity = "WARNING"
	// Informational notice
	ValidationSeverityInfo ValidationSeverity = "INFO"
)

var AllValidationSeverity = []ValidationSeverity{
	ValidationSeverityError,
	ValidationSeverityWarning,
	ValidationSeverityInfo,
}

func (e ValidationSeverity) IsValid() bool {
	switch e {
	case ValidationSeverityError, ValidationSeverityWarning, ValidationSeverityInfo:
		return true
	}
	return false
}

func (e ValidationSeverity) String() string {
	return string(e)
}

func (e *ValidationSeverity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidationSeverity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidationSeverity", str)
	}
	return nil
}

func (e ValidationSeverity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ValidationSeverity) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ValidationSeverity) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Validation pipeline stages
type ValidationStage string

const (
	// Schema validation (Zod/GraphQL)
	ValidationStageSchema ValidationStage = "SCHEMA"
	// Semantic validation (business rules)
	ValidationStageSemantic ValidationStage = "SEMANTIC"
	// Dependency validation (required resources exist)
	ValidationStageDependency ValidationStage = "DEPENDENCY"
	// Conflict detection (port/IP/route conflicts)
	ValidationStageConflict ValidationStage = "CONFLICT"
	// Platform validation (capability checks)
	ValidationStagePlatform ValidationStage = "PLATFORM"
	// Quota validation (resource limits)
	ValidationStageQuota ValidationStage = "QUOTA"
	// Pre-flight simulation
	ValidationStageSimulation ValidationStage = "SIMULATION"
	// All stages complete
	ValidationStageComplete ValidationStage = "COMPLETE"
)

var AllValidationStage = []ValidationStage{
	ValidationStageSchema,
	ValidationStageSemantic,
	ValidationStageDependency,
	ValidationStageConflict,
	ValidationStagePlatform,
	ValidationStageQuota,
	ValidationStageSimulation,
	ValidationStageComplete,
}

func (e ValidationStage) IsValid() bool {
	switch e {
	case ValidationStageSchema, ValidationStageSemantic, ValidationStageDependency, ValidationStageConflict, ValidationStagePlatform, ValidationStageQuota, ValidationStageSimulation, ValidationStageComplete:
		return true
	}
	return false
}

func (e ValidationStage) String() string {
	return string(e)
}

func (e *ValidationStage) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ValidationStage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ValidationStage", str)
	}
	return nil
}

func (e ValidationStage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ValidationStage) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ValidationStage) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Variable types for template parameters.
type VariableType string

const (
	// Free-form string
	VariableTypeString VariableType = "STRING"
	// Interface name (autocomplete from router)
	VariableTypeInterface VariableType = "INTERFACE"
	// Subnet in CIDR notation
	VariableTypeSubnet VariableType = "SUBNET"
	// IP address
	VariableTypeIP VariableType = "IP"
	// Port number
	VariableTypePort VariableType = "PORT"
	// VLAN ID
	VariableTypeVlanID VariableType = "VLAN_ID"
)

var AllVariableType = []VariableType{
	VariableTypeString,
	VariableTypeInterface,
	VariableTypeSubnet,
	VariableTypeIP,
	VariableTypePort,
	VariableTypeVlanID,
}

func (e VariableType) IsValid() bool {
	switch e {
	case VariableTypeString, VariableTypeInterface, VariableTypeSubnet, VariableTypeIP, VariableTypePort, VariableTypeVlanID:
		return true
	}
	return false
}

func (e VariableType) String() string {
	return string(e)
}

func (e *VariableType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VariableType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VariableType", str)
	}
	return nil
}

func (e VariableType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VariableType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VariableType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Binary verification status.
type VerificationStatus string

const (
	// Binary passed verification
	VerificationStatusValid VerificationStatus = "VALID"
	// Binary failed verification (hash mismatch)
	VerificationStatusInvalid VerificationStatus = "INVALID"
	// Verification in progress
	VerificationStatusPending VerificationStatus = "PENDING"
	// Verification not performed (disabled or missing data)
	VerificationStatusNotVerified VerificationStatus = "NOT_VERIFIED"
)

var AllVerificationStatus = []VerificationStatus{
	VerificationStatusValid,
	VerificationStatusInvalid,
	VerificationStatusPending,
	VerificationStatusNotVerified,
}

func (e VerificationStatus) IsValid() bool {
	switch e {
	case VerificationStatusValid, VerificationStatusInvalid, VerificationStatusPending, VerificationStatusNotVerified:
		return true
	}
	return false
}

func (e VerificationStatus) String() string {
	return string(e)
}

func (e *VerificationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VerificationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VerificationStatus", str)
	}
	return nil
}

func (e VerificationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VerificationStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VerificationStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Virtual interface lifecycle status.
type VirtualInterfaceStatus string

const (
	// Interface is being created
	VirtualInterfaceStatusCreating VirtualInterfaceStatus = "CREATING"
	// Interface is active and ready
	VirtualInterfaceStatusActive VirtualInterfaceStatus = "ACTIVE"
	// Interface creation/operation failed
	VirtualInterfaceStatusError VirtualInterfaceStatus = "ERROR"
	// Interface is being removed
	VirtualInterfaceStatusRemoving VirtualInterfaceStatus = "REMOVING"
)

var AllVirtualInterfaceStatus = []VirtualInterfaceStatus{
	VirtualInterfaceStatusCreating,
	VirtualInterfaceStatusActive,
	VirtualInterfaceStatusError,
	VirtualInterfaceStatusRemoving,
}

func (e VirtualInterfaceStatus) IsValid() bool {
	switch e {
	case VirtualInterfaceStatusCreating, VirtualInterfaceStatusActive, VirtualInterfaceStatusError, VirtualInterfaceStatusRemoving:
		return true
	}
	return false
}

func (e VirtualInterfaceStatus) String() string {
	return string(e)
}

func (e *VirtualInterfaceStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VirtualInterfaceStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VirtualInterfaceStatus", str)
	}
	return nil
}

func (e VirtualInterfaceStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VirtualInterfaceStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VirtualInterfaceStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// WAN connection type classification
type WANConnectionType string

const (
	// DHCP client (dynamic IP)
	WANConnectionTypeDhcp WANConnectionType = "DHCP"
	// PPPoE dial-up connection
	WANConnectionTypePppoe WANConnectionType = "PPPOE"
	// Static IP configuration
	WANConnectionTypeStatic WANConnectionType = "STATIC"
	// LTE/cellular connection
	WANConnectionTypeLte WANConnectionType = "LTE"
	// Not configured
	WANConnectionTypeNone WANConnectionType = "NONE"
)

var AllWANConnectionType = []WANConnectionType{
	WANConnectionTypeDhcp,
	WANConnectionTypePppoe,
	WANConnectionTypeStatic,
	WANConnectionTypeLte,
	WANConnectionTypeNone,
}

func (e WANConnectionType) IsValid() bool {
	switch e {
	case WANConnectionTypeDhcp, WANConnectionTypePppoe, WANConnectionTypeStatic, WANConnectionTypeLte, WANConnectionTypeNone:
		return true
	}
	return false
}

func (e WANConnectionType) String() string {
	return string(e)
}

func (e *WANConnectionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WANConnectionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WANConnectionType", str)
	}
	return nil
}

func (e WANConnectionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WANConnectionType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WANConnectionType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// WAN event types for history tracking
type WANEventType string

const (
	// Connection established
	WANEventTypeConnected WANEventType = "CONNECTED"
	// Connection lost
	WANEventTypeDisconnected WANEventType = "DISCONNECTED"
	// Authentication failed
	WANEventTypeAuthFailed WANEventType = "AUTH_FAILED"
	// IP address changed
	WANEventTypeIPChanged WANEventType = "IP_CHANGED"
	// Gateway changed
	WANEventTypeGatewayChanged WANEventType = "GATEWAY_CHANGED"
	// Health check failed
	WANEventTypeHealthFailed WANEventType = "HEALTH_FAILED"
	// Health check recovered
	WANEventTypeHealthRecovered WANEventType = "HEALTH_RECOVERED"
)

var AllWANEventType = []WANEventType{
	WANEventTypeConnected,
	WANEventTypeDisconnected,
	WANEventTypeAuthFailed,
	WANEventTypeIPChanged,
	WANEventTypeGatewayChanged,
	WANEventTypeHealthFailed,
	WANEventTypeHealthRecovered,
}

func (e WANEventType) IsValid() bool {
	switch e {
	case WANEventTypeConnected, WANEventTypeDisconnected, WANEventTypeAuthFailed, WANEventTypeIPChanged, WANEventTypeGatewayChanged, WANEventTypeHealthFailed, WANEventTypeHealthRecovered:
		return true
	}
	return false
}

func (e WANEventType) String() string {
	return string(e)
}

func (e *WANEventType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WANEventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WANEventType", str)
	}
	return nil
}

func (e WANEventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WANEventType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WANEventType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// WAN link type enum
type WANLinkTypeEnum string

const (
	// Domestic ISP link (residential, small business)
	WANLinkTypeEnumDomestic WANLinkTypeEnum = "DOMESTIC"
	// Foreign/International link with special routing needs
	WANLinkTypeEnumForeign WANLinkTypeEnum = "FOREIGN"
)

var AllWANLinkTypeEnum = []WANLinkTypeEnum{
	WANLinkTypeEnumDomestic,
	WANLinkTypeEnumForeign,
}

func (e WANLinkTypeEnum) IsValid() bool {
	switch e {
	case WANLinkTypeEnumDomestic, WANLinkTypeEnumForeign:
		return true
	}
	return false
}

func (e WANLinkTypeEnum) String() string {
	return string(e)
}

func (e *WANLinkTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WANLinkTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WANLinkTypeEnum", str)
	}
	return nil
}

func (e WANLinkTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WANLinkTypeEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WANLinkTypeEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// WAN connection status
type WANStatus string

const (
	// Connected and online
	WANStatusConnected WANStatus = "CONNECTED"
	// Connecting/authenticating
	WANStatusConnecting WANStatus = "CONNECTING"
	// Disconnected
	WANStatusDisconnected WANStatus = "DISCONNECTED"
	// Connection failed
	WANStatusError WANStatus = "ERROR"
	// Disabled
	WANStatusDisabled WANStatus = "DISABLED"
)

var AllWANStatus = []WANStatus{
	WANStatusConnected,
	WANStatusConnecting,
	WANStatusDisconnected,
	WANStatusError,
	WANStatusDisabled,
}

func (e WANStatus) IsValid() bool {
	switch e {
	case WANStatusConnected, WANStatusConnecting, WANStatusDisconnected, WANStatusError, WANStatusDisabled:
		return true
	}
	return false
}

func (e WANStatus) String() string {
	return string(e)
}

func (e *WANStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WANStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WANStatus", str)
	}
	return nil
}

func (e WANStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WANStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WANStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Webhook authentication types
type WebhookAuthType string

const (
	// No authentication required
	WebhookAuthTypeNone WebhookAuthType = "NONE"
	// Bearer token authentication
	WebhookAuthTypeBearer WebhookAuthType = "BEARER"
	// HTTP Basic authentication
	WebhookAuthTypeBasic WebhookAuthType = "BASIC"
)

var AllWebhookAuthType = []WebhookAuthType{
	WebhookAuthTypeNone,
	WebhookAuthTypeBearer,
	WebhookAuthTypeBasic,
}

func (e WebhookAuthType) IsValid() bool {
	switch e {
	case WebhookAuthTypeNone, WebhookAuthTypeBearer, WebhookAuthTypeBasic:
		return true
	}
	return false
}

func (e WebhookAuthType) String() string {
	return string(e)
}

func (e *WebhookAuthType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookAuthType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookAuthType", str)
	}
	return nil
}

func (e WebhookAuthType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WebhookAuthType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WebhookAuthType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Webhook template types for predefined formats
type WebhookTemplate string

const (
	// Generic JSON format
	WebhookTemplateGeneric WebhookTemplate = "GENERIC"
	// Slack incoming webhook format
	WebhookTemplateSLACk WebhookTemplate = "SLACK"
	// Discord webhook format
	WebhookTemplateDiscord WebhookTemplate = "DISCORD"
	// Microsoft Teams webhook format
	WebhookTemplateTeams WebhookTemplate = "TEAMS"
	// Custom template with user-defined format
	WebhookTemplateCustom WebhookTemplate = "CUSTOM"
)

var AllWebhookTemplate = []WebhookTemplate{
	WebhookTemplateGeneric,
	WebhookTemplateSLACk,
	WebhookTemplateDiscord,
	WebhookTemplateTeams,
	WebhookTemplateCustom,
}

func (e WebhookTemplate) IsValid() bool {
	switch e {
	case WebhookTemplateGeneric, WebhookTemplateSLACk, WebhookTemplateDiscord, WebhookTemplateTeams, WebhookTemplateCustom:
		return true
	}
	return false
}

func (e WebhookTemplate) String() string {
	return string(e)
}

func (e *WebhookTemplate) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookTemplate(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookTemplate", str)
	}
	return nil
}

func (e WebhookTemplate) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WebhookTemplate) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WebhookTemplate) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Wizard step in provisioning flow
type WizardStep string

const (
	// Step 1: Choose provisioning mode and basic settings
	WizardStepChoose WizardStep = "CHOOSE"
	// Step 2: Configure WAN link
	WizardStepWan WizardStep = "WAN"
	// Step 3: Configure LAN networks
	WizardStepLan WizardStep = "LAN"
	// Step 4: Configure extra features (VPN, firewall, etc.)
	WizardStepExtra WizardStep = "EXTRA"
	// Step 5: Review all configurations
	WizardStepReview WizardStep = "REVIEW"
	// Step 6: Apply configurations
	WizardStepApply WizardStep = "APPLY"
)

var AllWizardStep = []WizardStep{
	WizardStepChoose,
	WizardStepWan,
	WizardStepLan,
	WizardStepExtra,
	WizardStepReview,
	WizardStepApply,
}

func (e WizardStep) IsValid() bool {
	switch e {
	case WizardStepChoose, WizardStepWan, WizardStepLan, WizardStepExtra, WizardStepReview, WizardStepApply:
		return true
	}
	return false
}

func (e WizardStep) String() string {
	return string(e)
}

func (e *WizardStep) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WizardStep(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WizardStep", str)
	}
	return nil
}

func (e WizardStep) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WizardStep) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WizardStep) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
