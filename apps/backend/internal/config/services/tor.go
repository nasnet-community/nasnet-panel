package services

import (
	"fmt"

	cfglib "backend/internal/config"
)

const torConfigTemplate = `# Tor configuration generated by NasNetConnect
# Instance ID: {{.InstanceID}}

# Network binding (VLAN isolation enforced)
SOCKSPort {{.BindIP}}:{{.GetInt "socks_port"}}
ControlPort {{.BindIP}}:{{.GetInt "control_port"}}

# Relay configuration
Nickname {{.GetString "nickname"}}
ContactInfo {{.GetString "contact_info"}}

{{if eq (.GetString "relay_type") "relay"}}
# Relay mode
ORPort {{.BindIP}}:{{.GetInt "or_port"}}
DirPort {{.BindIP}}:{{.GetInt "dir_port"}}
ExitPolicy reject *:*
{{else if eq (.GetString "relay_type") "bridge"}}
# Bridge mode
ORPort {{.BindIP}}:{{.GetInt "or_port"}}
BridgeRelay 1
PublishServerDescriptor 0
{{else if eq (.GetString "relay_type") "exit"}}
# Exit relay mode (WARNING: Be aware of legal implications)
ORPort {{.BindIP}}:{{.GetInt "or_port"}}
DirPort {{.BindIP}}:{{.GetInt "dir_port"}}
ExitPolicy {{.GetString "exit_policy"}}
{{end}}

# Bandwidth limits
RelayBandwidthRate {{.GetInt "bandwidth_rate"}} KB
RelayBandwidthBurst {{.GetInt "bandwidth_burst"}} KB

# Data directory
DataDirectory /var/lib/tor

# Logging
Log notice file /var/log/tor/notices.log
`

// TorGenerator generates Tor torrc configuration files.
type TorGenerator struct {
	*cfglib.BaseGenerator
}

// NewTorGenerator creates a new Tor config generator.
func NewTorGenerator() *TorGenerator {
	schema := &cfglib.Schema{
		ServiceType: "tor",
		Version:     "1.0.0",
		Fields: []cfglib.Field{
			{
				Name:        "nickname",
				Type:        "string",
				Required:    true,
				Default:     "MyTorRelay",
				Description: "Relay nickname (alphanumeric, max 19 chars)",
				Placeholder: "MyRelay",
			},
			{
				Name:        "contact_info",
				Type:        "string",
				Required:    true,
				Default:     "admin@example.com",
				Description: "Contact email for relay operator",
				Placeholder: "operator@example.com",
			},
			{
				Name:        "relay_type",
				Type:        "enum",
				Required:    true,
				Default:     "relay",
				EnumValues:  []string{"relay", "bridge", "exit"},
				Description: "Type of Tor node to run",
			},
			{
				Name:        "socks_port",
				Type:        "port",
				Required:    true,
				Default:     9050,
				Min:         intPtr(1024),
				Max:         intPtr(65535),
				Description: "SOCKS proxy port",
			},
			{
				Name:        "control_port",
				Type:        "port",
				Required:    true,
				Default:     9051,
				Min:         intPtr(1024),
				Max:         intPtr(65535),
				Description: "Control port for Tor controller",
			},
			{
				Name:        "or_port",
				Type:        "port",
				Required:    true,
				Default:     9001,
				Min:         intPtr(1024),
				Max:         intPtr(65535),
				Description: "OR (Onion Router) port",
			},
			{
				Name:        "dir_port",
				Type:        "port",
				Required:    false,
				Default:     9030,
				Min:         intPtr(1024),
				Max:         intPtr(65535),
				Description: "Directory server port (for relays)",
			},
			{
				Name:        "bandwidth_rate",
				Type:        "int",
				Required:    true,
				Default:     1000,
				Min:         intPtr(100),
				Max:         intPtr(102400),
				Description: "Bandwidth rate limit in KB/s",
			},
			{
				Name:        "bandwidth_burst",
				Type:        "int",
				Required:    true,
				Default:     2000,
				Min:         intPtr(100),
				Max:         intPtr(204800),
				Description: "Bandwidth burst limit in KB/s",
			},
			{
				Name:        "exit_policy",
				Type:        "string",
				Required:    false,
				Default:     "reject *:*",
				Description: "Exit policy (for exit relays only)",
			},
		},
	}

	tmpl := cfglib.MustParseTemplate("tor", torConfigTemplate)

	return &TorGenerator{
		BaseGenerator: cfglib.NewBaseGenerator("tor", schema, tmpl),
	}
}

// Generate generates a Tor torrc configuration file.
func (g *TorGenerator) Generate(instanceID string, config map[string]interface{}, bindIP string) ([]byte, error) {
	// Merge with defaults FIRST
	config = g.Schema.MergeWithDefaults(config)

	// Then validate (after defaults are applied)
	if validateErr := g.Validate(config, bindIP); validateErr != nil {
		return nil, fmt.Errorf("validation failed: %w", validateErr)
	}

	// Prepare template data
	data := cfglib.NewTemplateData(instanceID, bindIP, config)

	// Render template
	rendered, err := g.RenderTemplate(data)
	if err != nil {
		return nil, fmt.Errorf("render tor template: %w", err)
	}
	return rendered, nil
}

// Validate performs Tor-specific validation.
func (g *TorGenerator) Validate(config map[string]interface{}, bindIP string) error {
	// Base validation (schema + bind IP)
	if configErr := g.ValidateConfig(config, bindIP); configErr != nil {
		return fmt.Errorf("validate tor config: %w", configErr)
	}

	// Tor-specific validation
	relayType, _ := config["relay_type"].(string) //nolint:errcheck // type assertion uses zero value default
	if relayType == "exit" {
		// Exit relays require exit_policy
		if _, hasPolicy := config["exit_policy"]; !hasPolicy {
			return fmt.Errorf("exit_policy is required for exit relays")
		}
	}

	// Validate nickname format (alphanumeric, max 19 chars)
	nickname, _ := config["nickname"].(string) //nolint:errcheck // type assertion uses zero value default
	if len(nickname) > 19 {
		return fmt.Errorf("nickname must be max 19 characters, got %d", len(nickname))
	}

	// Validate contact_info is an email
	contactInfo, _ := config["contact_info"].(string) //nolint:errcheck // type assertion uses zero value default
	if emailErr := cfglib.ValidateEmail(contactInfo); emailErr != nil {
		return fmt.Errorf("validate tor contact_info email: %w", emailErr)
	}

	return nil
}

// GetConfigFileName returns the filename for the generated config.
func (g *TorGenerator) GetConfigFileName() string {
	return "torrc"
}

// GetConfigFormat returns the config file format.
func (g *TorGenerator) GetConfigFormat() string {
	return "text"
}

// Helper function for creating int pointers (same as in tests)
func intPtr(i int) *int {
	return &i
}
