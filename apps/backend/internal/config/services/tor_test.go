package services

import (
	"strings"
	"testing"
)

func TestTorGenerator_Generate(t *testing.T) {
	gen := NewTorGenerator()

	tests := []struct {
		name       string
		instanceID string
		config     map[string]interface{}
		bindIP     string
		wantErr    bool
		wantOutput []string // strings that should appear in output
	}{
		{
			name:       "valid relay config",
			instanceID: "tor-instance-123",
			config: map[string]interface{}{
				"nickname":        "MyTorRelay",
				"contact_info":    "admin@example.com",
				"relay_type":      "relay",
				"socks_port":      9050,
				"control_port":    9051,
				"or_port":         9001,
				"dir_port":        9030,
				"bandwidth_rate":  1000,
				"bandwidth_burst": 2000,
			},
			bindIP:  "192.168.1.100",
			wantErr: false,
			wantOutput: []string{
				"# Tor configuration generated by NasNetConnect",
				"tor-instance-123",
				"SOCKSPort 192.168.1.100:9050",
				"ControlPort 192.168.1.100:9051",
				"Nickname MyTorRelay",
				"ContactInfo admin@example.com",
				"ORPort 192.168.1.100:9001",
				"DirPort 192.168.1.100:9030",
				"RelayBandwidthRate 1000 KB",
				"RelayBandwidthBurst 2000 KB",
				"ExitPolicy reject *:*",
			},
		},
		{
			name:       "valid bridge config",
			instanceID: "tor-bridge-456",
			config: map[string]interface{}{
				"nickname":        "MyBridge",
				"contact_info":    "bridge@example.com",
				"relay_type":      "bridge",
				"socks_port":      9050,
				"control_port":    9051,
				"or_port":         9001,
				"bandwidth_rate":  500,
				"bandwidth_burst": 1000,
			},
			bindIP:  "10.0.0.50",
			wantErr: false,
			wantOutput: []string{
				"BridgeRelay 1",
				"PublishServerDescriptor 0",
			},
		},
		{
			name:       "reject wildcard IP",
			instanceID: "tor-test",
			config: map[string]interface{}{
				"nickname":     "Test",
				"contact_info": "test@example.com",
			},
			bindIP:  "0.0.0.0",
			wantErr: true,
		},
		{
			name:       "reject loopback IP",
			instanceID: "tor-test",
			config: map[string]interface{}{
				"nickname":     "Test",
				"contact_info": "test@example.com",
			},
			bindIP:  "127.0.0.1",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			output, err := gen.Generate(tt.instanceID, tt.config, tt.bindIP)
			if (err != nil) != tt.wantErr {
				t.Errorf("Generate() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if !tt.wantErr {
				outputStr := string(output)
				for _, want := range tt.wantOutput {
					if !strings.Contains(outputStr, want) {
						t.Errorf("Generate() output missing expected string: %s", want)
					}
				}
			}
		})
	}
}

func TestTorGenerator_Validate(t *testing.T) {
	gen := NewTorGenerator()

	tests := []struct {
		name    string
		config  map[string]interface{}
		bindIP  string
		wantErr bool
		errMsg  string
	}{
		{
			name: "valid relay config",
			config: map[string]interface{}{
				"nickname":        "MyRelay",
				"contact_info":    "admin@example.com",
				"relay_type":      "relay",
				"socks_port":      9050,
				"control_port":    9051,
				"or_port":         9001,
				"dir_port":        9030,
				"bandwidth_rate":  1000,
				"bandwidth_burst": 2000,
			},
			bindIP:  "192.168.1.1",
			wantErr: false,
		},
		{
			name: "nickname too long",
			config: map[string]interface{}{
				"nickname":        "ThisNicknameIsTooLong",
				"contact_info":    "admin@example.com",
				"relay_type":      "relay",
				"socks_port":      9050,
				"control_port":    9051,
				"or_port":         9001,
				"bandwidth_rate":  1000,
				"bandwidth_burst": 2000,
			},
			bindIP:  "192.168.1.1",
			wantErr: true,
			errMsg:  "nickname must be max 19 characters",
		},
		{
			name: "invalid email",
			config: map[string]interface{}{
				"nickname":        "MyRelay",
				"contact_info":    "not-an-email",
				"relay_type":      "relay",
				"socks_port":      9050,
				"control_port":    9051,
				"or_port":         9001,
				"bandwidth_rate":  1000,
				"bandwidth_burst": 2000,
			},
			bindIP:  "192.168.1.1",
			wantErr: true,
			errMsg:  "must be a valid email",
		},
		{
			name: "exit relay without exit_policy",
			config: map[string]interface{}{
				"nickname":        "MyRelay",
				"contact_info":    "admin@example.com",
				"relay_type":      "exit",
				"socks_port":      9050,
				"control_port":    9051,
				"or_port":         9001,
				"bandwidth_rate":  1000,
				"bandwidth_burst": 2000,
			},
			bindIP:  "192.168.1.1",
			wantErr: true,
			errMsg:  "exit_policy is required for exit relays",
		},
		{
			name: "wildcard IP rejected",
			config: map[string]interface{}{
				"nickname":        "MyRelay",
				"contact_info":    "admin@example.com",
				"relay_type":      "relay",
				"socks_port":      9050,
				"control_port":    9051,
				"or_port":         9001,
				"bandwidth_rate":  1000,
				"bandwidth_burst": 2000,
			},
			bindIP:  "0.0.0.0",
			wantErr: true,
			errMsg:  "wildcard IP addresses",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := gen.Validate(tt.config, tt.bindIP)
			if (err != nil) != tt.wantErr {
				t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
			}
			if tt.wantErr && tt.errMsg != "" && err != nil {
				if !strings.Contains(err.Error(), tt.errMsg) {
					t.Errorf("Validate() error message = %v, want to contain %v", err.Error(), tt.errMsg)
				}
			}
		})
	}
}

func TestTorGenerator_GetSchema(t *testing.T) {
	gen := NewTorGenerator()
	schema := gen.GetSchema()

	if schema.ServiceType != "tor" {
		t.Errorf("GetSchema() ServiceType = %v, want tor", schema.ServiceType)
	}

	if len(schema.Fields) == 0 {
		t.Error("GetSchema() returned schema with no fields")
	}

	// Verify required fields exist
	requiredFields := []string{"nickname", "contact_info", "relay_type", "socks_port"}
	fieldMap := make(map[string]bool)
	for _, field := range schema.Fields {
		fieldMap[field.Name] = true
	}

	for _, required := range requiredFields {
		if !fieldMap[required] {
			t.Errorf("GetSchema() missing required field: %s", required)
		}
	}
}

func TestTorGenerator_GetConfigFileName(t *testing.T) {
	gen := NewTorGenerator()
	fileName := gen.GetConfigFileName()

	if fileName != "torrc" {
		t.Errorf("GetConfigFileName() = %v, want torrc", fileName)
	}
}

func TestTorGenerator_GetConfigFormat(t *testing.T) {
	gen := NewTorGenerator()
	format := gen.GetConfigFormat()

	if format != "text" {
		t.Errorf("GetConfigFormat() = %v, want text", format)
	}
}
