// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package bootstrap

import (
	"backend/generated/ent"
	"backend/internal/adapters"
	"backend/internal/alerts"
	"backend/internal/alerts/digest"
	"backend/internal/auth"
	"backend/internal/capability"
	"backend/internal/config"
	"backend/internal/credentials"
	"backend/internal/diagnostics"
	"backend/internal/dns"
	"backend/internal/encryption"
	"backend/internal/events"
	"backend/internal/features"
	"backend/internal/features/sharing"
	"backend/internal/features/updates"
	"backend/internal/firewall"
	isolation2 "backend/internal/isolation"
	"backend/internal/network"
	"backend/internal/notifications"
	"backend/internal/notifications/channels/http"
	"backend/internal/notifications/channels/push"
	"backend/internal/orchestrator"
	"backend/internal/orchestrator/boot"
	"backend/internal/orchestrator/dependencies"
	"backend/internal/orchestrator/isolation"
	"backend/internal/orchestrator/lifecycle"
	"backend/internal/orchestrator/resources"
	"backend/internal/orchestrator/scheduling"
	"backend/internal/orchestrator/supervisor"
	"backend/internal/registry"
	"backend/internal/router"
	"backend/internal/scanner"
	"backend/internal/services"
	"backend/internal/services/base"
	"backend/internal/services/bridge"
	"backend/internal/services/integration"
	"backend/internal/services/monitoring"
	"backend/internal/services/netif"
	"backend/internal/services/networking/vlan"
	"backend/internal/services/pollers"
	"backend/internal/services/wan"
	"backend/internal/storage"
	"backend/internal/templates"
	"backend/internal/traceroute"
	"backend/internal/vif"
	"backend/internal/vif/dhcp"
	"backend/internal/vif/ingress"
	isolation3 "backend/internal/vif/isolation"
	"backend/internal/vif/routing"
	"backend/internal/vif/traffic"
	"context"
	"github.com/google/wire"
	"go.uber.org/zap"
	"log/slog"
	"path/filepath"
	"time"
)

// Injectors from wire_alerts.go:

// InjectAlertSystem is a Wire injector that constructs the complete alert system.
func InjectAlertSystem(ctx context.Context, systemDB *ent.Client, eventBus events.EventBus, sugar *zap.SugaredLogger) (*AlertComponents, error) {
	v := provideNotificationChannels(eventBus)
	templateRenderer := provideNotificationTemplateService(systemDB, sugar)
	dispatcher, err := provideDispatcher(ctx, systemDB, eventBus, v, templateRenderer, sugar)
	if err != nil {
		return nil, err
	}
	engine := provideEscalationEngine(systemDB, dispatcher, eventBus, sugar)
	service, err := provideDigestService(systemDB, dispatcher, eventBus, sugar)
	if err != nil {
		return nil, err
	}
	scheduler := provideDigestScheduler(ctx, service, sugar)
	svcalertService := provideAlertService(systemDB, eventBus, engine, service, sugar)
	templateService, err := provideAlertTemplateService(systemDB, svcalertService, sugar)
	if err != nil {
		return nil, err
	}
	alerttplService, err := provideAlertRuleTemplateService(svcalertService, systemDB)
	if err != nil {
		return nil, err
	}
	alertsEngine, err := provideAlertEngine(ctx, systemDB, eventBus, dispatcher, engine, service, sugar)
	if err != nil {
		return nil, err
	}
	alertComponents := &AlertComponents{
		Dispatcher:               dispatcher,
		EscalationEngine:         engine,
		DigestService:            service,
		DigestScheduler:          scheduler,
		AlertService:             svcalertService,
		AlertTemplateService:     templateService,
		TemplateService:          templateRenderer,
		AlertRuleTemplateService: alerttplService,
		AlertEngine:              alertsEngine,
	}
	return alertComponents, nil
}

// Injectors from wire_core.go:

// InjectCoreServices is a Wire injector that constructs all core infrastructure services.
func InjectCoreServices(systemDB *ent.Client, eventBus events.EventBus, routerPort *router.MockAdapter, logger *zap.SugaredLogger, encryptionService *encryption.Service) (*CoreComponents, error) {
	service := provideAuthService()
	scannerService := provideScannerService(eventBus, logger)
	capabilityService := provideCapabilityService()
	routerService := provideRouterService(systemDB, eventBus, encryptionService, logger)
	credentialsService, err := provideCredentialService(encryptionService, logger)
	if err != nil {
		return nil, err
	}
	coreComponents := &CoreComponents{
		AuthService:       service,
		ScannerService:    scannerService,
		CapabilityService: capabilityService,
		RouterService:     routerService,
		CredentialService: credentialsService,
	}
	return coreComponents, nil
}

// Injectors from wire_diagnostics.go:

// InjectDiagnostics is a Wire injector that constructs the diagnostics components.
func InjectDiagnostics(routerPort *router.MockAdapter, logger *zap.SugaredLogger) (*DiagnosticsComponents, error) {
	service := provideDiagnosticsService()
	tracerouteService := provideTracerouteService(routerPort, logger)
	dnsService := provideDnsService(routerPort, logger)
	diagnosticsComponents := &DiagnosticsComponents{
		DiagnosticsService: service,
		TracerouteService:  tracerouteService,
		DnsService:         dnsService,
	}
	return diagnosticsComponents, nil
}

// Injectors from wire_firewall.go:

// InjectFirewallServices is a Wire injector that constructs the firewall service components.
func InjectFirewallServices(logger *zap.SugaredLogger) (*FirewallComponents, error) {
	templateService, err := provideFirewallTemplateService(logger)
	if err != nil {
		return nil, err
	}
	addressListService := provideAddressListService(logger)
	firewallComponents := &FirewallComponents{
		TemplateService:    templateService,
		AddressListService: addressListService,
	}
	return firewallComponents, nil
}

// Injectors from wire_integration.go:

// InjectIntegrationServices is a Wire injector that constructs the complete integration services.
func InjectIntegrationServices(systemDB *ent.Client, eventBus events.EventBus, encryptionService *encryption.Service, dispatcher *notifications.Dispatcher, routerPort *router.MockAdapter, featureRegistry *features.FeatureRegistry, configRegistry *config.Registry, pathResolver storage.PathResolverPort, portRegistry *network.PortRegistry, vlanAllocator *network.VLANAllocator, logger *zap.Logger, sugar *zap.SugaredLogger) (*IntegrationComponents, error) {
	service := provideWebhookService(systemDB, encryptionService, dispatcher, eventBus, sugar)
	sharingService := provideSharingService(systemDB, routerPort, eventBus, featureRegistry, logger)
	configService, err := provideConfigService(configRegistry, systemDB, eventBus, pathResolver, portRegistry, vlanAllocator, logger)
	if err != nil {
		return nil, err
	}
	credentialsService, err := provideIntegrationCredentialService(encryptionService)
	if err != nil {
		return nil, err
	}
	integrationComponents := &IntegrationComponents{
		WebhookService:    service,
		SharingService:    sharingService,
		ConfigService:     configService,
		CredentialService: credentialsService,
	}
	return integrationComponents, nil
}

// Injectors from wire_monitoring.go:

// InjectMonitoringServices is a Wire injector that constructs all monitoring components.
func InjectMonitoringServices(systemDB *ent.Client, eventBus events.EventBus, routerPort *router.MockAdapter, logger *zap.SugaredLogger) (*MonitoringComponents, error) {
	telemetryService := provideTelemetryService(systemDB, eventBus, routerPort)
	statsPoller := provideStatsPoller(routerPort, eventBus)
	monitoringComponents := &MonitoringComponents{
		TelemetryService: telemetryService,
		StatsPoller:      statsPoller,
	}
	return monitoringComponents, nil
}

// Injectors from wire_network.go:

// InjectNetworkServices is a Wire injector that constructs the network service components.
func InjectNetworkServices(eventBus events.EventBus, routerPort *router.MockAdapter, logger *zap.SugaredLogger) (*NetworkComponents, error) {
	ipAddressService := provideIPAddressService(eventBus, routerPort, logger)
	wanService := provideWANService(eventBus, routerPort, logger)
	service := provideBridgeService(eventBus, routerPort, logger)
	vlanService := provideVlanService(routerPort, logger)
	networkComponents := &NetworkComponents{
		IPAddressService: ipAddressService,
		WANService:       wanService,
		BridgeService:    service,
		VlanService:      vlanService,
	}
	return networkComponents, nil
}

// Injectors from wire_orchestrator.go:

// InjectOrchestrator is a Wire injector that constructs all orchestrator components.
func InjectOrchestrator(systemDB *ent.Client, eventBus events.EventBus, pathResolver storage.PathResolverPort, gatewayManager lifecycle.GatewayPort, bridgeOrchestrator *vif.BridgeOrchestrator, vlanAllocator *network.VLANAllocator, routerPort *router.MockAdapter, sugar *zap.SugaredLogger) (*OrchestratorComponents, error) {
	featureRegistry, err := provideFeatureRegistry()
	if err != nil {
		return nil, err
	}
	downloadManager := provideDownloadManager(eventBus)
	processSupervisor := provideProcessSupervisor(sugar)
	entNetworkAdapter := provideNetworkStore(systemDB)
	portRegistry, err := providePortRegistry(entNetworkAdapter)
	if err != nil {
		return nil, err
	}
	configValidatorAdapter := provideConfigValidator(sugar)
	isolationVerifier, err := provideIsolationVerifier(portRegistry, configValidatorAdapter, eventBus, sugar)
	if err != nil {
		return nil, err
	}
	resourceLimiter, err := provideResourceLimiter(eventBus, sugar)
	if err != nil {
		return nil, err
	}
	resourceManager, err := provideResourceManager(systemDB, sugar)
	if err != nil {
		return nil, err
	}
	resourcePoller, err := provideResourcePoller(resourceLimiter, eventBus, sugar)
	if err != nil {
		return nil, err
	}
	strategy := provideIsolationStrategy(sugar)
	gitHubClient := provideGitHubClient()
	instanceManager, err := provideInstanceManager(systemDB, eventBus, featureRegistry, downloadManager, processSupervisor, gatewayManager, bridgeOrchestrator, vlanAllocator, pathResolver, portRegistry, isolationVerifier, strategy, resourceLimiter, resourceManager, resourcePoller, gitHubClient, sugar)
	if err != nil {
		return nil, err
	}
	dependencyManager, err := provideDependencyManager(systemDB, eventBus, sugar)
	if err != nil {
		return nil, err
	}
	bootSequenceManager, err := provideBootSequenceManager(systemDB, eventBus, instanceManager, dependencyManager, sugar)
	if err != nil {
		return nil, err
	}
	orchestratorComponents := &OrchestratorComponents{
		FeatureRegistry:     featureRegistry,
		DownloadManager:     downloadManager,
		ProcessSupervisor:   processSupervisor,
		PortRegistry:        portRegistry,
		VLANAllocator:       vlanAllocator,
		ConfigValidator:     configValidatorAdapter,
		IsolationVerifier:   isolationVerifier,
		ResourceLimiter:     resourceLimiter,
		ResourceManager:     resourceManager,
		ResourcePoller:      resourcePoller,
		InstanceManager:     instanceManager,
		DependencyManager:   dependencyManager,
		BootSequenceManager: bootSequenceManager,
	}
	return orchestratorComponents, nil
}

// Injectors from wire_routing.go:

// InjectRouting is a Wire injector that constructs the complete routing engine.
func InjectRouting(systemDB *ent.Client, eventBus events.EventBus, routerPort *router.MockAdapter, featureRegistry *features.FeatureRegistry, logger *zap.SugaredLogger) (*RoutingComponents, error) {
	chainRouter, err := provideChainRouter(routerPort, systemDB, eventBus)
	if err != nil {
		return nil, err
	}
	pbrEngine := providePBREngine(routerPort, systemDB, eventBus)
	routingMatrixService := provideRoutingMatrixService(routerPort, systemDB)
	chainLatencyMeasurer := provideChainLatencyMeasurer(systemDB, eventBus, featureRegistry)
	routingComponents := &RoutingComponents{
		ChainRouter:          chainRouter,
		PBREngine:            pbrEngine,
		RoutingMatrixSvc:     routingMatrixService,
		ChainLatencyMeasurer: chainLatencyMeasurer,
	}
	return routingComponents, nil
}

// Injectors from wire_scheduling.go:

// InjectScheduling is a Wire injector that constructs the complete scheduling system.
func InjectScheduling(systemDB *ent.Client, eventBus events.EventBus, killSwitchCoord orchestrator.KillSwitchCoordinator, sugar *zap.SugaredLogger) (*SchedulingComponents, error) {
	scheduleEvaluator, err := provideScheduleEvaluator(systemDB, eventBus, killSwitchCoord, sugar)
	if err != nil {
		return nil, err
	}
	scheduleService, err := provideScheduleService(systemDB, scheduleEvaluator, eventBus, sugar)
	if err != nil {
		return nil, err
	}
	schedulingComponents := &SchedulingComponents{
		ScheduleService:   scheduleService,
		ScheduleEvaluator: scheduleEvaluator,
	}
	return schedulingComponents, nil
}

// Injectors from wire_storage.go:

// InjectStorage is a Wire injector that constructs the complete storage infrastructure.
func InjectStorage(ctx context.Context, systemDB *ent.Client, eventBus events.EventBus, storageLogger *zap.SugaredLogger) (*StorageComponents, error) {
	publisher := provideStoragePublisher(eventBus)
	storageDetector := provideStorageDetector(publisher, storageLogger)
	storageConfigService := provideStorageConfigService(systemDB, storageDetector, publisher, storageLogger)
	pathResolverPort := providePathResolver()
	bootValidator, err := provideBootValidator(ctx, systemDB, pathResolverPort, eventBus, storageLogger)
	if err != nil {
		return nil, err
	}
	storageComponents := &StorageComponents{
		Detector:      storageDetector,
		Service:       storageConfigService,
		PathResolver:  pathResolverPort,
		BootValidator: bootValidator,
	}
	return storageComponents, nil
}

// Injectors from wire_templates.go:

// InjectTemplateSystem is a Wire injector that constructs the complete template system.
func InjectTemplateSystem(systemDB *ent.Client, eventBus events.EventBus, instanceManager *lifecycle.InstanceManager, dependencyManager *dependencies.DependencyManager, logger *zap.Logger) (*TemplateComponents, error) {
	templateService, err := provideTemplateService(instanceManager, dependencyManager, eventBus, logger)
	if err != nil {
		return nil, err
	}
	templateValidator := provideTemplateValidator(logger)
	templateInstaller, err := provideTemplateInstaller(templateService, instanceManager, dependencyManager, eventBus, logger)
	if err != nil {
		return nil, err
	}
	templateExporter, err := provideTemplateExporter(systemDB, logger)
	if err != nil {
		return nil, err
	}
	templateImporter, err := provideTemplateImporter(systemDB, templateValidator, logger)
	if err != nil {
		return nil, err
	}
	templateComponents := &TemplateComponents{
		TemplateService:   templateService,
		TemplateValidator: templateValidator,
		TemplateInstaller: templateInstaller,
		TemplateExporter:  templateExporter,
		TemplateImporter:  templateImporter,
	}
	return templateComponents, nil
}

// Injectors from wire_traffic.go:

// InjectTrafficManagement is a Wire injector that constructs the complete traffic management system.
func InjectTrafficManagement(ctx context.Context, systemDB *ent.Client, eventBus events.EventBus, routerPort *router.MockAdapter, logger *zap.Logger) (*TrafficComponents, error) {
	serviceTrafficPoller := provideServiceTrafficPoller(routerPort, eventBus)
	trafficAggregator := provideTrafficAggregator(ctx, systemDB)
	deviceTrafficTracker := provideDeviceTrafficTracker(routerPort)
	quotaEnforcer := provideQuotaEnforcer(systemDB, eventBus, routerPort)
	trafficComponents := &TrafficComponents{
		ServiceTrafficPoller: serviceTrafficPoller,
		TrafficAggregator:    trafficAggregator,
		DeviceTrafficTracker: deviceTrafficTracker,
		QuotaEnforcer:        quotaEnforcer,
	}
	return trafficComponents, nil
}

// Injectors from wire_updates.go:

// InjectUpdateManager is a Wire injector that constructs the complete update manager.
func InjectUpdateManager(ctx context.Context, systemDB *ent.Client, eventBus events.EventBus, pathResolver storage.PathResolverPort, downloadManager *features.DownloadManager, instanceManager *lifecycle.InstanceManager, dataDir string, logger *zap.Logger) (*UpdateComponents, error) {
	gitHubClient := provideUpdateGitHubClient()
	updateService, err := provideUpdateService(gitHubClient)
	if err != nil {
		return nil, err
	}
	verifier := provideUpdateVerifier()
	updateJournal, err := provideUpdateJournal(dataDir)
	if err != nil {
		return nil, err
	}
	migratorRegistry := provideUpdateMigratorRegistry()
	updatesDownloadManager := provideUpdateDownloadManager(downloadManager)
	bootstrapInstanceHealthAdapter := provideHealthCheckerAdapter(instanceManager)
	updateEngine, err := provideUpdateEngine(updatesDownloadManager, verifier, updateJournal, migratorRegistry, pathResolver, dataDir, eventBus, logger, bootstrapInstanceHealthAdapter, instanceManager)
	if err != nil {
		return nil, err
	}
	updateScheduler, err := provideUpdateScheduler(updateService, updateEngine, systemDB, eventBus, logger)
	if err != nil {
		return nil, err
	}
	updateComponents := &UpdateComponents{
		GitHubClient:     gitHubClient,
		UpdateService:    updateService,
		Verifier:         verifier,
		Journal:          updateJournal,
		MigratorRegistry: migratorRegistry,
		UpdateEngine:     updateEngine,
		UpdateScheduler:  updateScheduler,
	}
	return updateComponents, nil
}

// Injectors from wire_vif.go:

// InjectVIF is a Wire injector that constructs all VIF components.
func InjectVIF(ctx context.Context, systemDB *ent.Client, eventBus events.EventBus, pathResolver storage.PathResolverPort, routerPort *router.MockAdapter, logger *zap.Logger) (*VIFComponents, error) {
	vlanAllocator, err := provideNetworkVLANAllocator(systemDB, routerPort)
	if err != nil {
		return nil, err
	}
	vifVLANAllocator := provideVLANAllocatorAdapter(vlanAllocator)
	interfaceFactory := provideInterfaceFactory(systemDB, eventBus, routerPort)
	gatewayManager, err := provideGatewayManager(pathResolver, logger)
	if err != nil {
		return nil, err
	}
	server := provideDHCPServer(logger)
	service := provideIngressService(routerPort, server, vifVLANAllocator, logger)
	bridgeOrchestrator := provideBridgeOrchestrator(systemDB, eventBus, interfaceFactory, gatewayManager, vifVLANAllocator, routerPort, service)
	killSwitchManager := provideKillSwitchManager(systemDB, eventBus, routerPort)
	vifComponents := &VIFComponents{
		NetworkVLANAllocator: vlanAllocator,
		VLANAllocator:        vifVLANAllocator,
		InterfaceFactory:     interfaceFactory,
		GatewayManager:       gatewayManager,
		BridgeOrchestrator:   bridgeOrchestrator,
		IngressService:       service,
		KillSwitchManager:    killSwitchManager,
	}
	return vifComponents, nil
}

// wire_alerts.go:

// provideNotificationChannels creates the notification channels map.
func provideNotificationChannels(eventBus events.EventBus) map[string]notifications.Channel {
	return map[string]notifications.Channel{
		"email":    http.NewEmailChannel(http.EmailConfig{}),
		"telegram": push.NewTelegramChannel(push.TelegramConfig{}),
		"pushover": push.NewPushoverChannel(push.PushoverConfig{}),
		"webhook":  http.NewWebhookChannel(http.WebhookConfig{}),
		"inapp":    push.NewInAppChannel(eventBus),
	}
}

// provideNotificationTemplateService creates the notification template service.
func provideNotificationTemplateService(
	systemDB *ent.Client,
	sugar *zap.SugaredLogger,
) notifications.TemplateRenderer {
	return notifications.NewTemplateService(notifications.TemplateServiceConfig{
		DB:     systemDB,
		Logger: sugar,
	})
}

// provideDispatcher creates and initializes the notification dispatcher.
func provideDispatcher(
	ctx context.Context,
	systemDB *ent.Client,
	eventBus events.EventBus,
	channels map[string]notifications.Channel,
	templateService notifications.TemplateRenderer,
	sugar *zap.SugaredLogger,
) (*notifications.Dispatcher, error) {
	dispatcher := notifications.NewDispatcher(notifications.DispatcherConfig{
		Channels:        channels,
		Logger:          sugar.Desugar(),
		TemplateService: templateService,
		DB:              systemDB,
		MaxRetries:      3,
		InitialBackoff:  1 * time.Second,
	})

	if err := eventBus.Subscribe(events.EventTypeAlertCreated, dispatcher.HandleAlertCreated); err != nil {
		return nil, err
	}

	return dispatcher, nil
}

// provideEscalationEngine creates the escalation engine.
func provideEscalationEngine(
	systemDB *ent.Client,
	dispatcher *notifications.Dispatcher,
	eventBus events.EventBus,
	sugar *zap.SugaredLogger,
) *alerts.EscalationEngine {
	eventBusAdapter2 := &eventBusAdapter{bus: eventBus}
	return alerts.NewEscalationEngine(alerts.EscalationEngineConfig{
		DB:         systemDB,
		Dispatcher: dispatcher,
		EventBus:   eventBusAdapter2,
		Logger:     sugar,
	})
}

// provideDigestService creates the digest service.
func provideDigestService(
	systemDB *ent.Client,
	dispatcher *notifications.Dispatcher,
	eventBus events.EventBus,
	sugar *zap.SugaredLogger,
) (*digest.Service, error) {
	return alerts.NewDigestService(alerts.DigestServiceConfig{
		DB:         systemDB,
		Dispatcher: dispatcher,
		EventBus:   eventBus,
		Logger:     sugar,
	})
}

// provideDigestScheduler creates and starts the digest scheduler.
func provideDigestScheduler(
	ctx context.Context,
	digestService *digest.Service,
	sugar *zap.SugaredLogger,
) *alerts.DigestScheduler {
	scheduler := alerts.NewDigestScheduler(alerts.DigestSchedulerConfig{
		DigestService: digestService,
		Logger:        sugar,
	})

	if schedErr := scheduler.Start(ctx); schedErr != nil {
		sugar.Warnw("failed to start digest scheduler", zap.Error(schedErr))
	}

	return scheduler
}

// provideAlertService creates the alert service.
func provideAlertService(
	systemDB *ent.Client,
	eventBus events.EventBus,
	escalationEngine *alerts.EscalationEngine,
	digestService *digest.Service,
	sugar *zap.SugaredLogger,
) *services.AlertService {
	return services.NewAlertService(services.AlertServiceConfig{
		DB:                  systemDB,
		EventBus:            eventBus,
		EscalationCanceller: escalationEngine,
		DigestService:       &digestServiceAdapter{svc: digestService},
		Logger:              sugar,
	})
}

// provideAlertRuleTemplateService creates the alert rule template service.
func provideAlertRuleTemplateService(
	alertService *services.AlertService,
	systemDB *ent.Client,
) (*alerts.AlertRuleTemplateService, error) {
	return alerts.NewAlertRuleTemplateService(alertService, systemDB)
}

// provideAlertEngine creates and starts the alert engine.
func provideAlertEngine(
	ctx context.Context,
	systemDB *ent.Client,
	eventBus events.EventBus,
	dispatcher *notifications.Dispatcher,
	escalationEngine *alerts.EscalationEngine,
	digestService *digest.Service,
	sugar *zap.SugaredLogger,
) (*alerts.Engine, error) {
	alertEngine := alerts.NewEngine(alerts.EngineConfig{
		DB:               systemDB,
		EventBus:         eventBus,
		Dispatcher:       dispatcher,
		EscalationEngine: escalationEngine,
		DigestService:    digestService,
		Logger:           sugar,
	})

	if engineErr := alertEngine.Start(ctx); engineErr != nil {
		return nil, engineErr
	}

	return alertEngine, nil
}

// provideAlertTemplateService creates the alert template service.
func provideAlertTemplateService(
	systemDB *ent.Client,
	alertService *services.AlertService,
	sugar *zap.SugaredLogger,
) (*services.AlertTemplateService, error) {
	return services.NewAlertTemplateService(services.AlertTemplateServiceConfig{
		DB:           systemDB,
		Logger:       sugar,
		AlertService: alertService,
	})
}

// AlertProviders is a Wire provider set for all alert system components.
var AlertProviders = wire.NewSet(
	provideNotificationChannels,
	provideNotificationTemplateService,
	provideDispatcher,
	provideEscalationEngine,
	provideDigestService,
	provideDigestScheduler,
	provideAlertService,
	provideAlertRuleTemplateService,
	provideAlertEngine,
	provideAlertTemplateService, wire.Struct(new(AlertComponents), "*"),
)

// wire_core.go:

// provideScannerService creates the scanner service.
func provideScannerService(
	eventBus events.EventBus,
	logger *zap.SugaredLogger,
) *scanner.ScannerService {
	return scanner.NewServiceWithDefaults(eventBus, logger.Desugar())
}

// provideCapabilityService creates the capability service with detector and cache.
func provideCapabilityService() *capability.Service {
	detector := capability.NewDetector()
	cache := capability.NewMemoryCache()
	return capability.NewService(detector, cache)
}

// provideCredentialService creates the credential service if encryption is available.
func provideCredentialService(
	encryptionService *encryption.Service,
	logger *zap.SugaredLogger,
) (*credentials.Service, error) {
	if encryptionService == nil {
		logger.Infow("Credential service: skipped (no encryption service)")
		return nil, nil
	}

	credSvc, err := credentials.NewService(encryptionService)
	if err != nil {
		logger.Warnw("Credential service initialization failed", "error", err)
		return nil, err
	}

	logger.Infow("Credential service initialized")
	return credSvc, nil
}

// provideRouterService creates the router service if encryption is available.
func provideRouterService(
	systemDB *ent.Client,
	eventBus events.EventBus,
	encryptionService *encryption.Service,
	logger *zap.SugaredLogger,
) *services.RouterService {
	if encryptionService == nil {
		logger.Infow("Router service: skipped (no encryption service)")
		return nil
	}

	routerService := services.NewRouterService(services.RouterServiceConfig{
		EventBus:          eventBus,
		EncryptionService: encryptionService,
		DB:                systemDB,
	})
	logger.Infow("Router service initialized")
	return routerService
}

// provideAuthService provides a nil auth service (auth is initialized separately in production).
func provideAuthService() *auth.Service {
	return nil
}

// CoreProviders is a Wire provider set for all core service components.
var CoreProviders = wire.NewSet(
	provideScannerService,
	provideCapabilityService,
	provideCredentialService,
	provideRouterService,
	provideAuthService, wire.Struct(new(CoreComponents), "*"),
)

// wire_diagnostics.go:

// provideDiagnosticsService creates the diagnostics service.
func provideDiagnosticsService() *diagnostics.Service {
	return diagnostics.NewService(diagnostics.Config{
		DocsBaseURL:     "https://docs.nasnetconnect.io",
		RateLimitPeriod: 0,
		RouterProvider:  nil,
		CBProvider:      nil,
	})
}

// provideTracerouteService creates the traceroute service.
// Note: Returns nil as it requires traceroute.RouterPort adapter not yet available.
func provideTracerouteService(
	_ *router.MockAdapter,
	sugar *zap.SugaredLogger,
) *traceroute.Service {
	sugar.Infow("traceroute service deferred", zap.String("reason", "requires traceroute.RouterPort adapter"))
	return nil
}

// provideDnsService creates the DNS service.
// Note: Returns nil as it requires dns.RouterPort adapter not yet available.
func provideDnsService(
	_ *router.MockAdapter,
	sugar *zap.SugaredLogger,
) *dns.Service {
	sugar.Infow("DNS service deferred", zap.String("reason", "requires dns.RouterPort adapter"))
	return nil
}

// DiagnosticsProviders is a Wire provider set for all diagnostics components.
var DiagnosticsProviders = wire.NewSet(
	provideDiagnosticsService,
	provideTracerouteService,
	provideDnsService, wire.Struct(new(DiagnosticsComponents), "*"),
)

// wire_firewall.go:

// provideFirewallTemplateService creates the firewall template service.
func provideFirewallTemplateService(sugar *zap.SugaredLogger) (*firewall.TemplateService, error) {
	service, err := firewall.NewTemplateService()
	if err != nil {
		return nil, err
	}
	sugar.Infow("firewall template service initialized")
	return service, nil
}

// provideAddressListService creates the address list service.
func provideAddressListService(sugar *zap.SugaredLogger) *firewall.AddressListService {
	service := firewall.NewAddressListService()
	sugar.Infow("address list service initialized")
	return service
}

// FirewallProviders is a Wire provider set for all firewall service components.
var FirewallProviders = wire.NewSet(
	provideFirewallTemplateService,
	provideAddressListService, wire.Struct(new(FirewallComponents), "*"),
)

// wire_integration.go:

// provideWebhookService creates the webhook service for webhook CRUD with encryption.
func provideWebhookService(
	systemDB *ent.Client,
	encryptionService *encryption.Service,
	dispatcher *notifications.Dispatcher,
	eventBus events.EventBus,
	sugar *zap.SugaredLogger,
) *integration.Service {
	return integration.NewService(integration.Config{
		DB:         systemDB,
		Encryption: encryptionService,
		Dispatcher: dispatcher,
		EventBus:   eventBus,
		Logger:     sugar,
	})
}

// provideSharingService creates the sharing service for service configuration export/import.
func provideSharingService(
	systemDB *ent.Client,
	routerPort *router.MockAdapter,
	eventBus events.EventBus,
	featureRegistry *features.FeatureRegistry,
	logger *zap.Logger,
) *sharing.Service {
	sharingRegistry := sharing.NewFeatureRegistryFromFunc(featureRegistry.GetManifest)
	return sharing.NewService(systemDB, routerPort, eventBus, sharingRegistry, nil, logger)
}

// provideConfigService creates the config service for configuration generation and management.
func provideConfigService(
	configRegistry *config.Registry,
	systemDB *ent.Client,
	eventBus events.EventBus,
	pathResolver storage.PathResolverPort,
	portRegistry *network.PortRegistry,
	vlanAllocator *network.VLANAllocator,
	logger *zap.Logger,
) (*config.Service, error) {
	return config.NewService(config.Config{
		Registry:      configRegistry,
		Store:         systemDB,
		EventBus:      eventBus,
		PathResolver:  pathResolver,
		PortRegistry:  portRegistry,
		VLANAllocator: vlanAllocator,
		Logger:        logger,
	})
}

// provideIntegrationCredentialService creates the credential service for encrypted storage.
func provideIntegrationCredentialService(
	encryptionService *encryption.Service,
) (*credentials.Service, error) {
	return credentials.NewService(encryptionService)
}

// IntegrationProviders is a Wire provider set for all integration service components.
var IntegrationProviders = wire.NewSet(
	provideWebhookService,
	provideSharingService,
	provideConfigService,
	provideIntegrationCredentialService, wire.Struct(new(IntegrationComponents), "*"),
)

// wire_monitoring.go:

// provideTelemetryService creates the telemetry service with three-tier architecture.
// Tier 1 (Hot): Last 1 hour at full resolution
// Tier 2 (Warm): Last 24 hours at 5-minute aggregation
// Tier 3 (Cold): Last 30 days at 1-hour aggregation
func provideTelemetryService(
	systemDB *ent.Client,
	eventBus events.EventBus,
	routerPort *router.MockAdapter,
) *monitoring.TelemetryService {
	return monitoring.NewTelemetryService(routerPort, systemDB, eventBus)
}

// provideStatsPoller creates the real-time interface statistics poller.
func provideStatsPoller(
	routerPort *router.MockAdapter,
	eventBus events.EventBus,
) *pollers.StatsPoller {
	return pollers.NewStatsPoller(routerPort, eventBus)
}

// MonitoringProviders is a Wire provider set for all monitoring components.
var MonitoringProviders = wire.NewSet(
	provideTelemetryService,
	provideStatsPoller, wire.Struct(new(MonitoringComponents), "*"),
)

// wire_network.go:

// provideIPAddressService creates the IP address service.
func provideIPAddressService(
	eventBus events.EventBus,
	routerPort *router.MockAdapter,
	sugar *zap.SugaredLogger,
) *netif.IPAddressService {
	service := netif.NewIPAddressService(netif.IPAddressServiceConfig{
		RouterPort: routerPort,
		EventBus:   eventBus,
	})
	sugar.Infow("IP address service initialized", "cache_ttl", "10s")
	return service
}

// provideWANService creates the WAN service.
func provideWANService(
	eventBus events.EventBus,
	routerPort *router.MockAdapter,
	sugar *zap.SugaredLogger,
) *wan.WANService {
	service := wan.NewWANService(wan.WANServiceConfig{
		RouterPort: routerPort,
		EventBus:   eventBus,
	})
	sugar.Infow("WAN service initialized", "cache_ttl", "30s", "health_monitor", "enabled")
	return service
}

// provideBridgeService creates the bridge service.
func provideBridgeService(
	eventBus events.EventBus,
	routerPort *router.MockAdapter,
	sugar *zap.SugaredLogger,
) *bridge.Service {
	service := bridge.NewService(base.ServiceConfig{
		RouterPort: routerPort,
		EventBus:   eventBus,
	})
	sugar.Infow("Bridge service initialized", "undo_support", "10s")
	return service
}

// provideVlanService creates the VLAN service.
func provideVlanService(
	routerPort *router.MockAdapter,
	sugar *zap.SugaredLogger,
) *vlan.VlanService {
	service := vlan.NewVlanService(routerPort)
	sugar.Infow("VLAN service initialized")
	return service
}

// NetworkProviders is a Wire provider set for all network service components.
var NetworkProviders = wire.NewSet(
	provideIPAddressService,
	provideWANService,
	provideBridgeService,
	provideVlanService, wire.Struct(new(NetworkComponents), "*"),
)

// wire_orchestrator.go:

// provideFeatureRegistry creates the feature registry that loads service manifests.
func provideFeatureRegistry() (*features.FeatureRegistry, error) {
	return features.NewFeatureRegistry()
}

// provideDownloadManager creates the download manager for binary downloads.
func provideDownloadManager(
	eventBus events.EventBus,
) *features.DownloadManager {
	return features.NewDownloadManager(eventBus, "/var/nasnet/downloads")
}

// provideProcessSupervisor creates the process supervisor for managing service processes.
func provideProcessSupervisor(
	sugar *zap.SugaredLogger,
) *supervisor.ProcessSupervisor {
	return supervisor.NewProcessSupervisor(supervisor.ProcessSupervisorConfig{Logger: sugar.Desugar()})
}

// provideNetworkStore creates the network store adapter.
func provideNetworkStore(
	systemDB *ent.Client,
) *adapters.EntNetworkAdapter {
	return adapters.NewEntNetworkAdapter(systemDB)
}

// providePortRegistry creates the port registry to prevent port conflicts.
func providePortRegistry(
	networkStore *adapters.EntNetworkAdapter,
) (*network.PortRegistry, error) {
	return network.NewPortRegistry(network.PortRegistryConfig{
		Store:         networkStore,
		Logger:        slog.Default(),
		ReservedPorts: []int{22, 53, 80, 443, 8080, 8291, 8728, 8729},
	})
}

// provideConfigValidator creates the config validator adapter.
func provideConfigValidator(
	sugar *zap.SugaredLogger,
) *isolation.ConfigValidatorAdapter {
	return isolation.NewConfigValidatorAdapter(sugar.Desugar())
}

// provideIsolationVerifier creates the isolation verifier with 4-layer defense.
func provideIsolationVerifier(
	portRegistry *network.PortRegistry,
	configValidator *isolation.ConfigValidatorAdapter,
	eventBus events.EventBus,
	sugar *zap.SugaredLogger,
) (*isolation.IsolationVerifier, error) {
	return isolation.NewIsolationVerifier(isolation.IsolationVerifierConfig{
		PortRegistry:           portRegistry,
		ConfigBindingValidator: configValidator,
		EventBus:               eventBus,
		Logger:                 sugar.Desugar(),
		AllowedBaseDir:         "/data/services",
	})
}

// provideResourceLimiter creates the resource limiter with cgroups v2 support.
func provideResourceLimiter(
	eventBus events.EventBus,
	sugar *zap.SugaredLogger,
) (*resources.ResourceLimiter, error) {
	return resources.NewResourceLimiter(resources.ResourceLimiterConfig{
		EventBus: eventBus,
		Logger:   sugar.Desugar(),
	})
}

// provideResourceManager creates the resource manager for system resource detection.
func provideResourceManager(
	systemDB *ent.Client,
	sugar *zap.SugaredLogger,
) (*resources.ResourceManager, error) {
	return resources.NewResourceManager(resources.ResourceManagerConfig{
		Store:  systemDB,
		Logger: sugar.Desugar(),
	})
}

// provideResourcePoller creates the resource poller for monitoring and warning emission.
func provideResourcePoller(
	resourceLimiter *resources.ResourceLimiter,
	eventBus events.EventBus,
	sugar *zap.SugaredLogger,
) (*resources.ResourcePoller, error) {
	return resources.NewResourcePoller(resources.ResourcePollerConfig{
		ResourceLimiter: resourceLimiter,
		EventBus:        eventBus,
		Logger:          sugar.Desugar(),
	})
}

// provideGitHubClient creates the GitHub client for binary resolution.
func provideGitHubClient() *registry.GitHubClient {
	return registry.NewGitHubClient()
}

// provideIsolationStrategy detects the best process isolation strategy.
func provideIsolationStrategy(
	sugar *zap.SugaredLogger,
) isolation2.Strategy {
	return isolation2.DetectStrategy(sugar.Desugar())
}

// provideInstanceManager creates the instance manager for orchestrating service lifecycle.
func provideInstanceManager(
	systemDB *ent.Client,
	eventBus events.EventBus,
	featureRegistry *features.FeatureRegistry,
	downloadManager *features.DownloadManager,
	processSupervisor *supervisor.ProcessSupervisor,
	gatewayManager lifecycle.GatewayPort,
	bridgeOrchestrator *vif.BridgeOrchestrator,
	vlanAllocator *network.VLANAllocator,
	pathResolver storage.PathResolverPort,
	portRegistry *network.PortRegistry,
	isolationVerifier *isolation.IsolationVerifier,
	isolationStrategy isolation2.Strategy,
	resourceLimiter *resources.ResourceLimiter,
	resourceManager *resources.ResourceManager,
	resourcePoller *resources.ResourcePoller,
	githubClient *registry.GitHubClient,
	sugar *zap.SugaredLogger,
) (*lifecycle.InstanceManager, error) {
	return lifecycle.NewInstanceManager(lifecycle.InstanceManagerConfig{
		Registry:           featureRegistry,
		DownloadMgr:        downloadManager,
		Supervisor:         processSupervisor,
		Gateway:            gatewayManager,
		Store:              systemDB,
		EventBus:           eventBus,
		PathResolver:       pathResolver,
		PortRegistry:       portRegistry,
		VLANAllocator:      vlanAllocator,
		BridgeOrchestrator: bridgeOrchestrator,
		IsolationVerifier:  isolationVerifier,
		IsolationStrategy:  isolationStrategy,
		ResourceLimiter:    resourceLimiter,
		ResourceManager:    resourceManager,
		ResourcePoller:     resourcePoller,
		GitHubClient:       githubClient,
		Logger:             sugar.Desugar(),
	})
}

// provideDependencyManager creates the dependency manager for service instance relationships.
func provideDependencyManager(
	systemDB *ent.Client,
	eventBus events.EventBus,
	sugar *zap.SugaredLogger,
) (*dependencies.DependencyManager, error) {
	return dependencies.NewDependencyManager(dependencies.DependencyManagerConfig{
		Store:    systemDB,
		EventBus: eventBus,
		Logger:   sugar.Desugar(),
	})
}

// provideBootSequenceManager creates the boot sequence manager.
func provideBootSequenceManager(
	systemDB *ent.Client,
	eventBus events.EventBus,
	instanceManager *lifecycle.InstanceManager,
	dependencyManager *dependencies.DependencyManager,
	sugar *zap.SugaredLogger,
) (*boot.BootSequenceManager, error) {
	return boot.NewBootSequenceManager(boot.BootSequenceManagerConfig{
		DependencyMgr: dependencyManager,
		InstanceMgr:   instanceManager,
		Store:         systemDB,
		EventBus:      eventBus,
		Logger:        sugar.Desugar(),
	})
}

// OrchestratorProviders is a Wire provider set for all orchestrator components.
var OrchestratorProviders = wire.NewSet(
	provideFeatureRegistry,
	provideDownloadManager,
	provideProcessSupervisor,
	provideNetworkStore,
	providePortRegistry,
	provideConfigValidator,
	provideIsolationVerifier,
	provideResourceLimiter,
	provideResourceManager,
	provideResourcePoller,
	provideGitHubClient,
	provideIsolationStrategy,
	provideInstanceManager,
	provideDependencyManager,
	provideBootSequenceManager, wire.Struct(new(OrchestratorComponents), "*"),
)

// wire_routing.go:

// provideChainRouter creates the chain router.
func provideChainRouter(
	routerPort *router.MockAdapter,
	systemDB *ent.Client,
	eventBus events.EventBus,
) (*routing.ChainRouter, error) {
	return routing.NewChainRouter(routing.ChainRouterConfig{
		RouterPort: routerPort,
		Store:      systemDB,
		EventBus:   eventBus,
	})
}

// providePBREngine creates the PBR engine.
func providePBREngine(
	routerPort *router.MockAdapter,
	systemDB *ent.Client,
	eventBus events.EventBus,
) *routing.PBREngine {
	pbrPublisher := events.NewPublisher(eventBus, "pbr-engine")
	return routing.NewPBREngine(routerPort, systemDB, eventBus, pbrPublisher)
}

// provideRoutingMatrixService creates the routing matrix service.
func provideRoutingMatrixService(
	routerPort *router.MockAdapter,
	systemDB *ent.Client,
) *routing.RoutingMatrixService {
	return routing.NewRoutingMatrixService(routerPort, systemDB)
}

// provideChainLatencyMeasurer creates the chain latency measurer.
func provideChainLatencyMeasurer(
	systemDB *ent.Client,
	eventBus events.EventBus,
	featureRegistry *features.FeatureRegistry,
) *routing.ChainLatencyMeasurer {
	return routing.NewChainLatencyMeasurer(systemDB, eventBus, featureRegistry)
}

// RoutingProviders is a Wire provider set for all routing engine components.
var RoutingProviders = wire.NewSet(
	provideChainRouter,
	providePBREngine,
	provideRoutingMatrixService,
	provideChainLatencyMeasurer, wire.Struct(new(RoutingComponents), "*"),
)

// wire_scheduling.go:

// provideScheduleEvaluator creates the schedule evaluator.
func provideScheduleEvaluator(
	systemDB *ent.Client,
	eventBus events.EventBus,
	killSwitchCoord orchestrator.KillSwitchCoordinator,
	sugar *zap.SugaredLogger,
) (*scheduling.ScheduleEvaluator, error) {
	evaluatorConfig := scheduling.ScheduleEvaluatorConfig{
		EntClient:           systemDB,
		EventBus:            eventBus,
		KillSwitchCoord:     killSwitchCoord,
		Logger:              sugar.Desugar(),
		NowFunc:             nil,
		RouterClockProvider: nil,
	}

	return scheduling.NewScheduleEvaluator(evaluatorConfig)
}

// provideScheduleService creates the schedule service.
func provideScheduleService(
	systemDB *ent.Client,
	evaluator *scheduling.ScheduleEvaluator,
	eventBus events.EventBus,
	sugar *zap.SugaredLogger,
) (*scheduling.ScheduleService, error) {
	return scheduling.NewScheduleService(scheduling.ScheduleServiceConfig{
		Store:     systemDB,
		Scheduler: evaluator,
		EventBus:  eventBus,
		Logger:    sugar.Desugar(),
	})
}

// SchedulingProviders is a Wire provider set for all scheduling components.
var SchedulingProviders = wire.NewSet(
	provideScheduleEvaluator,
	provideScheduleService, wire.Struct(new(SchedulingComponents), "*"),
)

// wire_storage.go:

// provideStoragePublisher creates a publisher for storage events.
func provideStoragePublisher(eventBus events.EventBus) *events.Publisher {
	return CreatePublisher(eventBus, "storage-infrastructure")
}

// provideStorageDetector creates and starts the storage detector.
func provideStorageDetector(
	publisher *events.Publisher,
	storageLogger *zap.SugaredLogger,
) *storage.StorageDetector {
	detector := storage.NewStorageDetector(storage.DefaultStorageDetectorConfig(
		publisher,
		storageLogger.Desugar(),
	))
	detector.Start()
	return detector
}

// provideStorageConfigService creates the storage config service.
func provideStorageConfigService(
	systemDB *ent.Client,
	detector *storage.StorageDetector,
	publisher *events.Publisher,
	storageLogger *zap.SugaredLogger,
) *storage.StorageConfigService {
	return storage.NewStorageConfigService(
		systemDB,
		detector,
		publisher,
		storageLogger.Desugar(),
	)
}

// providePathResolver creates the path resolver.
func providePathResolver() storage.PathResolverPort {
	return storage.NewDefaultPathResolver(storage.DefaultPathResolverConfig())
}

// provideBootValidator creates and validates boot instances.
func provideBootValidator(
	ctx context.Context,
	systemDB *ent.Client,
	pathResolver storage.PathResolverPort,
	eventBus events.EventBus,
	storageLogger *zap.SugaredLogger,
) (*boot.BootValidator, error) {
	bootValidator, err := boot.NewBootValidator(boot.BootValidatorConfig{
		DB:           systemDB,
		PathResolver: pathResolver,
		EventBus:     eventBus,
		Logger:       storageLogger.Desugar(),
	})
	if err != nil {
		return nil, err
	}

	storageLogger.Infow("Running boot-time instance validation")
	bootSummary, err := bootValidator.ValidateAllInstances(ctx)
	if err != nil {
		storageLogger.Warnw("Boot validation encountered errors", zap.Error(err))
	}
	if bootSummary != nil {
		storageLogger.Infow("Boot validation complete", "total_checked", bootSummary.TotalChecked, "failed_count", bootSummary.FailedCount)
		if bootSummary.FailedCount > 0 {
			storageLogger.Infow("Failed services", "services", bootSummary.FailedServices)
		}
	}

	return bootValidator, nil
}

// StorageProviders is a Wire provider set for all storage infrastructure components.
var StorageProviders = wire.NewSet(
	provideStoragePublisher,
	provideStorageDetector,
	provideStorageConfigService,
	providePathResolver,
	provideBootValidator, wire.Struct(new(StorageComponents), "*"),
)

// wire_templates.go:

// provideTemplateService creates the template service for managing service templates.
func provideTemplateService(
	instanceManager *lifecycle.InstanceManager,
	dependencyManager *dependencies.DependencyManager,
	eventBus events.EventBus,
	logger *zap.Logger,
) (*templates.TemplateService, error) {
	return templates.NewTemplateService(templates.TemplateServiceConfig{
		InstanceManager:   instanceManager,
		DependencyManager: dependencyManager,
		EventBus:          eventBus,
		Logger:            logger,
	})
}

// provideTemplateValidator creates the template validator.
func provideTemplateValidator(
	logger *zap.Logger,
) *templates.TemplateValidator {
	return templates.NewTemplateValidator(templates.TemplateValidatorConfig{
		Logger: logger,
	})
}

// provideTemplateInstaller creates the template installer.
func provideTemplateInstaller(
	templateService *templates.TemplateService,
	instanceManager *lifecycle.InstanceManager,
	dependencyManager *dependencies.DependencyManager,
	eventBus events.EventBus,
	logger *zap.Logger,
) (*templates.TemplateInstaller, error) {
	return templates.NewTemplateInstaller(templates.TemplateInstallerConfig{
		TemplateService:   templateService,
		InstanceManager:   instanceManager,
		DependencyManager: dependencyManager,
		EventBus:          eventBus,
		Logger:            logger,
	})
}

// provideTemplateExporter creates the template exporter.
func provideTemplateExporter(
	systemDB *ent.Client,
	logger *zap.Logger,
) (*templates.TemplateExporter, error) {
	return templates.NewTemplateExporter(templates.TemplateExporterConfig{
		Store:  systemDB,
		Logger: logger,
	})
}

// provideTemplateImporter creates the template importer.
func provideTemplateImporter(
	systemDB *ent.Client,
	templateValidator *templates.TemplateValidator,
	logger *zap.Logger,
) (*templates.TemplateImporter, error) {
	return templates.NewTemplateImporter(templates.TemplateImporterConfig{
		Store:     systemDB,
		Validator: templateValidator,
		Logger:    logger,
	})
}

// TemplateProviders is a Wire provider set for all template system components.
var TemplateProviders = wire.NewSet(
	provideTemplateService,
	provideTemplateValidator,
	provideTemplateInstaller,
	provideTemplateExporter,
	provideTemplateImporter, wire.Struct(new(TemplateComponents), "*"),
)

// wire_traffic.go:

// provideServiceTrafficPoller creates the service traffic poller.
func provideServiceTrafficPoller(
	routerPort *router.MockAdapter,
	eventBus events.EventBus,
) *pollers.ServiceTrafficPoller {
	return pollers.NewServiceTrafficPoller(routerPort, eventBus)
}

// provideTrafficAggregator creates and starts the traffic aggregator.
func provideTrafficAggregator(
	ctx context.Context,
	systemDB *ent.Client,
) *traffic.TrafficAggregator {
	aggregator := traffic.NewTrafficAggregator(systemDB)
	aggregator.Start(ctx)
	return aggregator
}

// provideDeviceTrafficTracker creates the device traffic tracker.
func provideDeviceTrafficTracker(
	routerPort *router.MockAdapter,
) *traffic.DeviceTrafficTracker {
	return traffic.NewDeviceTrafficTracker(routerPort)
}

// provideQuotaEnforcer creates the quota enforcer.
func provideQuotaEnforcer(
	systemDB *ent.Client,
	eventBus events.EventBus,
	routerPort *router.MockAdapter,
) *traffic.QuotaEnforcer {
	return traffic.NewQuotaEnforcer(systemDB, eventBus, routerPort)
}

// TrafficProviders is a Wire provider set for all traffic management components.
var TrafficProviders = wire.NewSet(
	provideServiceTrafficPoller,
	provideTrafficAggregator,
	provideDeviceTrafficTracker,
	provideQuotaEnforcer, wire.Struct(new(TrafficComponents), "*"),
)

// wire_updates.go:

// provideUpdateGitHubClient creates the GitHub client for release checking.
func provideUpdateGitHubClient() *updates.GitHubClient {
	return updates.NewGitHubClient()
}

// provideUpdateService creates the update service for checking available updates.
func provideUpdateService(
	githubClient *updates.GitHubClient,
) (*updates.UpdateService, error) {
	return updates.NewUpdateService(updates.UpdateServiceConfig{
		GitHubClient: githubClient,
	})
}

// provideUpdateVerifier creates the binary verifier for SHA256 verification.
func provideUpdateVerifier() *updates.Verifier {
	return &updates.Verifier{}
}

// provideUpdateJournal creates the update journal for power-safe journaling.
func provideUpdateJournal(
	dataDir string,
) (*updates.UpdateJournal, error) {
	journalPath := filepath.Join(dataDir, "update-journal.db")
	return updates.NewUpdateJournal(journalPath)
}

// provideUpdateMigratorRegistry creates the config migrator registry.
func provideUpdateMigratorRegistry() *updates.MigratorRegistry {
	return &updates.MigratorRegistry{}
}

// provideHealthCheckerAdapter creates the health checker adapter.
func provideHealthCheckerAdapter(
	instanceManager *lifecycle.InstanceManager,
) *instanceHealthAdapter {
	return &instanceHealthAdapter{manager: instanceManager}
}

// provideUpdateDownloadManager creates the download manager for updates.
func provideUpdateDownloadManager(
	downloadManager *features.DownloadManager,
) *updates.DownloadManager {
	return &updates.DownloadManager{
		DownloadFunc: func(ctx context.Context, featureID, url, expectedChecksum string) error {
			return downloadManager.Download(ctx, featureID, url, expectedChecksum)
		},
	}
}

// provideUpdateEngine creates the update engine orchestrating atomic updates.
func provideUpdateEngine(
	downloadManager *updates.DownloadManager,
	verifier *updates.Verifier,
	journal *updates.UpdateJournal,
	migratorRegistry *updates.MigratorRegistry,
	pathResolver storage.PathResolverPort,
	dataDir string,
	eventBus events.EventBus,
	logger *zap.Logger,
	healthChecker *instanceHealthAdapter,
	instanceManager *lifecycle.InstanceManager,
) (*updates.UpdateEngine, error) {
	updateEngine, err := updates.NewUpdateEngine(updates.UpdateEngineConfig{
		DownloadManager:  downloadManager,
		Verifier:         verifier,
		Journal:          journal,
		MigratorRegistry: migratorRegistry,
		PathResolver:     pathResolver,
		BaseDir:          dataDir,
		EventBus:         eventBus,
		Logger:           logger,
		HealthChecker:    healthChecker,
		InstanceStopper:  &instanceStopperAdapter{manager: instanceManager},
		InstanceStarter:  &instanceStarterAdapter{manager: instanceManager},
	})
	if err != nil {
		return nil, err
	}

	if recoveryErr := updateEngine.RecoverFromCrash(context.Background()); recoveryErr != nil {
		logger.Warn("Boot-time update recovery encountered errors", zap.Error(recoveryErr))
	}

	return updateEngine, nil
}

// provideUpdateScheduler creates and starts the update scheduler.
func provideUpdateScheduler(
	updateService *updates.UpdateService,
	updateEngine *updates.UpdateEngine,
	systemDB *ent.Client,
	eventBus events.EventBus,
	logger *zap.Logger,
) (*updates.UpdateScheduler, error) {
	updateScheduler, err := updates.NewUpdateScheduler(updates.UpdateSchedulerConfig{
		UpdateService:   updateService,
		UpdateEngine:    updateEngine,
		Store:           systemDB,
		EventBus:        eventBus,
		Logger:          logger,
		CheckInterval:   6 * time.Hour,
		QuietHoursStart: "02:00",
		QuietHoursEnd:   "06:00",
		Timezone:        "UTC",
	})
	if err != nil {
		return nil, err
	}

	if err := updateScheduler.Start(); err != nil {
		logger.Warn("Failed to start update scheduler", zap.Error(err))
	} else {
		logger.Info("Update scheduler started", zap.String("schedule", "checks every 6h, quiet hours 02:00-06:00 UTC"))
	}

	return updateScheduler, nil
}

// UpdateProviders is a Wire provider set for all update manager components.
var UpdateProviders = wire.NewSet(
	provideUpdateGitHubClient,
	provideUpdateService,
	provideUpdateVerifier,
	provideUpdateJournal,
	provideUpdateMigratorRegistry,
	provideHealthCheckerAdapter,
	provideUpdateDownloadManager,
	provideUpdateEngine,
	provideUpdateScheduler, wire.Struct(new(UpdateComponents), "*"),
)

// wire_vif.go:

// provideNetworkVLANAllocator creates the DB-backed VLAN allocator.
func provideNetworkVLANAllocator(
	systemDB *ent.Client,
	routerPort *router.MockAdapter,
) (*network.VLANAllocator, error) {
	networkStore := adapters.NewEntNetworkAdapter(systemDB)
	return network.NewVLANAllocator(network.VLANAllocatorConfig{
		Store:       networkStore,
		VlanService: &vifVlanServiceAdapter{svc: services.NewVlanService(routerPort)},
		Logger:      nil,
	})
}

// provideVLANAllocatorAdapter wraps NetworkVLANAllocator to satisfy vif.VLANAllocator interface.
func provideVLANAllocatorAdapter(
	networkVLANAllocator *network.VLANAllocator,
) vif.VLANAllocator {
	return vif.NewNetworkVLANAllocatorAdapter(networkVLANAllocator)
}

// provideInterfaceFactory creates the interface factory for VLAN creation.
func provideInterfaceFactory(
	systemDB *ent.Client,
	eventBus events.EventBus,
	routerPort *router.MockAdapter,
) *vif.InterfaceFactory {
	return vif.NewInterfaceFactory(vif.InterfaceFactoryConfig{
		RouterPort:  routerPort,
		Store:       systemDB,
		EventBus:    eventBus,
		ParentIface: "ether1",
	})
}

// provideGatewayManager creates the gateway manager for hev-socks5-tunnel processes.
func provideGatewayManager(
	pathResolver storage.PathResolverPort,
	logger *zap.Logger,
) (*vif.GatewayManager, error) {
	return vif.NewGatewayManager(vif.GatewayManagerConfig{
		Supervisor:    supervisor.NewProcessSupervisor(supervisor.ProcessSupervisorConfig{Logger: logger}),
		PathResolver:  pathResolver,
		HevBinaryPath: "/app/hev-socks5-tunnel",
		Logger:        logger,
	})
}

// provideDHCPServer creates the DHCP server with process supervisor adapter.
func provideDHCPServer(
	logger *zap.Logger,
) *dhcp.Server {
	dhcpSupervisor := supervisor.NewProcessSupervisor(supervisor.ProcessSupervisorConfig{Logger: logger})
	return dhcp.NewServer(&dhcpProcessSupervisorAdapter{ps: dhcpSupervisor}, nil, logger)
}

// provideIngressService creates the ingress service.
func provideIngressService(
	routerPort *router.MockAdapter,
	dhcpServer *dhcp.Server,
	vlanAllocator vif.VLANAllocator,
	logger *zap.Logger,
) *ingress.Service {
	return ingress.NewService(routerPort, dhcpServer, vlanAllocator, logger)
}

// provideBridgeOrchestrator creates the bridge orchestrator.
func provideBridgeOrchestrator(
	systemDB *ent.Client,
	eventBus events.EventBus,
	interfaceFactory *vif.InterfaceFactory,
	gatewayManager *vif.GatewayManager,
	vlanAllocator vif.VLANAllocator,
	routerPort *router.MockAdapter,
	ingressService *ingress.Service,
) *vif.BridgeOrchestrator {
	return vif.NewBridgeOrchestrator(vif.BridgeOrchestratorConfig{
		InterfaceFactory: interfaceFactory,
		GatewayManager:   gatewayManager,
		VLANAllocator:    vlanAllocator,
		Store:            systemDB,
		EventBus:         eventBus,
		RouterPort:       routerPort,
		IngressService:   ingressService,
	})
}

// provideKillSwitchManager creates the kill switch manager.
func provideKillSwitchManager(
	systemDB *ent.Client,
	eventBus events.EventBus,
	routerPort *router.MockAdapter,
) *isolation3.KillSwitchManager {
	publisher := events.NewPublisher(eventBus, "kill-switch-manager")
	return isolation3.NewKillSwitchManager(routerPort, systemDB, eventBus, publisher)
}

// provideKillSwitchListener creates and starts the kill switch listener.
func provideKillSwitchListener(
	ctx context.Context,
	systemDB *ent.Client,
	eventBus events.EventBus,
	killSwitchManager *isolation3.KillSwitchManager,
	logger *zap.Logger,
) (*isolation3.KillSwitchListener, error) {
	publisher := events.NewPublisher(eventBus, "kill-switch-listener")
	listener := isolation3.NewKillSwitchListener(systemDB, eventBus, publisher, killSwitchManager, logger)
	if err := listener.Start(); err != nil {
		logger.Warn("Kill switch listener failed to start", zap.Error(err))

	}
	return listener, nil
}

// VIFProviders is a Wire provider set for all VIF components.
var VIFProviders = wire.NewSet(
	provideNetworkVLANAllocator,
	provideVLANAllocatorAdapter,
	provideInterfaceFactory,
	provideGatewayManager, wire.Bind(new(lifecycle.GatewayPort), new(*vif.GatewayManager)), provideDHCPServer,
	provideIngressService,
	provideBridgeOrchestrator,
	provideKillSwitchManager,
	provideKillSwitchListener, wire.Struct(new(VIFComponents), "*"),
)
